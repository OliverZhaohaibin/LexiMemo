MultiSelectComboBox.py开始
# MultiSelectComboBox.py
from PySide6.QtGui import QStandardItemModel, QStandardItem
from PySide6.QtWidgets import QComboBox
from PySide6.QtCore import Qt
from db import get_all_tags


class MultiSelectComboBox(QComboBox):
    def __init__(self, parent=None, book_name="总单词册", book_color="#FF0000"):
        super(MultiSelectComboBox, self).__init__(parent)
        self.book_name = book_name
        self.book_color = book_color
        self.setModel(QStandardItemModel(self))
        self.add_all_tags_item()
        self.all_tags_item_changed = False
        self.model().itemChanged.connect(self.handle_item_changed)

    def add_all_tags_item(self):
        self.all_tags_item = QStandardItem("全部标签")
        self.all_tags_item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
        self.all_tags_item.setData(Qt.Unchecked, Qt.CheckStateRole)
        self.model().appendRow(self.all_tags_item)

    def addItem(self, text, checked=False):
        if text == "全部标签":
            return
        item = QStandardItem(text)
        item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
        item.setData(Qt.Checked if checked else Qt.Unchecked, Qt.CheckStateRole)
        self.model().appendRow(item)

    def selectedItems(self):
        selected = []
        for index in range(1, self.model().rowCount()):  # Skip "全部标签" at index 0
            item = self.model().item(index)
            if item.checkState() == Qt.Checked:
                selected.append(item.text())
        return selected

    def clear(self):
        self.model().clear()
        self.add_all_tags_item()

    def allItems(self):
        return get_all_tags(self.book_name, self.book_color)

    def handle_item_changed(self, item):
        if self.all_tags_item_changed:
            return
        self.all_tags_item_changed = True
        try:
            if item == self.all_tags_item:
                state = item.checkState()
                for i in range(1, self.model().rowCount()):
                    self.model().item(i).setCheckState(state)
            elif item != self.all_tags_item:
                if item.checkState() == Qt.Unchecked and self.all_tags_item.checkState() == Qt.Checked:
                    self.all_tags_item.setCheckState(Qt.Unchecked)
                elif all(self.model().item(i).checkState() == Qt.Checked for i in range(1, self.model().rowCount())):
                    self.all_tags_item.setCheckState(Qt.Checked)
        finally:
            self.all_tags_item_changed = False
MultiSelectComboBox.py结束

UI/Folder_UI/__init__.py开始
"""ui.folder_ui package

Refactored FolderUI component collection.  This package re-exports the public
interface from :pymod:`ui.folder_ui.api` so that consumers can simply::

    from ui.folder_ui import FolderLayoutMixin, ButtonFrame, ...

and remain insulated from internal module structure changes.
"""

from __future__ import annotations

# ---------------------------------------------------------------------------
# Public re-exports
# ---------------------------------------------------------------------------

from .api import (  # noqa: F401 – re-export; imported for side-effects only
    FolderLayoutMixin,
    FolderOperationMixin,
    FolderAnimationMixin,
    update_all_folder_backgrounds,
    update_folder_background,
    ButtonFrame,
)

__all__: list[str] = [
    "FolderLayoutMixin",
    "FolderOperationMixin",
    "FolderAnimationMixin",
    "update_all_folder_backgrounds",
    "update_folder_background",
    "ButtonFrame",
]

UI/Folder_UI/__init__.py结束

UI/Folder_UI/_animations.py开始
from PySide6.QtCore import QPropertyAnimation, QParallelAnimationGroup, QEasingCurve, QPoint


def create_folder_toggle_animation(folder_button, target_positions, button_width, button_height, spacing):
    """
    创建文件夹展开/关闭的动画

    Args:
        folder_button: 文件夹按钮
        target_positions: 子按钮目标位置列表
        button_width: 按钮宽度
        button_height: 按钮高度
        spacing: 间距

    Returns:
        动画组
    """
    master_anim_group = QParallelAnimationGroup()

    # folder_button.is_expanded 是「目标状态」：
    # True  ➜ 正在展开；False ➜ 正在折叠
    is_expanding = folder_button.is_expanded
    duration_base = 450 if is_expanding else 250  # 折叠更快
    duration_increment = 100 if is_expanding else 40  # 折叠更快

    for index, sub_btn in enumerate(folder_button.sub_buttons):
        if is_expanding:
            # 展开：从文件夹中心移动到目标网格
            sub_btn.show()
            sub_btn.setWindowOpacity(0)
            start_pos = folder_button.pos()
            end_pos = target_positions[index]
        else:
            # 折叠：从当前网格回收至文件夹中心
            start_pos = sub_btn.pos()
            end_pos = folder_button.pos()

        # 位置动画
        pos_anim = QPropertyAnimation(sub_btn, b"pos")
        pos_anim.setDuration(duration_base + index * duration_increment)
        pos_anim.setStartValue(start_pos)
        pos_anim.setEndValue(end_pos)
        pos_anim.setEasingCurve(QEasingCurve.OutBack if is_expanding
                                else QEasingCurve.InBack)
        master_anim_group.addAnimation(pos_anim)

        # 透明度动画
        opacity_anim = QPropertyAnimation(sub_btn, b"windowOpacity")
        opacity_anim.setDuration(duration_base - 50)
        opacity_anim.setStartValue(0 if is_expanding else 1)
        opacity_anim.setEndValue(1 if is_expanding else 0)
        opacity_anim.setEasingCurve(QEasingCurve.InOutQuad)
        master_anim_group.addAnimation(opacity_anim)

        # 折叠结束后隐藏子按钮
        if not is_expanding:
            pos_anim.finished.connect(sub_btn.hide)

    # 动画结束后统一刷新布局
    if folder_button.app:
        master_anim_group.finished.connect(
            folder_button.app.update_button_positions
        )

    return master_anim_group


def create_button_position_animation(button, target_pos, duration=200, easing_curve=QEasingCurve.OutBack):
    """
    创建按钮位置动画
    
    Args:
        button: 按钮
        target_pos: 目标位置
        duration: 动画时长
        easing_curve: 缓动曲线
        
    Returns:
        位置动画
    """
    animation = QPropertyAnimation(button, b"pos")
    animation.setDuration(duration)
    animation.setStartValue(button.pos())
    animation.setEndValue(target_pos)
    animation.setEasingCurve(easing_curve)
    return animation

class FolderAnimationMixin:
    """仅做 *Helper* 封装；完整动画逻辑通常在宿主类自行实现。"""

    create_folder_toggle_animation   = staticmethod(create_folder_toggle_animation)
    create_button_position_animation = staticmethod(create_button_position_animation)


__all__ = [
    "FolderAnimationMixin",
    "create_folder_toggle_animation",
    "create_button_position_animation",
]
UI/Folder_UI/_animations.py结束

UI/Folder_UI/_background.py开始
from PySide6.QtCore import QRect, QPropertyAnimation, QEasingCurve, QAbstractAnimation
from PySide6.QtWidgets import QFrame, QGraphicsOpacityEffect


class FolderBackground(QFrame):
    """文件夹子按钮背景框类"""
    def __init__(self, parent):
        super().__init__(parent)
        self.setStyleSheet("background-color: rgba(240, 240, 240, 0.5); border: 2px dashed #888888;")
        self.setFrameShape(QFrame.Box)
        self.lower()  # 确保背景框在按钮下方
        self.hide()

def calculate_folder_background_rect(folder_button, sub_buttons, button_width, button_height, spacing):
    """计算文件夹背景框的矩形区域"""
    if not folder_button.is_expanded or not sub_buttons:
        return None
    
    # 计算包含所有子按钮的矩形区域
    visible_sub_buttons = [btn for btn in sub_buttons if btn.isVisible()]
    if not visible_sub_buttons:
        return None
        
    min_x = min([btn.x() for btn in visible_sub_buttons])
    min_y = min([btn.y() for btn in visible_sub_buttons])
    max_x = max([btn.x() + button_width for btn in visible_sub_buttons])
    max_y = max([btn.y() + button_height for btn in visible_sub_buttons])
    
    # 添加边距
    margin = spacing // 2
    return QRect(min_x - margin, min_y - margin, max_x - min_x + margin * 2, max_y - min_y + margin * 2)

def update_folder_background(app, folder_button):
    """
    更新单个文件夹的灰色背景框 —— 带动画：
      • 位置/尺寸变化：250 ms OutCubic
      • 显示时淡入：250 ms OutQuad
      • 隐藏时淡出：200 ms InQuad
    """

    # 1. 初次创建背景框
    if not hasattr(folder_button, "background_frame"):
        folder_button.background_frame = FolderBackground(app.scroll_content)
        folder_button.background_frame.lower()

        # 绑定透明度效果（适用于子控件）
        effect = QGraphicsOpacityEffect(folder_button.background_frame)
        effect.setOpacity(1.0)
        folder_button.background_frame.setGraphicsEffect(effect)

    frame = folder_button.background_frame
    effect = frame.graphicsEffect()  # type: QGraphicsOpacityEffect

    # 2. 计算应否显示以及目标矩形
    target_rect = calculate_folder_background_rect(
        folder_button,
        folder_button.sub_buttons,
        app.button_width,
        app.button_height,
        app.spacing,
    )

    # ---------- 需要显示 / 更新 ---------- #
    if folder_button.is_expanded and folder_button.sub_buttons and target_rect:
        # 几何动画（尺寸 / 位置）
        if frame.geometry() != target_rect:
            geom_anim = QPropertyAnimation(frame, b"geometry", frame)
            geom_anim.setDuration(250)
            geom_anim.setEasingCurve(QEasingCurve.OutCubic)
            geom_anim.setStartValue(frame.geometry() if frame.isVisible() else target_rect)
            geom_anim.setEndValue(target_rect)
            geom_anim.start(QAbstractAnimation.DeleteWhenStopped)

        # 若当前隐藏 → 淡入
        if frame.isHidden():
            frame.setGeometry(target_rect)
            frame.show()
            effect.setOpacity(0.0)

            fade_in = QPropertyAnimation(effect, b"opacity", frame)
            fade_in.setDuration(250)
            fade_in.setEasingCurve(QEasingCurve.OutQuad)
            fade_in.setStartValue(0.0)
            fade_in.setEndValue(1.0)
            fade_in.start(QAbstractAnimation.DeleteWhenStopped)

    # ---------- 需要隐藏 ---------- #
    else:
        if frame.isVisible():
            fade_out = QPropertyAnimation(effect, b"opacity", frame)
            fade_out.setDuration(200)
            fade_out.setEasingCurve(QEasingCurve.InQuad)
            fade_out.setStartValue(effect.opacity())
            fade_out.setEndValue(0.0)

            def _after_hide():
                frame.hide()
                effect.setOpacity(1.0)  # 复位，以便下次直接显示

            fade_out.finished.connect(_after_hide)
            fade_out.start(QAbstractAnimation.DeleteWhenStopped)

def update_all_folder_backgrounds(app, button_width, button_height):
    """更新所有文件夹的背景框"""
    # 先隐藏所有背景框，确保Z顺序正确
    for btn in app.buttons:
        if btn.is_folder and hasattr(btn, 'background_frame'):
            btn.background_frame.lower()
    
    # 然后更新所有文件夹背景
    for btn in app.buttons:
        if btn.is_folder:
            update_folder_background(app, btn)
UI/Folder_UI/_background.py结束

UI/Folder_UI/_frame.py开始
from PySide6.QtWidgets import QFrame


class ButtonFrame(QFrame):
    """
    自定义框架类，用于显示不同类型的边框提示
    """
    def __init__(self, parent, border_style):
        super().__init__(parent)
        self.setFrameShape(QFrame.Box)
        self.setLineWidth(2)
        self.setStyleSheet(border_style)
        self.hide()
UI/Folder_UI/_frame.py结束

UI/Folder_UI/_layout.py开始
from PySide6.QtCore import QPoint, QRect


def calculate_main_button_positions(buttons, button_width, button_height, spacing, central_widget_width):
    """
    计算主界面按钮的位置
    
    Args:
        buttons: 按钮列表
        button_width: 按钮宽度
        button_height: 按钮高度
        spacing: 间距
        central_widget_width: 中央部件宽度
        
    Returns:
        按钮位置列表
    """
    target_positions = []
    current_x = spacing
    current_y = spacing + 40  # 留出编辑按钮的空间
    buttons_per_row = max(1, (central_widget_width - spacing) // (button_width + spacing))
    
    for i in range(len([btn for btn in buttons if not btn.is_sub_button])):
        if current_x + button_width > central_widget_width - spacing:
            current_y += button_height + spacing
            current_x = spacing
        target_positions.append(QPoint(current_x, current_y))
        current_x += button_width + spacing
        
    return target_positions


def calculate_sub_button_positions(folder_button, button_width, button_height, spacing, central_widget_width, folder_extra_width):
    """
    计算文件夹内子按钮的位置
    """
    target_positions = []
    # 删除folder_spacing,直接使用spacing
    current_y = folder_button.y() + button_height + spacing
    available_width = central_widget_width - spacing * 2 + folder_extra_width
    buttons_per_row = max(1, available_width // (button_width + spacing))
    rows = (len(folder_button.sub_buttons) + buttons_per_row - 1) // buttons_per_row
    
    for row in range(rows):
        for col in range(buttons_per_row):
            if len(target_positions) < len(folder_button.sub_buttons):
                # 使用统一的spacing
                x = spacing + col * (button_width + spacing)
                y = current_y + row * (button_height + spacing)
                target_positions.append(QPoint(x, y))
                
    return target_positions


def calculate_folder_area(folder_button, sub_buttons, button_width, button_height):
    """
    计算文件夹区域（包括文件夹按钮和所有子按钮）
    
    Args:
        folder_button: 文件夹按钮
        sub_buttons: 子按钮列表
        button_width: 按钮宽度
        button_height: 按钮高度
        
    Returns:
        文件夹区域的左上角坐标和右下角坐标
    """
    min_x = folder_button.x()
    min_y = folder_button.y()
    max_x = folder_button.x() + button_width
    max_y = folder_button.y() + button_height
    
    for sub_btn in sub_buttons:
        min_x = min(min_x, sub_btn.x())
        min_y = min(min_y, sub_btn.y())
        max_x = max(max_x, sub_btn.x() + button_width)
        max_y = max(max_y, sub_btn.y() + button_height)
        
    return min_x, min_y, max_x, max_y


def calculate_reorder_area(folder_button, button_width, button_height, spacing, central_widget_width, folder_extra_width):
    """
    计算文件夹内重排序区域

    Args:
        folder_button: 文件夹按钮
        button_width: 按钮宽度
        button_height: 按钮高度
        spacing: 间距
        central_widget_width: 中央部件宽度
        folder_extra_width: 文件夹额外宽度

    Returns:
        重排序区域
    """
    folder_spacing = spacing * 1.5
    available_width = central_widget_width - folder_spacing * 1.5 + folder_extra_width
    buttons_per_row = max(1, available_width // (button_width + folder_spacing))
    rows = (len(folder_button.sub_buttons) + buttons_per_row - 1) // buttons_per_row

    left = 0  # ✅ 左边界固定为0，不跟随按钮
    top = folder_button.y() + button_height
    width = central_widget_width  # ✅ 全宽
    height = (rows * (button_height + folder_spacing)) + folder_spacing * 1.01

    return QRect(left, top, width, height)

class FolderLayoutMixin:
    """为任意 QWidget 子类提供布局计算工具的无状态混入。"""

    # 直接把函数挂成静态方法，避免重复实现
    calculate_main_button_positions = staticmethod(calculate_main_button_positions)
    calculate_sub_button_positions  = staticmethod(calculate_sub_button_positions)
    calculate_folder_area           = staticmethod(calculate_folder_area)
    calculate_reorder_area          = staticmethod(calculate_reorder_area)


__all__ = [
    "FolderLayoutMixin",
    "calculate_main_button_positions",
    "calculate_sub_button_positions",
    "calculate_folder_area",
    "calculate_reorder_area",
]
UI/Folder_UI/_layout.py结束

UI/Folder_UI/_operations.py开始
from .button import DraggableButton



def merge_buttons_to_folder(btn1, btn2, central_widget, app):
    """
    将两个按钮合并为一个文件夹
    
    Args:
        btn1: 第一个按钮
        btn2: 第二个按钮
        central_widget: 中央部件
        app: 应用程序实例
        
    Returns:
        创建的文件夹按钮
    """
    folder_name = f"Folder {len([b for b in app.buttons if b.is_folder]) + 1}"
    folder_button = DraggableButton(folder_name, central_widget, app)
    folder_button.is_folder = True
    folder_button.move(btn1.pos())
    folder_button.setStyleSheet("background-color: #f0f0f0; font-weight: bold;")
    
    # 将原按钮作为子按钮加入文件夹
    if btn1.is_folder:
        folder_button.sub_buttons.extend(btn1.sub_buttons)
    else:
        sub_btn1 = DraggableButton(btn1.text(), central_widget, app)
        sub_btn1.is_sub_button = True
        sub_btn1.parent_folder = folder_button
        folder_button.sub_buttons.append(sub_btn1)
        sub_btn1.hide()
        
    if btn2.is_folder:
        folder_button.sub_buttons.extend(btn2.sub_buttons)
    else:
        sub_btn2 = DraggableButton(btn2.text(), central_widget, app)
        sub_btn2.is_sub_button = True
        sub_btn2.parent_folder = folder_button
        folder_button.sub_buttons.append(sub_btn2)
        sub_btn2.hide()
        
    return folder_button


def add_button_to_folder(button_to_add, folder, central_widget, app):
    """
    将按钮添加到现有文件夹
    
    Args:
        button_to_add: 要添加的按钮
        folder: 目标文件夹
        central_widget: 中央部件
        app: 应用程序实例
        
    Returns:
        创建的子按钮
    """
    sub_btn = DraggableButton(button_to_add.text(), central_widget, app)
    sub_btn.is_sub_button = True
    sub_btn.parent_folder = folder
    folder.sub_buttons.append(sub_btn)
    sub_btn.hide()  # 初始隐藏
    
    return sub_btn


def remove_sub_button_from_folder(sub_btn, buttons_list):
    """
    从文件夹中移除子按钮
    
    Args:
        sub_btn: 要移除的子按钮
        buttons_list: 主按钮列表
    """
    parent_folder = sub_btn.parent_folder
    if parent_folder:
        if sub_btn in parent_folder.sub_buttons:
            parent_folder.sub_buttons.remove(sub_btn)
        if sub_btn not in buttons_list:
            buttons_list.append(sub_btn)
        sub_btn.is_sub_button = False
        sub_btn.parent_folder = None
        sub_btn.show()
        
        return parent_folder
    return None


def check_and_remove_folder_if_needed(folder_btn, buttons_list):
    """
    检查并在需要时移除文件夹（当文件夹内按钮少于2个时）
    
    Args:
        folder_btn: 文件夹按钮
        buttons_list: 主按钮列表
        
    Returns:
        bool: 是否移除了文件夹
    """
    if len(folder_btn.sub_buttons) < 2:
        print(f"文件夹 {folder_btn.text()} 内按钮不足2个，执行删除文件夹操作")
        if folder_btn in buttons_list:
            buttons_list.remove(folder_btn)
        if len(folder_btn.sub_buttons) == 1:
            remaining_btn = folder_btn.sub_buttons[0]
            remaining_btn.is_sub_button = False
            remaining_btn.parent_folder = None
            if remaining_btn not in buttons_list:
                buttons_list.append(remaining_btn)
        
        # 移除文件夹背景框
        if hasattr(folder_btn, 'background_frame'):
            folder_btn.background_frame.hide()
            folder_btn.background_frame.deleteLater()
            
        folder_btn.hide()
        return True
    return False
class FolderOperationMixin:
    """封装文件夹增删改操作的工具混入。"""

    merge_buttons_to_folder          = staticmethod(merge_buttons_to_folder)
    add_button_to_folder             = staticmethod(add_button_to_folder)
    remove_sub_button_from_folder    = staticmethod(remove_sub_button_from_folder)
    check_and_remove_folder_if_needed = staticmethod(check_and_remove_folder_if_needed)


__all__ = [
    "FolderOperationMixin",
    "merge_buttons_to_folder",
    "add_button_to_folder",
    "remove_sub_button_from_folder",
    "check_and_remove_folder_if_needed",
]

UI/Folder_UI/_operations.py结束

UI/Folder_UI/_utils.py开始
import math
from typing import Sequence, Tuple, Union
from PySide6.QtCore import QPoint, QRect
import os
import sys
from pathlib import Path
from PIL import Image

def calculate_button_distance(btn1, btn2, button_width, button_height):
    """
    计算两个按钮中心点之间的距离
    """
    center1 = btn1.pos() + QPoint(button_width // 2, button_height // 2)
    center2 = btn2.pos() + QPoint(button_width // 2, button_height // 2)
    dx = center1.x() - center2.x()
    dy = center1.y() - center2.y()
    return math.sqrt(dx * dx + dy * dy)


def is_button_in_frame(button, frame):
    """
    检查按钮是否在框架内
    """
    button_rect = QRect(button.pos(), button.size())
    frame_rect = QRect(frame.pos(), frame.size())
    return frame_rect.contains(button_rect)


def create_folder_icon(
    sub_icon_paths: Sequence[Union[str, Path]],
    folder_name: str,
    out_path: Union[str, Path] = None,
    *,
    cell_size: int = 120,                 # ⬆️ 缩略图默认尺寸
    grid_size: Tuple[int, int] = (3, 3),
    spacing: int = 1,                    # ⬇️ 间距默认
    bg_color: Tuple[int, int, int, int] = (255, 255, 255, 0),
) -> str:
    """
    将最多 9 张子图标拼成一个九宫格缩略图（iOS 文件夹风格）。

    Parameters
    ----------
    sub_icon_paths : Sequence[str | Path]
        子按钮图标的文件路径列表。
    folder_name : str
        文件夹名称，用于生成输出文件名（格式为 ``folder_<文件夹名称>.png``）。
    out_path : str | Path, optional
        输出文件路径；为空则自动写入 <程序目录>/icon/ 目录，且文件名遵循
        ``folder_<文件夹名称>.png`` 的规则。
    cell_size : int, default 120
        单个子图在九宫格里的边长（像素）。
    grid_size : (int, int), default (3, 3)
        网格列数 × 行数。
    spacing : int, default 1
        子图之间以及与外边缘的间距。
    bg_color : (R, G, B, A), default (255, 255, 255, 0)
        背景颜色（含透明度）。

    Returns
    -------
    str
        合成图保存的绝对路径
    """
    # ---------- 计算整体尺寸 ----------
    cols, rows = grid_size
    total_w = cols * cell_size + (cols + 1) * spacing
    total_h = rows * cell_size + (rows + 1) * spacing
    canvas = Image.new("RGBA", (total_w, total_h), bg_color)

    # ---------- 粘贴子图 ----------
    for idx, icon_path in enumerate(sub_icon_paths[: rows * cols]):
        try:
            icon = Image.open(icon_path).convert("RGBA").resize(
                (cell_size, cell_size), Image.LANCZOS
            )
        except (FileNotFoundError, OSError):
            continue

        col = idx % cols
        row = idx // cols
        x = spacing + col * (cell_size + spacing)
        y = spacing + row * (cell_size + spacing)
        canvas.alpha_composite(icon, (x, y))

    # ---------- 保存 ----------
    if out_path is None:
        base_dir = Path(os.path.dirname(os.path.abspath(sys.argv[0]))) / "icon"
        base_dir.mkdir(parents=True, exist_ok=True)
        # 统一命名：folder_<文件夹名称>.png
        out_path = base_dir / f"folder_{folder_name}.png"

    out_path = Path(out_path)
    canvas.save(out_path)
    return str(out_path)
UI/Folder_UI/_utils.py结束

UI/Folder_UI/api.py开始
# UI/Folder_UI/api.py   ← 新文件名，无 “.” 前缀
"""
Public façade for the *Folder-UI* subsystem.

外部模块只需::

    from UI.Folder_UI import FolderLayoutMixin, ButtonFrame, ...

即可安全使用，与内部文件结构解耦。
"""

from __future__ import annotations

# ----------------  对外稳定接口  ----------------
from ._layout      import FolderLayoutMixin
from ._operations   import FolderOperationMixin
from ._animations   import FolderAnimationMixin
from ._background   import update_all_folder_backgrounds, update_folder_background
from ._frame        import ButtonFrame

__all__: list[str] = [
    "FolderLayoutMixin",
    "FolderOperationMixin",
    "FolderAnimationMixin",
    "update_all_folder_backgrounds",
    "update_folder_background",
    "ButtonFrame",
]
UI/Folder_UI/api.py结束

UI/Folder_UI/button.py开始
import math
from typing import Optional, Tuple

from PySide6.QtCore import Qt, QPoint, QPropertyAnimation, QRect, QEasingCurve, QParallelAnimationGroup, QSize
from PySide6.QtGui import QPainter
from PySide6.QtWidgets import QPushButton, QStyleOptionButton, QStyle
from PySide6.QtCore import Property


class DraggableButton(QPushButton):
    def __init__(self, text, parent, app=None):
        super().__init__(text, parent)
        self.parent_widget = parent
        self.app = app  # 主应用窗口引用
        self.drag_start_position = QPoint()
        self.is_dragging = False
        self.setFixedSize(100, 50)
        self.is_folder = False  # 是否为文件夹按钮
        self.sub_buttons = []  # 存储子按钮
        self.is_expanded = False  # 文件夹是否展开

        # 新增属性，用于标识是否为文件夹内的子按钮
        self.is_sub_button = False
        self.parent_folder = None  # 若为子按钮，记录所属文件夹
        self.drag_out_threshold_exceeded = False  # 标记是否拖出阈值

        # 抖动动画相关
        self.jitter_animation_group = QParallelAnimationGroup(self)
        self.jitter_animations = []  # 存储动画对象，方便管理
        self._rotation = 0  # 用于旋转动画的属性

        # 新增：文件夹展开/关闭动画组属性，防止重复触发
        self.folder_animation_group = None
        # ➤➤➤ 新增：删除小按钮（右上角 ✕） ← iOS 风格
        self.delete_button = QPushButton("✕", self)
        self.delete_button.setFixedSize(22, 22)
        self.delete_button.move(self.width() - self.delete_button.width(), 0)
        self.delete_button.setStyleSheet("""
                   QPushButton {
                       background-color: #FF4D4D;
                       color: #FFFFFF;
                       border: none;
                       border-radius: 11px;
                       font-weight: bold;
                   }
                   QPushButton:hover { background-color: #FF8080; }
               """)
        self.delete_button.hide()
        self.delete_button.clicked.connect(self.on_delete_clicked)

    # ✕ 按钮点击 —— 主按钮走 delete_word_book，子按钮走 remove_sub_button_from_folder
    def on_delete_clicked(self):
        """✕ 按钮点击：主按钮、子按钮统一直接删除单词册。

        现在加入保护：主单词册（“总单词册”）永远不可删除。
        """
        # —— 主单词册保护 —— #
        if self.text() == "总单词册":
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(
                self,
                "提示",
                "『总单词册』是主单词册，无法删除！"
            )
            return

        # —— 原有逻辑 —— #
        if getattr(self, "is_new_button", False):
            return  # “新建单词册” 不可删

        if hasattr(self.app, "delete_word_book"):
            self.app.delete_word_book(self)

    def start_jitter(self):
        if self.jitter_animation_group.state() == QPropertyAnimation.Running:
            return  # 避免重复启动

        duration = 200  # 动画时长增加到200毫秒，使抖动更平滑
        rotation_angle = 3  # 旋转角度保持不变

        # 清空之前的动画
        self.jitter_animation_group.stop()
        self.jitter_animation_group.clear()
        self.jitter_animations = []

        # 优化旋转动画的关键帧分布，使动画更加平滑
        animation_rotation = QPropertyAnimation(self, b"rotation")
        animation_rotation.setDuration(duration)
        animation_rotation.setKeyValueAt(0, 0)
        animation_rotation.setKeyValueAt(0.3, -rotation_angle)
        animation_rotation.setKeyValueAt(0.5, 0)
        animation_rotation.setKeyValueAt(0.7, rotation_angle)
        animation_rotation.setKeyValueAt(1, 0)
        self.jitter_animations.append(animation_rotation)

        for anim in self.jitter_animations:
            self.jitter_animation_group.addAnimation(anim)

        self.jitter_animation_group.setLoopCount(-1)  # 无限循环
        self.jitter_animation_group.start()
        # ➤ 更新 ✕ 按钮可见性
        self.update_delete_button_visibility()

    # 根据当前是否处于编辑模式决定 ✕ 是否可见
    def update_delete_button_visibility(self):
        """根据是否处于编辑模式决定 ✕ 按钮可见性，并禁止主单词册出现✕ 按钮。"""
        show = (
            self.app
            and getattr(self.app, "edit_mode", False)
            and not getattr(self, "is_new_button", False)
            and self.text() != "总单词册"          # ⭐ 关键：主单词册不显示删除按钮
        )
        self.delete_button.move(self.width() - self.delete_button.width(), 0)
        self.delete_button.setVisible(show)

    def stop_jitter(self):
        if self.jitter_animation_group.state() == QPropertyAnimation.Running:
            self.jitter_animation_group.stop()
            self._rotation = 0
            self.update()
        # ➤ 隐藏 ✕ 按钮
        self.update_delete_button_visibility()

    # 添加rotation属性的getter和setter方法，用于旋转动画
    @Property(float)
    def rotation(self):
        return self._rotation

    @rotation.setter
    def rotation(self, angle):
        self._rotation = angle
        self.update()  # 触发重绘

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # 保存当前状态
        painter.save()

        # 如果有旋转角度，应用旋转变换
        if self._rotation != 0:
            painter.translate(self.width() / 2, self.height() / 2)
            painter.rotate(self._rotation)
            painter.translate(-self.width() / 2, -self.height() / 2)

        # 绘制按钮背景
        option = QStyleOptionButton()
        option.initFrom(self)
        option.state = QStyle.State_Enabled
        if self.isDown():
            option.state |= QStyle.State_Sunken
        elif self.isChecked():
            option.state |= QStyle.State_On
        elif not self.isFlat():
            option.state |= QStyle.State_Raised
        option.rect = self.rect()
        self.style().drawControl(QStyle.CE_PushButton, option, painter, self)

        # 绘制按钮文本
        painter.setPen(self.palette().buttonText().color())
        painter.drawText(self.rect(), Qt.AlignCenter, self.text())

        # 恢复状态
        painter.restore()

    def mousePressEvent(self, event):
        """
        左键按下 —— 准备拖动（仅编辑模式）

        ✨ 关键点
        ------------------------------------------------------------------
        1. 依旧调用 collapse_all_folders() 折叠全部文件夹；
        2. 记录 _cursor_offset（鼠标位于按钮内的相对坐标）；
        3. 折叠后启动一个 10 ms 周期的 QTimer（持续 0-800 ms）：
              • 每次 timeout → _recenter()，同步滚动条并把按钮
                调整到「当前鼠标全局坐标 − _cursor_offset」处，
                同时更新 drag_start_position。
           因为 _recenter() 每次都取实时鼠标位置，所以拖动过程
           中的任何鼠标移动都会被立即补偿。
        """
        """按下：开启拖拽 + 启动补偿计时器（800 ms 后自动停止）。"""
        if event.button() == Qt.LeftButton and self.app.edit_mode:
            from PySide6.QtCore import QTimer, QPoint
            from PySide6.QtGui  import QCursor

            # —— ① 缓存原位置 —— #
            self._origin_pos = self.pos()

            # —— ② 启动拖拽 —— #
            cursor_global       = event.globalPosition().toPoint()
            btn_global          = self.mapToGlobal(QPoint(0, 0))
            self._cursor_offset = cursor_global - btn_global
            self.drag_start_position = cursor_global
            self.raise_()
            self.is_dragging = True
            self.setStyleSheet("background-color: lightblue;")

            # —— ③ 折叠文件夹 + 创建补偿计时器 —— #
            if not self.is_sub_button and callable(getattr(self.app, "collapse_all_folders", None)):
                scroll_area = getattr(self.app, "scroll_area", None)
                old_scroll  = scroll_area.verticalScrollBar().value() if scroll_area else None
                self.app.collapse_all_folders()

                def _recenter():
                    if scroll_area and old_scroll is not None:
                        sb = scroll_area.verticalScrollBar()
                        sb.setValue(min(old_scroll, sb.maximum()))
                    cursor_now    = QCursor.pos()
                    target_global = cursor_now - self._cursor_offset
                    shift         = target_global - self.mapToGlobal(QPoint(0, 0))
                    if shift:
                        self.move(self.pos() + shift)
                    self.drag_start_position = cursor_now

                self._recenter_timer = QTimer(self)
                self._recenter_timer.setInterval(10)
                self._recenter_timer.timeout.connect(_recenter)
                self._recenter_timer.start()
                _recenter()  # 立即补偿首帧

                # —— ④ 800 ms 后安全停止 —— #
                QTimer.singleShot(800, self._stop_recenter_timer)

        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if not (event.buttons() & Qt.LeftButton) or not self.is_dragging or not self.app.edit_mode:
            return

        delta = event.globalPosition().toPoint() - self.drag_start_position
        new_pos = self.pos() + delta
        self.move(new_pos)
        self.drag_start_position = event.globalPosition().toPoint()

        # 如果是文件夹内的子按钮，则执行拖出或重排序逻辑
        if self.is_sub_button and self.parent_folder and self.app.edit_mode:
            # 计算文件夹内子按钮的布局区域
            folder_spacing = self.app.spacing * 1.5
            available_width = self.app.central_widget.width() - folder_spacing * 1.5 + self.app.folder_extra_width
            buttons_per_row = max(1, available_width // (self.app.button_width + folder_spacing))
            rows = (len(self.parent_folder.sub_buttons) + buttons_per_row - 1) // buttons_per_row

            # 计算重排序区域的边界
            reorder_area_left = self.parent_folder.x() - folder_spacing
            reorder_area_top = self.parent_folder.y() + self.app.button_height
            reorder_area_width = available_width + folder_spacing * 1.01
            reorder_area_height = (rows * (self.app.button_height + folder_spacing)) + folder_spacing * 1.01
            reorder_area = QRect(reorder_area_left, reorder_area_top, reorder_area_width, reorder_area_height)

            # 判断按钮是否在重排序区域内
            button_rect = QRect(self.pos(), self.size())
            if reorder_area.contains(button_rect.center()):
                # 显示蓝色框表示文件夹内重排序区域
                self.app.show_blue_reorder_frame(self.parent_folder)
                self.app.hide_red_removal_frame()
                self.drag_out_threshold_exceeded = False
                # 实时更新文件夹内子按钮排序（直接更新位置，无动画）
                self.app.update_sub_button_order(self.parent_folder, dragged_sub_button=self, realtime=True)
            else:
                # 超过阈值，显示红色框提示拖出文件夹
                self.app.hide_blue_reorder_frame()
                self.app.show_red_removal_frame(self.parent_folder)
                self.drag_out_threshold_exceeded = True
        else:
            # 主界面按钮执行原有的靠近检测和排序
            self.app.check_button_proximity(self)
            self.app.update_button_order(self)

    def mouseReleaseEvent(self, event):
        """
                拖拽释放 / 普通点击统一入口
                • 拖拽场景：保持子按钮重排序、文件夹合并等原有逻辑
                • 点击场景：编辑模式下仅做拖拽；非编辑模式才允许打开 / 展开
                同时在 super() 之后 setDown(False) 立即复位 pressed 颜色
                """
        """释放：停止补偿计时器；正常收尾（排序 / 合并 / 回弹）"""
        if self.app.edit_mode and self.is_dragging:
            self.is_dragging = False
            self.setStyleSheet("")

            # —— A. 子按钮 —— #
            if self.is_sub_button and self.parent_folder:
                if not self.drag_out_threshold_exceeded:
                    self.app.update_sub_button_order(
                        self.parent_folder, dragged_sub_button=self, realtime=False
                    )
                else:
                    self.app.remove_sub_button_from_folder(self)
                self.app.hide_blue_reorder_frame()
                self.app.hide_red_removal_frame()
                self.drag_out_threshold_exceeded = False

            # —— B. 主按钮 —— #
            else:
                if self.app.frame_visible and self.app.is_button_in_frame(self):
                    self.app.merge_folders()
                self.app.finalize_button_order()
                self.app.hide_frame()
                if not self.is_sub_button:
                    self.app.expand_all_folders()

            self.app.update_button_positions()

        elif not self.app.edit_mode and getattr(self, "is_folder", False):
            self.app.toggle_folder(self)

            # —— ★ 安全停止补偿计时器 —— #
        self._stop_recenter_timer()

        super().mouseReleaseEvent(event)
        self.setDown(False)
        self.update()

    # ============================================================
#  Button —— 计时器安全处理
# ============================================================

    def _stop_recenter_timer(self):
        """安全停止并销毁 _recenter_timer（若存在）。"""
        if hasattr(self, "_recenter_timer") and self._recenter_timer:
            if self._recenter_timer.isActive():
                self._recenter_timer.stop()
            self._recenter_timer.deleteLater()
            self._recenter_timer = None

UI/Folder_UI/button.py结束

UI/__init__.py开始
from UI.word_book_inside.word_book_window import WordBookWindow
from UI.word_book_inside.word_detail_panel import WordDetailPanel
from UI.word_book_inside.word_edit_panel import WordEditPanel
from UI.word_book_inside.word_list_panel import WordListPanel

__all__ = [
    "WordBookWindow",
    "WordListPanel",
    "WordDetailPanel",
    "WordEditPanel",
]

UI/__init__.py结束

UI/cover_content.py开始
from __future__ import annotations

from PySide6.QtCore import QEvent
from PySide6.QtWidgets import QWidget

from UI.Folder_UI.common.folderUI_API import (
    FolderAnimationMixin,
    FolderLayoutMixin,
    FolderHintMixin,
    FolderOperationMixin,
)
from UI.Folder_UI._background import update_all_folder_backgrounds
from UI.Folder_UI._frame import ButtonFrame
from WordBookButton import WordBookButton


class CoverContent(
    FolderAnimationMixin,
    FolderLayoutMixin,
    FolderHintMixin,
    FolderOperationMixin,
    QWidget,
):
    """Scroll‑area content that actually lays out the word‑book buttons and
    handles drag‑and‑drop / folder UI interactions.  It fulfils all
    dependencies required by the 4 FolderUI mixins.
    """

    def __init__(self, parent=None) -> None:
        # *parent* must be the ``QScrollArea`` that hosts this widget.
        super().__init__(parent)
        if parent is None:
            raise ValueError("CoverContent must be constructed with its QScrollArea as parent")

        # ---------- external references ----------
        self.scroll_area = parent          # type: QScrollArea
        self.scroll_content = self         # mixins expect this alias

        # ---------- layout parameters ----------
        self.button_width: int = 120
        self.button_height: int = 150
        self.spacing: int = 10
        self.folder_extra_width: int = 150

        # ---------- runtime state ----------
        self.edit_mode: bool = False
        self.buttons: list[WordBookButton] = []

        # ---------- hint frames ----------
        self.frame = ButtonFrame(
            self,
            "border:2px dashed #3498db; background:rgba(52,152,219,.1);",
        )  # blue merge rectangle
        self.blue_reorder_frame = ButtonFrame(
            self,
            "border:2px dashed blue; background:rgba(0,0,255,.1);",
        )  # blue internal‑order rectangle
        self.red_removal_frame = ButtonFrame(
            self,
            "border:2px dashed red; background:rgba(255,0,0,.1);",
        )  # red removal rectangle
        self.frame_visible: bool = False
        self.blue_reorder_frame.hide()
        self.red_removal_frame.hide()

        # ---------- “新建单词本” ----------
        self.new_book_button = WordBookButton(
            "新建单词本",
            "#a3d2ca",
            parent=self,
            app=self,
        )
        self.new_book_button.is_new_button = True
        # click signal will be rebound by controller

        # intercept wheel so that hint rectangles disappear while scrolling
        self.scroll_area.viewport().installEventFilter(self)

    # ------------------------------------------------------------------
    # FolderOperationMixin callback
    # ------------------------------------------------------------------
    def show_word_book(self, path: str, target_word: str | None = None) -> None:
        """Open the inside‑window for a single word book."""
        if self.edit_mode:
            return
        win = WordBookApp(path, target_word=target_word)
        win.show()

    # ------------------------------------------------------------------
    # QWidget overrides
    # ------------------------------------------------------------------
    def resizeEvent(self, event):  # noqa: D401
        super().resizeEvent(event)
        self.update_button_positions()
        update_all_folder_backgrounds(self, self.button_width, self.button_height)

    def eventFilter(self, obj, ev):
        if ev.type() == QEvent.Wheel and self.frame_visible:
            # hide hint rectangles while scrolling
            self.hide_frame()
        return super().eventFilter(obj, ev)

UI/cover_content.py结束

UI/cover_view.py开始
# ui/cover_view.py
from __future__ import annotations

from PySide6.QtCore    import Qt, Signal, QEvent

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QScrollArea,
    QPushButton, QLineEdit, QListWidget, QLabel
)
from UI.cover_content import CoverContent
from styles import SECONDARY_BUTTON_STYLE, TEXT_EDIT_STYLE


class CoverView(QWidget):
    """
    纯 UI：标题栏 = 编辑按钮 + 全局搜索框
    中部 = ScrollArea，内部由 Controller 绝对定位各 WordBookButton
    """

    editToggled         = Signal(bool)
    searchTextChanged   = Signal(str)
    suggestionSelected  = Signal(str)     # 用户点击 / 回车确定的词

    # ------------------------------------------------------------
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("背单词程序")
        self.resize(660, 720)

        # ========= ① 头部 =========
        self.edit_btn = QPushButton("编辑")
        self.edit_btn.setFixedSize(60, 30)
        self.edit_btn.setStyleSheet(SECONDARY_BUTTON_STYLE)

        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("在全部单词册内搜索 …")
        self.search_bar.setFixedHeight(33)
        self.search_bar.setStyleSheet(TEXT_EDIT_STYLE)
        self.search_bar.installEventFilter(self)

        head = QHBoxLayout()
        head.setContentsMargins(0, 0, 0, 0)
        head.addWidget(self.edit_btn)
        head.addWidget(self.search_bar, 1)

        # ========= ② ScrollArea =========
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)

        # ⭐ 改用 CoverContent（自带文件夹功能）
        self.content = CoverContent(self.scroll_area)
        self.scroll_area.setWidget(self.content)

        # —— 初次启动提示 —— #
        self.empty_hint = QLabel("还没有单词本，点击下面的『新建单词本』按钮开始吧！", self.content)
        self.empty_hint.setAlignment(Qt.AlignCenter)

        # ========= ③ 根布局 =========
        root = QVBoxLayout(self)
        root.addLayout(head)
        root.addWidget(self.scroll_area)

        # ========= ④ 下拉建议列表 =========
        self.suggestions_list = QListWidget()
        self.suggestions_list.setWindowFlags(
            Qt.FramelessWindowHint
            | Qt.WindowStaysOnTopHint
            | Qt.NoDropShadowWindowHint
        )
        self.suggestions_list.setAttribute(Qt.WA_ShowWithoutActivating, True)
        self.suggestions_list.setFocusPolicy(Qt.NoFocus)
        self.suggestions_list.itemClicked.connect(self._on_suggestion_clicked)
        self.suggestions_list.hide()

        # ========= ⑤ 信号外发 =========
        self.edit_btn.clicked.connect(self._toggle_edit)
        self.search_bar.textChanged.connect(self.searchTextChanged)


    # ------------------------------------------------------------
    #               Controller 调用的 UI API
    # ------------------------------------------------------------
    def _toggle_edit(self) -> None:
        entering = self.edit_btn.text() == "编辑"
        self.edit_btn.setText("退出" if entering else "编辑")
        self.editToggled.emit(entering)

    # —— 清空 / 添加按钮 —— #
    def clear_wordbook_buttons(self) -> None:
        """
        删除当前所有单词本按钮，但保留“新建单词本”按钮，
        并让 CoverContent 自己维护 buttons 列表。
        """
        # CoverContent 在 build_buttons 时挂载了 .buttons
        for btn in list(getattr(self.content, "buttons", [])):
            if getattr(btn, "is_new_button", False):
                continue
            btn.setParent(None)
            btn.deleteLater()
            self.content.buttons.remove(btn)
        self.empty_hint.show()
    def add_wordbook_button(self, button: QPushButton) -> None:
        self.empty_hint.hide()
        button.setParent(self.content)
        button.show()

    # ------------------------------------------------------------
    #           下拉建议：由 Controller 调用
    # ------------------------------------------------------------
    def show_suggestions(self, words: list[str]) -> None:
        if not words:
            self.suggestions_list.hide()
            return

        self.suggestions_list.clear()
        self.suggestions_list.addItems(words)

        # 确定大小 & 位置
        row_h   = self.suggestions_list.sizeHintForRow(0) or 24
        max_row = min(8, len(words))
        self.suggestions_list.setFixedSize(
            self.search_bar.width(),
            max_row * row_h + 2
        )
        global_pos = self.search_bar.mapToGlobal(self.search_bar.rect().bottomLeft())
        self.suggestions_list.move(global_pos)
        self.suggestions_list.show()
        self.suggestions_list.setCurrentRow(0)

    def hide_suggestions(self) -> None:
        self.suggestions_list.hide()

    def _on_suggestion_clicked(self, item) -> None:
        self.hide_suggestions()
        self.search_bar.setText(item.text())
        self.suggestionSelected.emit(item.text())

    # ------------------------------------------------------------
    #      让 ↑ ↓ ↵ 在搜索框里直接操作建议列表
    # ------------------------------------------------------------
    def eventFilter(self, obj, event):
        if obj is self.search_bar and event.type() == QEvent.KeyPress:
            if not self.suggestions_list.isVisible():
                return super().eventFilter(obj, event)

            key = event.key()
            row = self.suggestions_list.currentRow()
            count = self.suggestions_list.count()

            if key == Qt.Key_Down:
                row = 0 if row < 0 else min(row + 1, count - 1)
                self.suggestions_list.setCurrentRow(row)
                return True
            elif key == Qt.Key_Up:
                row = count - 1 if row < 0 else max(row - 1, 0)
                self.suggestions_list.setCurrentRow(row)
                return True
            elif key in (Qt.Key_Return, Qt.Key_Enter):
                item = self.suggestions_list.currentItem()
                if item:
                    self._on_suggestion_clicked(item)
                return True

        return super().eventFilter(obj, event)

UI/cover_view.py结束

UI/new_wordbook_dialog.py开始
# UI/new_wordbook_dialog.py
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QColorDialog, QMessageBox
)
from PySide6.QtGui import QColor


class NewWordBookDialog(QDialog):
    """输入『名称 + 颜色』的简单对话框"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("新建单词本")
        self.resize(320, 150)

        self._build_ui()
        self.book_name: str | None = None
        self.book_color: str = "#a3d2ca"   # 默认色

    # ------------------------------------------------------------
    def _build_ui(self):
        lay = QVBoxLayout(self)

        self.name_edit = QLineEdit(placeholderText="单词本名称")
        lay.addWidget(self.name_edit)

        self.color_btn = QPushButton("选择颜色 (#a3d2ca)")
        self.color_btn.clicked.connect(self._choose_color)
        lay.addWidget(self.color_btn)

        btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btns.accepted.connect(self._accept)
        btns.rejected.connect(self.reject)
        lay.addWidget(btns)

    # ------------------------------------------------------------
    def _choose_color(self):
        c = QColorDialog.getColor(QColor(self.book_color), self, "选择颜色")
        if c.isValid():
            self.book_color = c.name()
            self.color_btn.setText(f"选择颜色 ({self.book_color})")
            self.color_btn.setStyleSheet(f"background:{self.book_color}")

    def _accept(self):
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "错误", "名称不能为空！")
            return
        self.book_name = name
        self.accept()
UI/new_wordbook_dialog.py结束

UI/word_book_inside/word_book_window.py开始
from __future__ import annotations

import os
from PySide6.QtWidgets import QSplitter, QWidget, QVBoxLayout, QApplication
from PySide6.QtCore import Qt

from UI.word_book_inside.word_list_panel import WordListPanel
from UI.word_book_inside.word_detail_panel import WordDetailPanel
from UI.word_book_inside.word_edit_panel import WordEditPanel
from services.wordbook_service import WordBookService as WS


class WordBookWindow(QWidget):
    """顶层壳（替代原 inside.WordBookApp）。"""

    def __init__(self, path: str, target_word: str | None = None):
        super().__init__()
        self.path = path
        self.book_name = os.path.basename(path).split("_")[1]
        self.book_color = os.path.basename(path).split("_")[2]
        self.setWindowTitle(f"单词本 - {self.book_name}")
        self.resize(1200, 800)

        self._build_ui()
        if target_word:
            self._jump_to_word(target_word)

    # ------------------------------------------------------------------
    def _build_ui(self):
        lay = QVBoxLayout(self)
        self.split = QSplitter(Qt.Horizontal)
        self.list_panel = WordListPanel(self.book_name, self.book_color)
        self.list_panel.word_selected.connect(self._on_word_selected)
        self.list_panel.add_word_click.connect(self._on_add_word)
        self.list_panel.memory_click.connect(self._on_memory)
        self.split.addWidget(self.list_panel)

        self.detail_panel = WordDetailPanel()
        self.detail_panel.edit_requested.connect(self._enter_edit_mode)
        self.split.addWidget(self.detail_panel)
        self.split.setSizes([350, 850])
        lay.addWidget(self.split)

        self._current_word: dict | None = None
        self._dlg_add = None  # 保留对话框引用，避免被 GC

    # ------------------------------------------------------------------
    # 交互
    # ------------------------------------------------------------------
    def _on_word_selected(self, word: dict):
        self._current_word = word
        self.detail_panel.show_word(word)

    def _on_add_word(self):
        from add_new_word import WordEntryUI
        # 保持引用，避免立即被销毁
        self._dlg_add = WordEntryUI(self.path)
        self._dlg_add.save_successful.connect(lambda *_: self.list_panel.reload_words())
        self._dlg_add.show()

    def _on_memory(self):
        from memory_curve import MemoryCurveApp
        self._mem = MemoryCurveApp(self.path)
        self._mem.show()

    # ------------------------------------------------------------------
    # 编辑
    # ------------------------------------------------------------------
    def _enter_edit_mode(self, word: dict):
        self._edit_panel = WordEditPanel(word, self.book_name, self.book_color)
        self._edit_panel.edit_saved.connect(self._save_edit)
        self._edit_panel.cancelled.connect(self._exit_edit_mode)
        self.split.replaceWidget(1, self._edit_panel)

    def _save_edit(self, updated: dict):
        try:
            WS.save_word(self.book_name, self.book_color, updated)
            self.list_panel.reload_words()
            self._current_word = updated
        except Exception as exc:
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(self, "错误", str(exc))
            return
        self._exit_edit_mode()

    def _exit_edit_mode(self):
        self.split.replaceWidget(1, self.detail_panel)
        if self._current_word:
            self.detail_panel.show_word(self._current_word)

    # ------------------------------------------------------------------
    def _jump_to_word(self, word_name: str):
        for w in WS.list_words(self.book_name, self.book_color):
            if str(w["单词"]).strip().lower() == str(word_name).strip().lower():
                self._on_word_selected(w)
                break


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("需要传入 books_... 文件夹路径！")
        sys.exit(1)

    app = QApplication(sys.argv)
    win = WordBookWindow(sys.argv[1])
    win.show()
    sys.exit(app.exec())

UI/word_book_inside/word_book_window.py结束

UI/word_book_inside/word_detail_panel.py开始
from __future__ import annotations

from collections import OrderedDict

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QTextEdit, QPushButton, QTabWidget, QFrame,
)
from PySide6.QtCore import Signal, Qt

from styles import PRIMARY_BUTTON_STYLE, TEXT_EDIT_STYLE, LINE_EDIT_STYLE, TAG_LABEL_STYLE
from font import meaning_font, main_word_font, sentence_font, sentence_font_platte, list_word_font

class WordDetailPanel(QWidget):
    """右侧只读详情视图。"""

    edit_requested = Signal(dict)   # 当用户点击“编辑”

    def __init__(self, parent: QWidget | None = None):
        super().__init__(parent)
        self._build_ui()
        self._current_word: dict | None = None

    # ------------------------------------------------------------------
    def _build_ui(self):
        self.layout = QVBoxLayout(self)
        self.word_label = QLabel()
        self.word_label.setFont(main_word_font)
        self.word_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.word_label)

        self.tab = QTabWidget()
        self.layout.addWidget(self.tab, 1)

        # 占位——无数据时
        self.placeholder = QLabel("请选择左侧单词…", alignment=Qt.AlignCenter)
        self.layout.addWidget(self.placeholder)

    # ------------------------------------------------------------------
    def show_word(self, word: dict):
        self._current_word = word
        self.placeholder.hide()
        self.word_label.setText(str(word["单词"]))

        # 清空旧 tab
        while self.tab.count():
            self.tab.removeTab(0)

        # 构建『释义 & 例句』
        self._build_meaning_example_tab(word)
        # 备注
        self._build_note_tab(word)
        # 标签
        self._build_tag_tab(word)
        # 相关单词
        self._build_related_tab(word)

        # 编辑按钮
        if not hasattr(self, "_btn_edit"):
            self._btn_edit = QPushButton("编辑")
            self._btn_edit.setStyleSheet(PRIMARY_BUTTON_STYLE)
            self._btn_edit.clicked.connect(lambda: self.edit_requested.emit(self._current_word))
            self.layout.addWidget(self._btn_edit)

    # ------------------------------------------------------------------
    def _build_meaning_example_tab(self, w: dict):
        wid = QWidget(); lay = QVBoxLayout(wid)
        meanings, examples = w.get("释义", []), w.get("例句", [])
        if len(examples) < len(meanings):
            examples += [""] * (len(meanings) - len(examples))
        grouped: OrderedDict[str, list[str]] = OrderedDict()
        for m, e in zip(meanings, examples):
            grouped.setdefault(str(m).strip(), [])
            if e:
                grouped[str(m).strip()].append(e)

        for idx, (m, exs) in enumerate(grouped.items(), start=1):
            self._add_row(lay, f"释义{idx}:", m, multiline=False, bold=True)
            if exs:
                for j, ex in enumerate(exs, start=1):
                    self._add_row(lay, f"例句{idx}.{j}:", ex, multiline=True)
            else:
                self._add_row(lay, f"例句{idx}.1:", "", multiline=True)
            if idx < len(grouped):
                sep = QFrame(); sep.setFrameShape(QFrame.HLine); sep.setFrameShadow(QFrame.Sunken)
                lay.addWidget(sep)
        self.tab.addTab(wid, "释义 & 例句")

    def _build_note_tab(self, w: dict):
        wid = QWidget(); lay = QVBoxLayout(wid)
        self._add_row(lay, "备注:", w.get("备注", "无备注"), multiline=True)
        self.tab.addTab(wid, "备注")

    def _build_tag_tab(self, w: dict):
        wid = QWidget(); lay = QVBoxLayout(wid)
        tags = w.get("标签", [])
        txt = ", ".join(tags) if tags else "无标签"
        self._add_row(lay, "标签:", txt)
        self.tab.addTab(wid, "标签")

    def _build_related_tab(self, w: dict):
        rel = w.get("相关单词", [])
        txt = ", ".join(rel) if rel else "无"
        wid = QWidget(); lay = QVBoxLayout(wid)
        self._add_row(lay, "关联单词:", txt)
        self.tab.addTab(wid, "相关")

    # ------------------------------------------------------------------
    def _add_row(self, layout: QVBoxLayout, label_text: str, content: str, *, multiline=False, bold=False):
        lbl = QLabel(label_text)
        if bold:
            lbl.setFont(meaning_font)
        layout.addWidget(lbl)
        if multiline:
            te = QTextEdit()
            te.setReadOnly(True)
            te.setStyleSheet(TEXT_EDIT_STYLE)
            te.setPlainText(str(content))
            te.setFixedHeight(90)
            layout.addWidget(te)
        else:
            val = QLabel(str(content))
            layout.addWidget(val)

UI/word_book_inside/word_detail_panel.py结束

UI/word_book_inside/word_edit_panel.py开始
from __future__ import annotations

from datetime import datetime
from typing import List, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QGridLayout, QLineEdit, QTextEdit, QLabel, QPushButton, QHBoxLayout, QMessageBox
)
from PySide6.QtCore import Signal, Qt

from styles import (
    GREEN_BUTTON_STYLE, RED_BUTTON_STYLE, LINE_EDIT_STYLE, TEXT_EDIT_STYLE,
    PRIMARY_BUTTON_STYLE, SECONDARY_BUTTON_STYLE
)
from font import meaning_font, sentence_font, sentence_font_platte
from MultiSelectComboBox import MultiSelectComboBox
from utils import get_tags_path


class WordEditPanel(QWidget):
    """右侧：编辑模式。传入原 word dict 的副本进行编辑。"""

    edit_saved = Signal(dict)  # 发射保存后的完整 word dict
    cancelled = Signal()

    def __init__(self, word: dict, book_name: str, book_color: str, parent: QWidget | None = None):
        super().__init__(parent)
        self.book_name, self.book_color = book_name, book_color
        self.original = word.copy()
        self._build_ui()

    # ------------------------------------------------------------------
    # 构建界面
    # ------------------------------------------------------------------
    def _build_ui(self):
        self.layout = QVBoxLayout(self)
        # 释义-例句区
        self.meaning_grid = QGridLayout(); self.layout.addLayout(self.meaning_grid)
        self._rows: List[Tuple[QLineEdit, QTextEdit, QLabel, QLabel]] = []
        for idx, (m, e) in enumerate(zip(self.original.get("释义", []), self.original.get("例句", []))):
            self._rows.append(self._add_row(idx, m, e))
        if not self._rows:
            self._rows.append(self._add_row(0))

        ctrl = QHBoxLayout()
        btn_add = QPushButton("+"); btn_add.setFixedSize(30, 30); btn_add.setStyleSheet(GREEN_BUTTON_STYLE)
        btn_add.clicked.connect(self._add_row_clicked)
        btn_rm = QPushButton("-"); btn_rm.setFixedSize(30, 30); btn_rm.setStyleSheet(RED_BUTTON_STYLE)
        btn_rm.clicked.connect(self._remove_row_clicked)
        ctrl.addWidget(btn_add); ctrl.addWidget(btn_rm)
        self.layout.addLayout(ctrl)

        # 备注
        self.note_edit = QTextEdit(); self.note_edit.setPlainText(self.original.get("备注", ""))
        self.note_edit.setStyleSheet(TEXT_EDIT_STYLE)
        self.layout.addWidget(QLabel("备注:")); self.layout.addWidget(self.note_edit)

        # 标签多选
        self.tag_combo = MultiSelectComboBox(book_name=self.book_name, book_color=self.book_color)
        for t in self.tag_combo.allItems():
            self.tag_combo.addItem(t, t in self.original.get("标签", []))
        self.layout.addWidget(QLabel("标签:")); self.layout.addWidget(self.tag_combo)

        # 按钮
        btn_row = QHBoxLayout()
        btn_save = QPushButton("保存"); btn_save.setStyleSheet(SECONDARY_BUTTON_STYLE); btn_save.clicked.connect(self._on_save)
        btn_cancel = QPushButton("取消"); btn_cancel.setStyleSheet(RED_BUTTON_STYLE); btn_cancel.clicked.connect(lambda: self.cancelled.emit())
        btn_row.addWidget(btn_save); btn_row.addWidget(btn_cancel)
        self.layout.addLayout(btn_row)

    # ------------------------------------------------------------------
    # 行操作
    # ------------------------------------------------------------------
    def _add_row_clicked(self):
        idx = len(self._rows)
        self._rows.append(self._add_row(idx))

    def _remove_row_clicked(self):
        if len(self._rows) <= 1:
            return
        row_idx = len(self._rows) - 1
        base = row_idx * 2
        for r in (base, base + 1):
            for c in range(4):
                item = self.meaning_grid.itemAtPosition(r, c)
                if item and item.widget():
                    item.widget().deleteLater()
        self._rows.pop()

    def _add_row(self, row: int, meaning: str = "", example: str = ""):
        base_row = row * 2
        err_m = QLabel("", styleSheet="color:red;"); err_e = QLabel("", styleSheet="color:red;")
        err_m.hide(); err_e.hide()
        self.meaning_grid.addWidget(err_m, base_row, 1); self.meaning_grid.addWidget(err_e, base_row, 3)

        lab_m = QLabel(f"释义{row + 1}:"); lab_m.setFont(meaning_font)
        inp_m = QLineEdit(meaning); inp_m.setStyleSheet(LINE_EDIT_STYLE)
        lab_e = QLabel(f"例句{row + 1}:")
        lab_e.setFont(sentence_font); lab_e.setPalette(sentence_font_platte)
        inp_e = QTextEdit(); inp_e.setFixedHeight(90); inp_e.setStyleSheet(TEXT_EDIT_STYLE); inp_e.setPlainText(example)

        self.meaning_grid.addWidget(lab_m, base_row + 1, 0)
        self.meaning_grid.addWidget(inp_m, base_row + 1, 1)
        self.meaning_grid.addWidget(lab_e, base_row + 1, 2)
        self.meaning_grid.addWidget(inp_e, base_row + 1, 3)
        return inp_m, inp_e, err_m, err_e

    # ------------------------------------------------------------------
    # 保存逻辑
    # ------------------------------------------------------------------
    def _on_save(self):
        pairs: List[Tuple[str, str, QLabel, QLabel]] = []
        for inp_m, inp_e, err_m, err_e in self._rows:
            err_m.hide(); err_m.setText("")
            err_e.hide(); err_e.setText("")
            pairs.append((inp_m.text().strip(), inp_e.toPlainText().strip(), err_m, err_e))

        valid, has_pair = True, False
        for m, e, em, ee in pairs:
            if m and e:
                has_pair = True
            elif m and not e:
                ee.setText("*必填"); ee.show(); valid = False
            elif e and not m:
                em.setText("*必填"); em.show(); valid = False
        if not has_pair:
            QMessageBox.warning(self, "错误", "至少填写一对释义+例句！")
            return
        if not valid:
            return

        meanings, examples = [], []
        for m, e, *_ in pairs:
            if m and e:
                meanings.append(m); examples.append(e)

        updated = self.original.copy()
        updated.update({
            "释义": meanings,
            "例句": examples,
            "备注": self.note_edit.toPlainText().strip(),
            "标签": self.tag_combo.selectedItems(),
            "时间": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        })
        self.edit_saved.emit(updated)

UI/word_book_inside/word_edit_panel.py结束

UI/word_book_inside/word_list_panel.py开始
from __future__ import annotations

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QLineEdit, QLabel, QPushButton,
    QScrollArea, QHBoxLayout
)
from PySide6.QtCore import Signal, Qt, QTimer

from MultiSelectComboBox import MultiSelectComboBox
from services.wordbook_service import WordBookService as WS
from styles import PRIMARY_BUTTON_STYLE, SECONDARY_BUTTON_STYLE, LINE_EDIT_STYLE
from font import list_word_font
from utils import get_tags_path


class WordListPanel(QWidget):
    """左侧：搜索框 + 标签过滤 + 单词列表"""

    # --- 对外信号 --- #
    word_selected = Signal(dict)   # 单词按钮被点击，发射完整单词 dict
    add_word_click = Signal()      # "添加新单词" 按钮
    memory_click = Signal()        # "背单词" 按钮

    def __init__(self, book_name: str, book_color: str, parent: QWidget | None = None):
        super().__init__(parent)
        self.book_name = book_name
        self.book_color = book_color
        self._timer: QTimer | None = None
        self.full_words: list[dict] = []
        self._build_ui()
        self._load_tags_to_filter()
        self.reload_words()

    # ------------------------------------------------------------------
    # UI
    # ------------------------------------------------------------------
    def _build_ui(self):
        lay = QVBoxLayout(self)

        # ---- 搜索框 ---- #
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("查找…")
        self.search_bar.setStyleSheet(LINE_EDIT_STYLE)
        self.search_bar.textChanged.connect(self._debounce_filter)
        lay.addWidget(self.search_bar)

        # ---- 标签过滤 ---- #
        tag_row = QHBoxLayout()
        tag_row.addWidget(QLabel("过滤标签:"))
        self.tag_filter_combo = MultiSelectComboBox(book_name=self.book_name, book_color=self.book_color)
        self.tag_filter_combo.model().itemChanged.connect(self.filter_words)
        tag_row.addWidget(self.tag_filter_combo)
        lay.addLayout(tag_row)

        # ---- 控制按钮 ---- #
        btn_add = QPushButton("添加新单词")
        btn_add.setStyleSheet(PRIMARY_BUTTON_STYLE)
        btn_add.clicked.connect(self.add_word_click)
        lay.addWidget(btn_add)

        btn_mem = QPushButton("背单词")
        btn_mem.setStyleSheet(SECONDARY_BUTTON_STYLE)
        btn_mem.clicked.connect(self.memory_click)
        lay.addWidget(btn_mem)

        # ---- 列表区 ---- #
        self._list_container = QWidget()
        self._list_layout = QVBoxLayout(self._list_container)
        self._list_layout.setAlignment(Qt.AlignTop)

        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(self._list_container)
        lay.addWidget(scroll, 1)  # stretch

    # ------------------------------------------------------------------
    # 数据加载
    # ------------------------------------------------------------------
    def reload_words(self):
        self.full_words = WS.list_words(self.book_name, self.book_color)
        self._display_words(self.full_words)

    def _display_words(self, words: list[dict]):
        # 清空旧
        while self._list_layout.count():
            w = self._list_layout.takeAt(0).widget()
            if w:
                w.deleteLater()

        for wd in words:
            btn = QPushButton(str(wd["单词"]))
            btn.setFont(list_word_font)
            btn.clicked.connect(lambda _, d=wd: self.word_selected.emit(d))
            self._list_layout.addWidget(btn)

        self._list_layout.addStretch(1)

    # ------------------------------------------------------------------
    # 过滤逻辑
    # ------------------------------------------------------------------
    def _debounce_filter(self):
        if self._timer is None:
            self._timer = QTimer(self)
            self._timer.setSingleShot(True)
            self._timer.timeout.connect(self.filter_words)
        self._timer.start(300)

    def filter_words(self):
        kw = self.search_bar.text().strip().lower()
        tags = self.tag_filter_combo.selectedItems()

        def ok(w: dict):
            has_kw = kw in str(w["单词"]).lower()
            has_tag = not tags or any(t in w.get("标签", []) for t in tags)
            return has_kw and has_tag

        self._display_words([w for w in self.full_words if ok(w)])

    # ------------------------------------------------------------------
    # 初始化标签下拉
    # ------------------------------------------------------------------
    def _load_tags_to_filter(self):
        self.tag_filter_combo.clear()
        tags_path = get_tags_path(self.book_name, self.book_color)
        if not tags_path or not tags_path.endswith("tags.txt"):
            return
        try:
            with open(tags_path, "r", encoding="utf-8") as f:
                for t in f.read().splitlines():
                    self.tag_filter_combo.addItem(t)
        except FileNotFoundError:
            pass

UI/word_book_inside/word_list_panel.py结束

WordBookButton.py开始
from PySide6.QtWidgets import QPushButton, QLineEdit, QMessageBox
from PySide6.QtGui import QColor, QPainter, QPixmap, QFont
from PySide6.QtCore import Qt, QRect, QPoint, QPropertyAnimation, QTimer, QEasingCurve, Property
from PIL import Image
import os
import sys
from font import normal_font
from UI.Folder_UI.button import DraggableButton
from UI.Folder_UI._layout import calculate_folder_area


class WordBookButton(DraggableButton):
    """自定义单词本按钮，支持拖拽、文件夹展开/折叠、子按钮拖出等交互。"""

    def __init__(self, title: str, color: str, parent=None, app=None):
        super().__init__(title, parent if parent is not None else parent, app)

        # —— 基本属性 —— #
        self.color          = color
        self.is_folder      = False
        self.is_expanded    = False
        self.is_sub_button  = False
        self.parent_folder  = None
        self.sub_buttons    = []
        self.is_dragging    = False
        self.drag_start_position       = QPoint()
        self.drag_out_threshold_exceeded = False
        self.rename_source  = "edit"
        self._fade_opacity: float = 1.0  # 深色背景当前透明度
        self._fade_anim: QPropertyAnimation | None = None
        self._suppress_dark: bool = False  # 渐隐结束 → True 彻底不再绘制
        # —— 字体 / 尺寸 —— #
        cover_font = QFont(normal_font)
        cover_font.setBold(True)
        self.setFont(cover_font)
        self.icon_size  = 120
        self.setFixedSize(120, 150)

        # —— 图标 —— #
        icon_path            = self.create_colored_icon(color)
        self.icon_path       = icon_path
        self.icon_pixmap     = QPixmap(icon_path).scaled(self.icon_size, self.icon_size)

        # —— hover / pressed 样式（颜色深、浅） —— #
        hover_color, pressed_color = color, color
        self.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                border: none;
                text-align: center;
            }}
            QPushButton::hover {{
                background-color: {WordBookButton.lighten_color(hover_color)};
                border-radius: 15px;
            }}
            QPushButton::pressed {{
                background-color: {pressed_color};
                border-radius: 15px;
            }}
        """)

        # —— 内联名称编辑控件 —— #
        self.name_edit = QLineEdit(self)
        self.name_edit.hide()
        self.name_edit.setAlignment(Qt.AlignCenter)
        self.name_edit.setStyleSheet("""
            QLineEdit {
                border: 1px solid #888;
                border-radius: 4px;
                background-color: rgba(255, 255, 255, 0.9);
            }
        """)
        self.name_edit.returnPressed.connect(self.finish_name_edit)
        self.name_edit.editingFinished.connect(self.finish_name_edit)

        # —— 删除按钮（右上角 ✕） —— #
        self.delete_button = QPushButton("✕", self)
        self.delete_button.setFixedSize(22, 22)
        self.delete_button.move(self.width() - self.delete_button.width(), 0)
        self.delete_button.setStyleSheet("""
               QPushButton {
                   background-color: #FF4D4D;
                   color: #FFFFFF;
                   border: none;
                   border-radius: 11px;
                   font-weight: bold;
               }
               QPushButton:hover { background-color: #FF8080; }
           """)
        self.delete_button.hide()
        self.delete_button.clicked.connect(self.on_delete_clicked)
        self.delete_button.setCursor(Qt.ArrowCursor)   # ✕ 按钮始终保持默认箭头

        # —— 启用鼠标跟踪，以便不按键时也能接收 mouseMoveEvent —— #
        self.setMouseTracking(True)

        # ----------  新增：按压动画/计时  ---------- #
        self._orig_geometry: QRect | None = None  # 原始几何
        self._shrink_anim: QPropertyAnimation | None = None
        self._restore_anim: QPropertyAnimation | None = None
        self._long_press_timer: QTimer | None = None
        self._suppress_dark: bool = False  # 0.5 s后取消变深
    # ------------------------------------------------------------
    # 光标更新辅助
    # ------------------------------------------------------------
    def _update_cursor(self, pos: QPoint):
        """
        根据鼠标位置更新光标（仅编辑模式生效）
          • 名称区域       → IBeam（文本）
          • 删除按钮区域   → Arrow（默认）
          • 其余按钮区域   → PointingHand（手掌）
        """
        if self.app and self.app.edit_mode:
            # 1. 删除按钮区域优先
            if self.delete_button.isVisible() and self.delete_button.geometry().contains(pos):
                self.setCursor(Qt.ArrowCursor)
                return

            # 2. 名称文字所在矩形
            name_rect = QRect(
                0,
                self.icon_size + 5,
                self.width(),
                self.height() - self.icon_size - 5
            )
            if name_rect.contains(pos):
                self.setCursor(Qt.IBeamCursor)
            else:
                self.setCursor(Qt.PointingHandCursor)
        else:
            # 非编辑模式：保持默认
            self.setCursor(Qt.ArrowCursor)
    # ------------------------- 静态辅助方法 ------------------------- #
    @staticmethod
    def lighten_color(color: str, factor: float = 0.6) -> str:
        rgb = QColor(color).getRgb()[:3]
        lightened = [int(min(255, c + (255 - c) * factor)) for c in rgb]
        return QColor(*lightened).name()

    def create_colored_icon(self, color: str) -> str:
        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        icon_dir = os.path.join(base_dir, "icon")
        os.makedirs(icon_dir, exist_ok=True)
        icon_path = os.path.join(icon_dir, f"colored_icon_{color[1:]}.png")
        if os.path.exists(icon_path):
            return icon_path
        base_image_path = os.path.join(base_dir, "icon", "cover.webp")
        base_image = Image.open(base_image_path).convert("RGBA")
        datas = base_image.getdata()
        new_data = []
        target = Image.new("RGBA", (1, 1), color).getdata()[0]
        for item in datas:
            if not (item[0] > 200 and item[1] > 200 and item[2] > 200):
                new_data.append(target)
            else:
                new_data.append((255, 255, 255, 0))
        base_image.putdata(new_data)
        base_image.save(icon_path)
        return icon_path

    def update_folder_icon(self):
        """
        重新生成九宫格文件夹图标并刷新显示。
        若子按钮数量发生变化（新增 / 移除 / 重排）时，务必调用本方法。
        """
        if not self.is_folder or not self.sub_buttons:
            return

        # 收集最多 9 张子按钮图标
        sub_icon_paths = []
        for sub in self.sub_buttons[:9]:
            # 普通按钮 & 另一个文件夹按钮都会在 __init__ 中写入 icon_path
            if hasattr(sub, "icon_path") and sub.icon_path:
                sub_icon_paths.append(sub.icon_path)

        if not sub_icon_paths:  # 没有可用子图标则跳过
            return

        from UI.Folder_UI._utils import create_folder_icon
        icon_path = create_folder_icon(
            sub_icon_paths=sub_icon_paths,
            folder_name=self.text()
        )

        self.icon_path = icon_path
        self.icon_pixmap = QPixmap(icon_path).scaled(self.icon_size, self.icon_size)
        self.update()  # 触发重绘

    # --------------------------- 绘制 --------------------------- #
    def paintEvent(self, event):
        """先绘制浅色 hover，再叠加可渐隐的深色层。"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # ---------- ① 浅色 hover 背景 ----------
        base_color = None
        if self.underMouse():  # 包括按住时
            base_color = QColor(WordBookButton.lighten_color(self.color))

        if base_color:
            painter.setPen(Qt.NoPen)
            painter.setBrush(base_color)
            painter.drawRoundedRect(self.rect(), 15, 15)

        # ---------- ② 深色按压层（会淡出） ----------
        if (
                self.isDown()
                and not self._suppress_dark
                and self._fade_opacity > 0.0
        ):
            overlay = QColor(self.color)
            overlay.setAlphaF(self._fade_opacity)  # α 随动画变化 1 → 0
            painter.setPen(Qt.NoPen)
            painter.setBrush(overlay)
            painter.drawRoundedRect(self.rect(), 15, 15)

        # ---------- ③ 抖动旋转支持 ----------
        painter.save()
        if getattr(self, "_rotation", 0):
            painter.translate(self.width() / 2, self.height() / 2)
            painter.rotate(self._rotation)
            painter.translate(-self.width() / 2, -self.height() / 2)

        # ---------- ④ 图标 & 标题 ----------
        if hasattr(self, "icon_pixmap"):
            icon_x = (self.width() - self.icon_pixmap.width()) // 2
            painter.drawPixmap(icon_x, 0, self.icon_pixmap)

        painter.setPen(self.palette().buttonText().color())
        text_rect = QRect(
            0, self.icon_size + 5, self.width(), self.height() - self.icon_size - 5
        )
        painter.drawText(text_rect, Qt.AlignHCenter | Qt.AlignTop, self.text())
        painter.restore()

    # ------------------------------------------------------------
    # 鼠标进入：立即设置一次光标
    # ------------------------------------------------------------

    def enterEvent(self, event):
        self._update_cursor(event.pos())
        super().enterEvent(event)

    def mouseDoubleClickEvent(self, event):
        """
        在编辑模式下，双击按钮名称区域进入重命名状态；
        非编辑模式保持原有行为。
        """
        if self.app and self.app.edit_mode:
            self.start_name_edit()
            return  # 不向父类传递，避免触发拖动
        super().mouseDoubleClickEvent(event)

    # -------------------- 名称编辑核心逻辑 --------------------
    def start_name_edit(self):
        """
        内联进入重命名状态（编辑模式双击 / 右键菜单皆可调用）。
        使用 QTimer.singleShot 确保在弹出式菜单完全关闭后再获取焦点，
        避免偶发需要二次点击的问题。
        """
        from PySide6.QtCore import QTimer      # 局部导入，避免循环依赖

        # ——— 准备编辑框 ——— #
        self.stop_jitter()                     # 停止抖动
        self.name_edit.setText(self.text())    # 预填旧名
        self.name_edit.selectAll()             # 全选文本，方便直接输入

        # 覆盖标题文字区域
        y_start = self.icon_size + 5
        self.name_edit.setGeometry(
            0, y_start,
            self.width(),
            self.height() - y_start
        )
        self.name_edit.show()

        # 关键：等当前事件（右键菜单）处理完再聚焦
        QTimer.singleShot(0, self.name_edit.setFocus)

    def finish_name_edit(self):
        """完成重命名；依据调用来源决定是否恢复抖动，并在成功后立即保存布局。"""
        if not self.name_edit.isVisible():
            return

        new_name = self.name_edit.text().strip()
        self.name_edit.hide()

        # -------- A. 无改动 / 空名 --------
        if not new_name or new_name == self.text():
            if self.app.edit_mode and self.rename_source == "edit":
                self.start_jitter()  # 仅编辑模式下恢复抖动
            return

        # -------- B. 检查重名 --------
        sibling_names = [btn.text() for btn in self.app.buttons if btn is not self]
        if new_name in sibling_names:
            QMessageBox.warning(self, "重名冲突", "已有同名单词本或文件夹！")
            if self.app.edit_mode and self.rename_source == "edit":
                self.start_jitter()
            return

        old_name = self.text()
        self.setText(new_name)

        # -------- C. 文件夹 / 普通按钮处理 --------
        if self.is_folder:
            self.update_folder_icon()  # 文件夹需刷新九宫格图标
        else:
            try:
                self.rename_wordbook_directory(old_name, new_name)
            except Exception as e:
                QMessageBox.warning(self, "重命名失败", f"{e}")
                self.setText(old_name)
                if self.app.edit_mode and self.rename_source == "edit":
                    self.start_jitter()
                return

        # 更新点击路径
        if not self.is_folder:
            try:
                self.clicked.disconnect()
            except TypeError:
                pass
            base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
            new_path = os.path.join(base_dir, "books",
                                    f"books_{new_name}_{self.color}")
            self.clicked.connect(lambda _, p=new_path: self.app.show_word_book(p))

        # 子按钮刷新父文件夹图标
        if self.is_sub_button and self.parent_folder:
            self.parent_folder.update_folder_icon()

        # 刷新整体布局
        self.app.update_button_positions()

        # -------- D. 立即保存最新布局 --------
        try:
            self.app.save_layout_to_json()  # ⭐ 新增：重命名后立刻持久化
        except Exception as e:
            print(f"❌ 保存布局失败: {e}")

        # -------- E. 结束后抖动恢复策略 --------
        if self.app.edit_mode and self.rename_source == "edit":
            self.start_jitter()

        self.rename_source = "edit"  # 重置来源标记

    def rename_wordbook_directory(self, old_name: str, new_name: str):
        """
        将磁盘上的 books_<名称>_<颜色> 文件夹重命名。
        若目标已存在则抛出异常。
        """
        base_dir  = os.path.dirname(os.path.abspath(sys.argv[0]))
        books_dir = os.path.join(base_dir, "books")
        old_folder = f"books_{old_name}_{self.color}"
        new_folder = f"books_{new_name}_{self.color}"
        old_path = os.path.join(books_dir, old_folder)
        new_path = os.path.join(books_dir, new_folder)

        if os.path.exists(new_path):
            raise FileExistsError("目标名称已存在，请换一个名称。")
        if not os.path.exists(old_path):
            # 若原目录不存在（如首次创建后尚未保存），忽略磁盘重命名
            return

        os.rename(old_path, new_path)

    # --------------------------- 事件 --------------------------- #
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            if self.app and getattr(self.app, "edit_mode", False):
                # 编辑模式
                if getattr(self, "is_new_button", False):
                    # “新建单词本”按钮：按原行为直接走基类 QPushButton 的实现
                    QPushButton.mousePressEvent(self, event)
                    return

                # 开始拖动
                self.drag_start_position = event.globalPosition().toPoint()
                self.is_dragging = True
                self.setStyleSheet(
                    "background-color: rgba(200,200,200,0.2); border-radius: 15px;"
                )

                # ⚠️ 折叠所有文件夹的逻辑已经在 DraggableButton 中实现，
                #    只需要保证稍后会调用 super().mousePressEvent(event)
                #    即可触发，无需重复编写。
            else:
                # 非编辑模式：只有点击封面图标区域才响应
                icon_rect = QRect(
                    0,
                    0,
                    self.icon_pixmap.width() if hasattr(self, "icon_pixmap") else self.icon_size,
                    self.icon_size,
                )
                if not icon_rect.contains(event.pos()):
                    return

        self._start_press_effect()
        # 关键修改：调用父类 DraggableButton 的 mousePressEvent，
        # 以触发其内部的 collapse_all_folders() 逻辑
        super().mousePressEvent(event)

        # ------------------------------------------------------------
        # 鼠标移动：拖拽 + 光标更新（编辑模式专用）
        # ------------------------------------------------------------

    def mouseMoveEvent(self, event):
        # —— ① 光标热区实时更新 —— #
        self._update_cursor(event.pos())

        # —— ② 若非“按住左键拖动”场景，交给父类处理即可 —— #
        if (
                not (event.buttons() & Qt.LeftButton)  # 未按住左键
                or not self.is_dragging  # 未进入拖动状态
                or not self.app.edit_mode  # 不在编辑模式
        ):
            super().mouseMoveEvent(event)  # 保持 Hover 效果等
            return

        # ---------- 主/子按钮跟随鼠标移动 ---------- #
        delta = event.globalPosition().toPoint() - self.drag_start_position
        self.move(self.pos() + delta)
        self.drag_start_position = event.globalPosition().toPoint()

        # ---------- A. 子按钮拖拽逻辑 ---------- #
        if self.is_sub_button and self.parent_folder and self.app.edit_mode:
            # 计算除自身外其他子按钮的 folder 区域，保持区域随拖动静止
            other_sub_buttons = [btn for btn in self.parent_folder.sub_buttons if btn is not self]
            folder_area = calculate_folder_area(
                self.parent_folder,
                other_sub_buttons,
                self.app.button_width,
                self.app.button_height,
            )
            min_x, min_y, max_x, max_y = folder_area
            center = QPoint(
                self.x() + self.app.button_width // 2,
                self.y() + self.app.button_height // 2,
            )

            # 判定是否仍在“文件夹内部重排区”
            margin = 10
            left_bound = 0
            right_bound = self.app.scroll_content.width()
            top_bound = min_y
            bottom_bound = max_y
            inside = (
                    left_bound - margin <= center.x() <= right_bound + margin and
                    top_bound - margin <= center.y() <= bottom_bound + margin
            )

            if inside:  # ★ 重排
                self.app.show_blue_reorder_frame(self.parent_folder)
                self.app.hide_red_removal_frame()
                self.drag_out_threshold_exceeded = False
                self.app.update_sub_button_order(
                    self.parent_folder,
                    dragged_sub_button=self,
                    realtime=True,
                )
            else:  # ★ 拖出提示
                self.app.hide_blue_reorder_frame()
                self.app.show_red_removal_frame(self.parent_folder)
                self.drag_out_threshold_exceeded = True

        # ---------- B. 主界面按钮拖拽逻辑 ---------- #
        else:
            # 近距离合并提示框 & 主按钮排序
            self.app.check_button_proximity(self)
            self.app.update_button_order(self)

    def mouseReleaseEvent(self, event):
        # ---------- 1. 编辑模式下拖拽释放 ----------
        if self.app and self.app.edit_mode and self.is_dragging:
            super().mouseReleaseEvent(event)
            self.setDown(False)
            self.update()
            return

        # ---------- 2. 非编辑模式：点击封面 ----------
        if event.button() == Qt.LeftButton:
            icon_rect = QRect(
                0, 0,
                self.icon_pixmap.width() if hasattr(self, "icon_pixmap") else self.icon_size,
                self.icon_size,
            )
            if icon_rect.contains(event.pos()) and self.is_folder:
                self.app.toggle_folder(self)

        self._start_press_effect()
        super().mouseReleaseEvent(event)       # 交回基类，保证 clicked()
        self.setDown(False)                    # 🔑 复位 pressed 状态
        self.update()

    # ------------------------------------------------------------
    # 按压／松开视觉效果（已去除缩小动画）
    # ------------------------------------------------------------
    def _start_press_effect(self):
        """按下时：仅触发深色遮罩的淡入计时，不再缩小按钮尺寸"""
        # ---------- a. 深色遮罩计时 ----------
        self._suppress_dark = False
        self.setFadeOpacity(1.0)  # 立即显示深色层

        if self._fade_anim and self._fade_anim.state() == QPropertyAnimation.Running:
            self._fade_anim.stop()

        if self._long_press_timer:
            self._long_press_timer.stop()
        self._long_press_timer = QTimer(self)
        self._long_press_timer.setSingleShot(True)
        self._long_press_timer.timeout.connect(self._disable_darkening)
        self._long_press_timer.start(100)  # 0.1 s 后允许渐隐

        # ---------- b. 取消所有缩放相关动画 ----------
        self._orig_geometry = None  # 不再记录原始几何
        if self._shrink_anim and self._shrink_anim.state() == QPropertyAnimation.Running:
            self._shrink_anim.stop()
        if self._restore_anim and self._restore_anim.state() == QPropertyAnimation.Running:
            self._restore_anim.stop()
        self._shrink_anim = None
        self._restore_anim = None

    def _end_press_effect(self):
        """松开时：只淡出深色遮罩，不做尺寸复原"""
        # ---------- a. 终止深色遮罩计时 / 动画 ----------
        if self._long_press_timer:
            self._long_press_timer.stop()

        self._suppress_dark = False
        self.setFadeOpacity(0.0)  # 立即隐藏深色层
        if self._fade_anim and self._fade_anim.state() == QPropertyAnimation.Running:
            self._fade_anim.stop()

        # ---------- b. 取消任何残留的缩放动画 ----------
        if self._shrink_anim and self._shrink_anim.state() == QPropertyAnimation.Running:
            self._shrink_anim.stop()
        if self._restore_anim and self._restore_anim.state() == QPropertyAnimation.Running:
            self._restore_anim.stop()
        self._shrink_anim = None
        self._restore_anim = None

    def _disable_darkening(self):
        """0.5 s 到期：深色背景『渐隐』约 180 ms，然后彻底去除"""
        if self._fade_anim and self._fade_anim.state() == QPropertyAnimation.Running:
            self._fade_anim.stop()

        self._fade_anim = QPropertyAnimation(self, b"fadeOpacity")
        self._fade_anim.setDuration(100)  # 若需调整速度就在此改
        self._fade_anim.setEasingCurve(QEasingCurve.OutQuad)
        self._fade_anim.setStartValue(1.0)
        self._fade_anim.setEndValue(0.0)

        def _after():
            self._suppress_dark = True  # 渐隐完毕 → 不再绘制

        self._fade_anim.finished.connect(_after)
        self._fade_anim.start()

    def getFadeOpacity(self) -> float:
        return self._fade_opacity

    def setFadeOpacity(self, value: float):
        self._fade_opacity = value
        self.update()

    fadeOpacity = Property(float, getFadeOpacity, setFadeOpacity)
WordBookButton.py结束

add_new_word.py开始
# add_new_word.py
import sys
import os
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLineEdit, QLabel, QPushButton, QHBoxLayout, QMessageBox,
    QInputDialog, QGridLayout, QFrame, QTextEdit, QScrollArea, QCheckBox
)
from PySide6.QtCore import Signal

from datetime import datetime

from font import meaning_font, word_font
from utils import get_tags_path, get_total_tags_path
from services.wordbook_service import WordBookService as WS
from styles import GREEN_BUTTON_STYLE, RED_BUTTON_STYLE, GRAY_INPUT_STYLE, GRAY_TEXT_EDIT_STYLE, PRIMARY_BUTTON_STYLE, \
    SECONDARY_BUTTON_STYLE


class WordEntryUI(QWidget):
    save_successful = Signal(dict)
    def __init__(self, path):
        super(WordEntryUI, self).__init__()
        self.path = path  # 保存传入的路径
        self.book_name = os.path.basename(path).split('_')[1]
        self.book_color = os.path.basename(path).split('_')[2]

        self.setWindowTitle("新单词")
        self.resize(800, 700)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)

        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)

        self.layout = QVBoxLayout()

        # 单词
        self.word_layout = QHBoxLayout()
        self.word_label = QLabel("单词:")
        self.word_label.setFont(word_font)
        self.word_input = QLineEdit()
        self.word_input.setFixedSize(400, 30)
        self.word_input.setStyleSheet(GRAY_INPUT_STYLE)
        self.word_layout.addWidget(self.word_label)
        self.word_layout.addWidget(self.word_input)
        self.scroll_layout.addLayout(self.word_layout)

        # 相关单词
        self.related_layout = QVBoxLayout()
        self.related_layout.setSpacing(10)
        self.related_items = [self.add_related_input_field(0)]
        self.add_related_button = QPushButton("+")
        self.add_related_button.setFixedSize(30, 30)
        self.add_related_button.setStyleSheet(GREEN_BUTTON_STYLE) # 加号按钮样式
        self.add_related_button.clicked.connect(self.add_related_input_row)
        self.remove_related_button = QPushButton("-")
        self.remove_related_button.setFixedSize(30, 30)
        self.remove_related_button.setStyleSheet(RED_BUTTON_STYLE) # 减号按钮样式
        self.remove_related_button.clicked.connect(self.remove_related_input_row)
        button_layout = QHBoxLayout()
        button_layout.addWidget(self.add_related_button)
        button_layout.addWidget(self.remove_related_button)
        self.scroll_layout.addLayout(self.related_layout)
        self.scroll_layout.addLayout(button_layout)

        # Separator
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        self.scroll_layout.addWidget(line)

        # 释义和例句
        self.meaning_example_layout = QVBoxLayout()
        self.meaning_example_grid = QGridLayout()
        self.meaning_inputs = [self.add_meaning_example_pair(0)]
        self.add_meaning_button = QPushButton("+")
        self.add_meaning_button.setFixedSize(30, 30)
        self.add_meaning_button.setStyleSheet(GREEN_BUTTON_STYLE) # 加号按钮样式
        self.add_meaning_button.clicked.connect(self.add_meaning_example_row)
        self.remove_meaning_button = QPushButton("-")
        self.remove_meaning_button.setFixedSize(30, 30)
        self.remove_meaning_button.setStyleSheet(RED_BUTTON_STYLE) # 减号按钮样式
        self.remove_meaning_button.clicked.connect(self.remove_meaning_example_row)
        self.meaning_example_layout.addLayout(self.meaning_example_grid)
        self.meaning_button_layout = QHBoxLayout()
        self.meaning_button_layout.addWidget(self.add_meaning_button)
        self.meaning_button_layout.addWidget(self.remove_meaning_button)
        self.meaning_example_layout.addLayout(self.meaning_button_layout)
        self.scroll_layout.addLayout(self.meaning_example_layout)

        # 备注
        self.note_layout = QHBoxLayout()
        self.note_label = QLabel("备注:")
        self.note_input = QTextEdit()
        self.note_input.setFixedSize(400, 90)
        self.note_input.setStyleSheet(GRAY_TEXT_EDIT_STYLE)
        self.note_layout.addWidget(self.note_label)
        self.note_layout.addWidget(self.note_input)
        self.scroll_layout.addLayout(self.note_layout)

        # 标签
        self.tag_label = QLabel("标签:")
        self.scroll_layout.addWidget(self.tag_label)

        self.tag_scroll_area = QScrollArea()
        self.tag_scroll_area.setWidgetResizable(True)
        self.tag_widget = QWidget()
        self.tag_layout = QVBoxLayout(self.tag_widget)
        self.tag_scroll_area.setWidget(self.tag_widget)

        self.new_tag_button = QPushButton("新建标签")
        self.new_tag_button.clicked.connect(self.add_new_tag)
        self.new_tag_button.setStyleSheet(PRIMARY_BUTTON_STYLE)

        self.scroll_layout.addWidget(self.tag_scroll_area)
        self.scroll_layout.addWidget(self.new_tag_button)
        self.load_tags()

        # 保存和取消按钮
        self.button_layout = QHBoxLayout()
        self.save_button = QPushButton("保存")
        self.cancel_button = QPushButton("取消")
        self.cancel_button.setStyleSheet(RED_BUTTON_STYLE)  # 取消按钮样式
        self.cancel_button.clicked.connect(self.close)
        self.save_button.setStyleSheet(SECONDARY_BUTTON_STYLE) # 保存按钮样式
        self.button_layout.addWidget(self.save_button)
        self.button_layout.addWidget(self.cancel_button)
        self.save_button.setFixedSize(80, 30)
        self.cancel_button.setFixedSize(80, 30)
        self.scroll_layout.addLayout(self.button_layout)

        self.save_button.clicked.connect(self.save_word)

        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)
        self.setLayout(self.layout)

    def add_meaning_example_pair(self, row):
        """
        新建“释义-例句”输入对，并在其上方预留隐藏的错误提示标签。
        每个输入对占两行：第 1 行放错误提示，第 2 行放输入控件。
        """
        base_row = row * 2  # 每对控件预留两行
        # ---------- 错误提示 ----------
        meaning_err = QLabel("")
        meaning_err.setStyleSheet("color: red;")
        meaning_err.hide()
        example_err = QLabel("")
        example_err.setStyleSheet("color: red;")
        example_err.hide()
        self.meaning_example_grid.addWidget(meaning_err, base_row, 1)
        self.meaning_example_grid.addWidget(example_err, base_row, 3)

        # ---------- 输入控件 ----------
        meaning_label = QLabel(f"释义{row + 1}:")
        meaning_label.setFont(meaning_font)
        meaning_input = QLineEdit()
        meaning_input.setFixedSize(180, 30)
        meaning_input.setStyleSheet(GRAY_INPUT_STYLE)

        example_label = QLabel(f"例句{row + 1}:")
        example_input = QTextEdit()
        example_input.setFixedSize(300, 90)
        example_input.setStyleSheet(GRAY_TEXT_EDIT_STYLE)

        self.meaning_example_grid.addWidget(meaning_label, base_row + 1, 0)
        self.meaning_example_grid.addWidget(meaning_input, base_row + 1, 1)
        self.meaning_example_grid.addWidget(example_label, base_row + 1, 2)
        self.meaning_example_grid.addWidget(example_input, base_row + 1, 3)

        return (meaning_input, example_input, meaning_err, example_err)

    def add_meaning_example_row(self):
        row = len(self.meaning_inputs)
        self.meaning_inputs.append(self.add_meaning_example_pair(row))

    def remove_meaning_example_row(self):
        if len(self.meaning_inputs) > 1:
            row = len(self.meaning_inputs) - 1
            for i in range(4):
                widget = self.meaning_example_grid.itemAtPosition(row, i).widget()
                if widget:
                    widget.deleteLater()
            self.meaning_inputs.pop()

    def add_related_input_field(self, index):
        layout = QHBoxLayout()
        label = QLabel(f"相关单词{index + 1}:")
        input_field = QLineEdit()
        input_field.setFixedSize(400, 30)
        input_field.setStyleSheet(GRAY_INPUT_STYLE)
        layout.addWidget(label)
        layout.addWidget(input_field)
        self.related_layout.addLayout(layout)
        return (layout, label, input_field)

    def add_related_input_row(self):
        index = len(self.related_items)
        self.related_items.append(self.add_related_input_field(index))

    def remove_related_input_row(self):
        if len(self.related_items) > 1:
            layout, label, input_field = self.related_items.pop()
            label.deleteLater()
            input_field.deleteLater()
            layout.deleteLater()

    def load_tags(self):
        if hasattr(self, 'tag_checkboxes'):
            for checkbox in self.tag_checkboxes:
                checkbox.setParent(None)
        self.tag_checkboxes = []
        tags_path = get_tags_path(self.book_name, self.book_color)
        if os.path.exists(tags_path):
            with open(tags_path, "r", encoding="utf-8") as file:
                tags = file.read().splitlines()
                for tag in tags:
                    tag_checkbox = QCheckBox(tag)
                    self.tag_layout.addWidget(tag_checkbox)
                    self.tag_checkboxes.append(tag_checkbox)

    def add_new_tag(self):
        tag, ok = QInputDialog.getText(self, "新建标签", "输入新标签:")
        if ok and tag:
            tags_path = get_tags_path(self.book_name, self.book_color)
            if os.path.exists(tags_path):
                with open(tags_path, "r", encoding="utf-8") as file:
                    existing_tags = file.read().splitlines()
            else:
                existing_tags = []

            if tag in existing_tags:
                QMessageBox.warning(self, "警告", "该标签已存在！", QMessageBox.Ok)
            else:
                with open(tags_path, "a", encoding="utf-8") as file:
                    file.write(tag + "\n")
                self.load_tags()
                for checkbox in self.tag_checkboxes:
                    if checkbox.text() == tag:
                        checkbox.setChecked(True)

                # 更新总单词册中的标签文件
                total_tags_path = get_total_tags_path()
                os.makedirs(os.path.dirname(total_tags_path), exist_ok=True)
                if os.path.exists(total_tags_path):
                    with open(total_tags_path, "r", encoding="utf-8") as file:
                        total_existing_tags = file.read().splitlines()
                else:
                    total_existing_tags = []

                if tag not in total_existing_tags:
                    with open(total_tags_path, "a", encoding="utf-8") as file:
                        file.write(tag + "\n")

    def save_word(self):
        """
        校验并保存单词。
        - 校验失败 → 在对应输入框上方显示红色“*该内容为必填字段”，弹窗提示但窗口保持开启
        - 校验成功 → 保存→发射 save_successful 信号→弹窗提示→关闭窗口
        """
        try:
            # ---------- 0. 先清空旧错误提示 ----------
            for tup in self.meaning_inputs:
                if len(tup) >= 4:
                    _, _, err_m, err_e = tup
                    err_m.hide();
                    err_m.setText("")
                    err_e.hide();
                    err_e.setText("")

            # ---------- 1. 收集字段 ----------
            word = self.word_input.text().strip()
            related = [w.text().strip() for _, _, w in self.related_items if w.text().strip()]
            tags = [c.text() for c in self.tag_checkboxes if c.isChecked()]
            note = self.note_input.toPlainText().strip()
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # ---------- 2. 校验释义-例句成对必填 ----------
            meanings, examples = [], []
            valid = True
            for meaning_inp, example_inp, err_m, err_e in self.meaning_inputs:
                m = meaning_inp.text().strip()
                e = example_inp.toPlainText().strip()

                if m and not e:  # 释义有值，例句缺失
                    err_e.setText("*该内容为必填字段")
                    err_e.show()
                    valid = False
                elif e and not m:  # 例句有值，释义缺失
                    err_m.setText("*该内容为必填字段")
                    err_m.show()
                    valid = False

                meanings.append(m)
                examples.append(e)

            # 过滤出真正成对的数据
            paired = [(m, e) for m, e in zip(meanings, examples) if m and e]

            # ---------- 3. 其它必填校验 ----------
            if not word:
                QMessageBox.warning(self, "警告", "单词不能为空！", QMessageBox.Ok)
                return
            if not paired:  # 全部为空或都不成对
                QMessageBox.warning(self, "警告", "至少填写一对释义和例句！", QMessageBox.Ok)
                return
            if not valid:  # 有红色提示，停止保存
                return

            # ---------- 4. 组织并保存 ----------
            data = {
                "单词": word,
                "相关单词": related,
                "标签": tags,
                "释义": [m for m, _ in paired],
                "例句": [e for _, e in paired],
                "备注": note,
                "时间": timestamp,
            }

            WS.save_word(self.book_name, self.book_color, data)

            # ---------- 5. 成功操作 ----------
            self.save_successful.emit(data)  # 发射信号，供父窗口刷新
            QMessageBox.information(self, "成功", "单词保存成功！", QMessageBox.Ok)
            self.close()

        except PermissionError:
            QMessageBox.warning(self, "错误", "无法写入文件，请检查文件占用或权限。", QMessageBox.Ok)
        except Exception as e:
            QMessageBox.critical(self, "错误", f"保存单词时发生错误：{e}", QMessageBox.Ok)

def show_word_entry_ui():
    app = QApplication(sys.argv)
    window = WordEntryUI()
    window.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    show_word_entry_ui()
add_new_word.py结束

business_logic.py开始
# business_logic.py
from data_access import load_words_from_excel, save_words_to_excel
from utils import get_excel_path
from db import delete_word as db_delete_word

def get_all_words(book_name, book_color):
   """Loads and return all word data for a given word book."""
   excel_path = get_excel_path(book_name, book_color)
   return load_words_from_excel(excel_path)

def save_word(book_name, book_color, data, sync_to_total = True):
    """Saves word data to a given word book."""
    try:
        excel_path = get_excel_path(book_name, book_color)
        save_words_to_excel(excel_path, data, sync_to_total)
    except Exception as e:
        raise Exception(f"保存单词失败：{str(e)}")

def delete_word(book_name, book_color, word):
    """Deletes a word from a given word book."""
    try:
        db_delete_word(book_name, book_color, word)
    except Exception as e:
        raise Exception(f"删除单词失败：{str(e)}")
business_logic.py结束

controllers/cover_controller.py开始
# controllers/cover_controller.py
from __future__ import annotations

import os, sys
from PySide6.QtCore import QObject, QEvent
from PySide6.QtWidgets import QMenu
from UI.cover_view import CoverView
from services.folder_service import FolderService
from services.cover_layout_service    import CoverLayoutService
from WordBookButton          import WordBookButton
from UI.word_book_inside.word_book_window import WordBookWindow
from db import load_words


class CoverController(QObject):
    """连接 CoverView ↔︎ 业务层；支持全局搜索 + 二级菜单"""

    def __init__(self, view: CoverView) -> None:
        super().__init__()
        self.view      = view
        self.fs        = FolderService()
        self.ls        = CoverLayoutService()
        self.edit_mode = False
        self._child_windows: list[WordBookWindow] = []

        # —— UI 信号 —— #
        v = self.view
        v.editToggled.connect(self._set_edit_mode)
        v.searchTextChanged.connect(self._on_search_text)
        v.suggestionSelected.connect(self._open_word_by_text)

        # —— 构建按钮 —— #
        self._load_buttons()
        self._restore_layout()
        # ⭐ 删除了 fs.layout_buttons —— CoverContent 会自行排版

        # —— 构建全局索引 —— #
        self._build_word_index()

        # —— 监听 viewport 宽度变化 —— #
        v.scroll_area.viewport().installEventFilter(self)

    # ============================================================
    #                    初始构建
    # ============================================================
    def _load_buttons(self) -> None:
        """重新扫描 books/ 并把按钮挂到 CoverContent 上"""
        self.view.clear_wordbook_buttons()
        self.buttons: list[WordBookButton] = self.fs.build_buttons(self.view.content)

        for btn in self.buttons:
            # —— 关键修改：不要再把 app 指到 Controller ——★
            # btn.app = self               ← 这一行整段删掉

            if getattr(btn, "is_new_button", False):
                btn.clicked.connect(self._create_wordbook)
            else:
                btn.clicked.connect(lambda _, p=btn.path: self._open_wordbook(p))

            self.view.add_wordbook_button(btn)

    def _restore_layout(self) -> None:
        layout = self.ls.load()
        if layout:
            self.fs.apply_layout(layout, self.buttons)

    # ============================================================
    #                     全局搜索
    # ============================================================
    def _build_word_index(self) -> None:
        """word_lower → [book_path, …]"""
        self.word_index: dict[str, list[str]] = {}
        for btn in self.buttons:
            if getattr(btn, "is_new_button", False):
                continue
            _, book_name, color = os.path.basename(btn.path).split("_", 2)
            try:
                for w in load_words(book_name, color):
                    key = str(w["单词"]).strip().lower()
                    if not key:
                        continue
                    self.word_index.setdefault(key, []).append(btn.path)
            except Exception as e:
                print("读取单词本失败:", e)

    def _on_search_text(self, text: str) -> None:
        text_l = text.strip().lower()
        self.fs.highlight_search(text, self.buttons)      # 按钮高亮

        if not text_l:
            self.view.hide_suggestions()
            return
        matches = [w for w in self.word_index if text_l in w][:50]
        self.view.show_suggestions(matches)

    # ============================================================
    #         建立二级菜单：同词存在于多个单词册
    # ============================================================
    def _open_word_by_text(self, word: str) -> None:
        paths = self.word_index.get(word.lower(), [])
        if not paths:
            return

        # —— 仅 1 本：直接打开 —— #
        if len(paths) == 1:
            self._open_wordbook(paths[0], target_word=word)
            return

        # —— 多本：弹二级菜单 —— #
        menu = QMenu(self.view)
        for p in paths:
            _, book_name, _ = os.path.basename(p).split("_", 2)
            act = menu.addAction(book_name)
            act.triggered.connect(lambda _, path=p: self._open_wordbook(path, target_word=word))

        # 菜单位置：紧贴搜索框下方
        global_pos = self.view.search_bar.mapToGlobal(self.view.search_bar.rect().bottomLeft())
        menu.exec_(global_pos)

    # ============================================================
    #                编辑模式 / 新建 / 搜索高亮
    # ============================================================
    def _set_edit_mode(self, entering: bool) -> None:
        """
        开关编辑模式：直接写入 CoverContent.edit_mode，
        停止使用 FolderService.set_edit_mode。
        """
        self.edit_mode = entering
        self.view.content.edit_mode = entering

        # 启动 / 停止按钮抖动
        for b in self.buttons:
            (b.start_jitter() if entering else b.stop_jitter())
        self.view.content.new_book_button.start_jitter() if entering else self.view.content.new_book_button.stop_jitter()

        if not entering:
            # 保存最新布局
            self.ls.save(self.fs.export_layout(self.buttons))

    def _create_wordbook(self) -> None:
        if self.fs.show_new_wordbook_dialog():
            self._load_buttons()
            self._restore_layout()
            self.fs.layout_buttons(self.view.content, self.buttons)
            self._build_word_index()           # 新单词本 → 重建索引

    # ============================================================
    #                     打开窗口
    # ============================================================
    def _open_wordbook(self, path: str, target_word: str | None = None) -> None:
        win = WordBookWindow(path, target_word=target_word)
        self._child_windows.append(win)   # 防 GC
        win.show()

    # ============================================================
    #          viewport Resize → 重新排版按钮
    # ============================================================
    def eventFilter(self, obj, event):
        """
        viewport 尺寸变化 → 让 CoverContent 重新排版
        """
        if event.type() == QEvent.Resize and obj is self.view.scroll_area.viewport():
            self.view.content.update_button_positions()
        return super().eventFilter(obj, event)
controllers/cover_controller.py结束

cover.py开始
# cover.py – 程序入口
import sys
from PySide6.QtWidgets import QApplication
from UI.cover_view import CoverView
from controllers.cover_controller import CoverController   # ← 路径未变

def main() -> None:
    app  = QApplication(sys.argv)
    view = CoverView()
    CoverController(view)   # 保持引用即可
    view.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

cover.py结束

data_access.py开始
#data_access.py
import os
from db import load_words, save_word
from utils import clean_data

def load_words_from_excel(path):
    """兼容旧接口，从路径获取单词本名称和颜色，然后从数据库加载单词"""
    try:
        # 从路径中提取单词本名称和颜色
        folder_name = os.path.basename(os.path.dirname(path))
        parts = folder_name.split('_')
        if len(parts) >= 3:
            book_name = parts[1]
            book_color = parts[2]
            return load_words(book_name, book_color)
        return []
    except Exception as e:
        print(f"Error loading words from database: {e}")
        return []


def save_words_to_excel(path, data, sync_to_total=True):
    """Saves word data to Excel file."""
    try:
        data = clean_data(data)
        
        # 从路径中提取单词本名称和颜色
        folder_name = os.path.basename(os.path.dirname(path))
        parts = folder_name.split('_')
        if len(parts) >= 3:
            book_name = parts[1]
            book_color = parts[2]
            # 调用db.py中的save_word函数保存数据
            save_word(book_name, book_color, data, sync_to_total)
        else:
            raise Exception("无法从路径中提取单词本信息")
    except Exception as e:
        raise Exception(f"保存单词数据时出错：{str(e)}")
data_access.py结束

db.py开始
# db.py
import os
import sys
import sqlite3
import json
from datetime import datetime

def get_db_path(book_name, color):
    """
    获取SQLite数据库文件路径
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        str: 数据库文件路径
    """
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    directory = os.path.join(base_dir, "books")
    os.makedirs(directory, exist_ok=True)
    folder_name = f"books_{book_name}_{color}"
    path = os.path.join(directory, folder_name)
    os.makedirs(path, exist_ok=True)
    return os.path.join(path, "wordbook.db")

def get_total_db_path():
    """
    获取总单词本数据库路径
    
    Returns:
        str: 总单词本数据库路径
    """
    return get_db_path("总单词册", "#FF0000")

def init_db(db_path):
    """
    初始化数据库，创建必要的表
    
    Args:
        db_path (str): 数据库文件路径
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # 创建单词表
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS words (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        word TEXT NOT NULL,
        meanings TEXT NOT NULL,  -- JSON格式存储释义列表
        examples TEXT,           -- JSON格式存储例句列表
        related_words TEXT,      -- JSON格式存储相关单词列表
        tags TEXT,               -- JSON格式存储标签列表
        note TEXT,               -- 备注
        timestamp TEXT,          -- 时间戳
        UNIQUE(word)
    )
    ''')
    
    # 创建标签表
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tag TEXT NOT NULL UNIQUE
    )
    ''')
    
    conn.commit()
    conn.close()

def get_connection(book_name, color):
    """
    获取数据库连接
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        sqlite3.Connection: 数据库连接对象
    """
    db_path = get_db_path(book_name, color)
    init_db(db_path)  # 确保数据库和表已创建
    return sqlite3.connect(db_path)

def load_words(book_name, color):
    """
    从数据库加载单词数据
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        list: 单词数据列表
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        cursor.execute("SELECT word, meanings, examples, related_words, tags, note, timestamp FROM words")
        rows = cursor.fetchall()
        
        words = []
        for row in rows:
            word, meanings, examples, related_words, tags, note, timestamp = row
            word_data = {
                "单词": word,
                "释义": json.loads(meanings),
                "例句": json.loads(examples) if examples else [],
                "相关单词": json.loads(related_words) if related_words else [],
                "标签": json.loads(tags) if tags else [],
                "备注": note if note else "",
                "时间": timestamp
            }
            words.append(word_data)
            
        conn.close()
        return words
    except Exception as e:
        print(f"Error loading words from database: {e}")
        return []

def save_word(book_name, color, data, sync_to_total=True):
    """
    保存 / 更新单词数据到数据库（『覆盖式』）。
    · 若单词不存在 ——> 直接插入
    · 若单词已存在 ——> 以最新提交的数据完全覆盖旧记录
      —— 这样才能正确处理『删除释义 / 例句』等编辑场景。
    """
    try:
        conn    = get_connection(book_name, color)
        cursor  = conn.cursor()

        # ---------- 1) 整理并去重 ----------
        word         = data["单词"]
        new_meanings = list(dict.fromkeys(data["释义"]))                # 去重但保持顺序
        new_examples = data.get("例句", [])
        new_related  = list(dict.fromkeys(data.get("相关单词", [])))
        new_tags     = list(dict.fromkeys(data.get("标签", [])))
        note         = data.get("备注", "")
        timestamp    = data.get("时间", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        # 例句条数不足时用空串占位，保证与释义等长
        if len(new_examples) < len(new_meanings):
            new_examples += [""] * (len(new_meanings) - len(new_examples))

        # ---------- 2) 查询是否已存在 ----------
        cursor.execute("SELECT id FROM words WHERE word = ?", (word,))
        row = cursor.fetchone()

        # ---------- 3) 覆盖更新 / 新增 ----------
        if row:        # ---- 更新 ----
            word_id = row[0]
            cursor.execute("""
                UPDATE words SET
                    meanings      = ?,
                    examples      = ?,
                    related_words = ?,
                    tags          = ?,
                    note          = ?,
                    timestamp     = ?
                WHERE id = ?
            """, (
                json.dumps(new_meanings, ensure_ascii=False),
                json.dumps(new_examples, ensure_ascii=False),
                json.dumps(new_related, ensure_ascii=False),
                json.dumps(new_tags,    ensure_ascii=False),
                note,
                timestamp,
                word_id
            ))
        else:          # ---- 插入 ----
            cursor.execute("""
                INSERT INTO words (
                    word, meanings, examples, related_words, tags, note, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (
                word,
                json.dumps(new_meanings, ensure_ascii=False),
                json.dumps(new_examples, ensure_ascii=False),
                json.dumps(new_related,  ensure_ascii=False),
                json.dumps(new_tags,     ensure_ascii=False),
                note,
                timestamp
            ))

        # ---------- 4) 新标签入库 ----------
        for tag in new_tags:
            cursor.execute("INSERT OR IGNORE INTO tags (tag) VALUES (?)", (tag,))

        conn.commit()
        conn.close()

        # ---------- 5) 同步到总单词册（同样采用覆盖策略） ----------
        if sync_to_total and book_name != "总单词册":
            sync_data        = data.copy()
            sync_data["备注"] = ""          # 总册不保留备注
            save_word_to_total(sync_data)

    except Exception as e:
        raise Exception(f"保存单词到数据库失败：{str(e)}")


def save_word_to_total(data):
    """
    保存单词到总单词本（#FF0000）。
    修复：同样基于『释义-例句对』精细合并，避免出现释义空行或例句错位。
    """
    try:
        conn   = get_connection("总单词册", "#FF0000")
        cursor = conn.cursor()

        word          = data["单词"]
        new_meanings  = data["释义"]
        new_examples  = data.get("例句", [])
        new_related   = data.get("相关单词", [])
        new_tags      = data.get("标签", [])
        timestamp     = data.get("时间", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        if len(new_examples) < len(new_meanings):
            new_examples += [""] * (len(new_meanings) - len(new_examples))

        cursor.execute(
            "SELECT id, meanings, examples, related_words, tags FROM words WHERE word = ?",
            (word,),
        )
        existing = cursor.fetchone()

        if existing:
            # ---------- 合并 ----------
            word_id, om_json, oe_json, or_json, ot_json = existing
            old_meanings = json.loads(om_json)
            old_examples = json.loads(oe_json) if oe_json else []
            old_related  = json.loads(or_json) if or_json else []
            old_tags     = json.loads(ot_json) if ot_json else []

            merged_meanings, merged_examples = _merge_meanings_examples(
                old_meanings, old_examples, new_meanings, new_examples
            )

            merged_related = old_related + [r for r in new_related if r not in old_related]
            merged_tags    = old_tags    + [t for t in new_tags if t not in old_tags]

            cursor.execute(
                """
                UPDATE words SET
                    meanings      = ?,
                    examples      = ?,
                    related_words = ?,
                    tags          = ?,
                    timestamp     = ?
                WHERE id = ?
                """,
                (
                    json.dumps(merged_meanings, ensure_ascii=False),
                    json.dumps(merged_examples, ensure_ascii=False),
                    json.dumps(merged_related, ensure_ascii=False),
                    json.dumps(merged_tags, ensure_ascii=False),
                    timestamp,
                    word_id,
                ),
            )
        else:
            # ---------- 直接插入 ----------
            cursor.execute(
                """
                INSERT INTO words (
                    word, meanings, examples,
                    related_words, tags, note, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    word,
                    json.dumps(new_meanings, ensure_ascii=False),
                    json.dumps(new_examples, ensure_ascii=False),
                    json.dumps(new_related, ensure_ascii=False),
                    json.dumps(new_tags, ensure_ascii=False),
                    "",        # 总单词册不记录备注
                    timestamp,
                ),
            )

        # ---- 标签入库 ----
        for tag in new_tags:
            cursor.execute("INSERT OR IGNORE INTO tags (tag) VALUES (?)", (tag,))

        conn.commit()
        conn.close()

    except Exception as e:
        raise Exception(f"保存单词到总单词本失败：{str(e)}")
def get_all_tags(book_name, color):
    """
    获取所有标签
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        list: 标签列表
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        cursor.execute("SELECT tag FROM tags ORDER BY tag")
        tags = [row[0] for row in cursor.fetchall()]
        
        conn.close()
        return tags
    except Exception as e:
        print(f"Error getting tags from database: {e}")
        return []

def save_tags(book_name, color, tags):
    """
    保存标签到数据库
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        tags (list): 标签列表
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        # 清空现有标签
        cursor.execute("DELETE FROM tags")
        
        # 插入新标签
        for tag in tags:
            cursor.execute("INSERT INTO tags (tag) VALUES (?)", (tag,))
        
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"Error saving tags to database: {e}")

def delete_word(book_name, color, word):
    """
    从数据库删除单词
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        word (str): 要删除的单词
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM words WHERE word = ?", (word,))
        
        conn.commit()
        conn.close()
    except Exception as e:
        raise Exception(f"删除单词失败：{str(e)}")

# ======== 1. 释义-例句 合并工具 ========
def _merge_meanings_examples(
    old_meanings: list[str],
    old_examples: list[str],
    new_meanings: list[str],
    new_examples: list[str],
) -> tuple[list[str], list[str]]:
    """
    按『释义-例句』成对合并，解决：
      • 仅凭释义去重 → 例句丢失
      • 释义已存在但旧例句为空 → 写入新例句
      • 同一释义可保留多条不同例句
    """
    # --- 长度对齐 ---
    if len(old_examples) < len(old_meanings):
        old_examples += [""] * (len(old_meanings) - len(old_examples))

    # --- 逐对处理 ---
    for m, ex in zip(new_meanings, new_examples):
        # a. 查找所有同释义的位置
        idx_list = [i for i, om in enumerate(old_meanings) if om == m]

        updated = False
        for idx in idx_list:
            # ① 完全重复 → 跳过
            if old_examples[idx] == ex:
                updated = True
                break
            # ② 旧例句为空 → 填充
            if not old_examples[idx] and ex:
                old_examples[idx] = ex
                updated = True
                break

        if updated:
            continue    # 已处理

        # b. 释义不存在 / 未匹配成功 → 追加新对
        old_meanings.append(m)
        old_examples.append(ex)

    return old_meanings, old_examples
db.py结束

db_memory.py开始
# db_memory.py
import sqlite3
import json
from datetime import datetime, timedelta
import pandas as pd

from db import get_db_path

# 艾宾浩斯遗忘曲线复习间隔（单位：天）
MEMORY_INTERVALS = [0, 1, 2, 4, 7, 15, 30]

def init_memory_table(db_path):
    """
    初始化记忆曲线数据表
    
    Args:
        db_path (str): 数据库文件路径
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # 创建记忆曲线数据表
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS memory_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        word TEXT NOT NULL,
        review_count INTEGER DEFAULT 0,  -- 复习次数
        last_review_date TEXT,          -- 上次复习时间
        next_review_date TEXT,          -- 下次复习时间
        correct_count INTEGER DEFAULT 0, -- 正确次数
        error_count INTEGER DEFAULT 0,   -- 错误次数
        UNIQUE(word)
    )
    ''')
    
    conn.commit()
    conn.close()

def get_memory_connection(book_name, color):
    """
    获取数据库连接并确保记忆表已创建
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        sqlite3.Connection: 数据库连接对象
    """
    db_path = get_db_path(book_name, color)
    init_memory_table(db_path)  # 确保记忆表已创建
    return sqlite3.connect(db_path)

def load_memory_data(book_name, color):
    """
    从数据库加载记忆数据
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        pd.DataFrame: 记忆数据DataFrame
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 获取所有单词
        cursor.execute("SELECT word FROM words")
        all_words = [row[0] for row in cursor.fetchall()]
        
        # 获取记忆数据
        cursor.execute("""
        SELECT word, review_count, last_review_date, next_review_date, correct_count, error_count 
        FROM memory_data
        """)
        memory_rows = cursor.fetchall()
        
        # 转换为字典列表
        memory_data = []
        memory_words = set()
        
        for row in memory_rows:
            word, review_count, last_review_date, next_review_date, correct_count, error_count = row
            memory_words.add(word)
            memory_data.append({
                "单词": word,
                "复习次数": review_count,
                "上次复习时间": last_review_date,
                "下次复习时间": next_review_date,
                "正确次数": correct_count,
                "错误次数": error_count
            })
        
        # 检查是否有新单词需要添加到记忆数据中
        new_words = set(all_words) - memory_words
        if new_words:
            today = datetime.now().strftime("%Y-%m-%d")
            for word in new_words:
                memory_data.append({
                    "单词": word,
                    "复习次数": 0,
                    "上次复习时间": None,
                    "下次复习时间": today,
                    "正确次数": 0,
                    "错误次数": 0
                })
                
                # 将新单词添加到数据库
                cursor.execute("""
                INSERT INTO memory_data (word, review_count, last_review_date, next_review_date, correct_count, error_count)
                VALUES (?, ?, ?, ?, ?, ?)
                """, (word, 0, None, today, 0, 0))
            
            conn.commit()
        
        # 检查是否有已删除的单词需要从记忆数据中移除
        deleted_words = memory_words - set(all_words)
        if deleted_words:
            for word in deleted_words:
                cursor.execute("DELETE FROM memory_data WHERE word = ?", (word,))
            conn.commit()
            # 从内存中的记忆数据中移除已删除的单词
            memory_data = [data for data in memory_data if data["单词"] not in deleted_words]
        
        conn.close()
        
        # 转换为DataFrame
        memory_df = pd.DataFrame(memory_data)
        return memory_df
    
    except Exception as e:
        print(f"Error loading memory data: {e}")
        # 返回空DataFrame，包含必要的列
        return pd.DataFrame(columns=["单词", "复习次数", "上次复习时间", "下次复习时间", "正确次数", "错误次数"])

def save_memory_data(book_name, color, memory_data):
    """
    保存记忆数据到数据库
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        memory_data (pd.DataFrame): 记忆数据DataFrame
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 遍历DataFrame中的每一行
        for _, row in memory_data.iterrows():
            word = row["单词"]
            review_count = int(row["复习次数"])
            last_review_date = row["上次复习时间"]
            next_review_date = row["下次复习时间"]
            correct_count = int(row["正确次数"])
            error_count = int(row["错误次数"])
            
            # 检查单词是否已存在
            cursor.execute("SELECT id FROM memory_data WHERE word = ?", (word,))
            existing = cursor.fetchone()
            
            if existing:
                # 更新现有记录
                cursor.execute("""
                UPDATE memory_data SET 
                    review_count = ?,
                    last_review_date = ?,
                    next_review_date = ?,
                    correct_count = ?,
                    error_count = ?
                WHERE word = ?
                """, (review_count, last_review_date, next_review_date, correct_count, error_count, word))
            else:
                # 插入新记录
                cursor.execute("""
                INSERT INTO memory_data (word, review_count, last_review_date, next_review_date, correct_count, error_count)
                VALUES (?, ?, ?, ?, ?, ?)
                """, (word, review_count, last_review_date, next_review_date, correct_count, error_count))
        
        conn.commit()
        conn.close()
    
    except Exception as e:
        print(f"Error saving memory data: {e}")
        raise Exception(f"保存记忆数据失败: {str(e)}")

def get_review_words(book_name, color):
    """
    获取今天需要复习的单词
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        list: 需要复习的单词数据列表
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 获取今天需要复习的单词
        today = datetime.now().strftime("%Y-%m-%d")
        cursor.execute("""
        SELECT m.word, m.review_count, m.last_review_date, m.next_review_date, m.correct_count, m.error_count
        FROM memory_data m
        WHERE m.next_review_date <= ?
        """, (today,))
        
        memory_rows = cursor.fetchall()
        if not memory_rows:
            conn.close()
            return []
        
        # 获取单词详细信息
        review_words = []
        for row in memory_rows:
            word, review_count, last_review_date, next_review_date, correct_count, error_count = row
            
            # 获取单词详细信息
            cursor.execute("""
            SELECT meanings, examples, related_words, tags, note
            FROM words
            WHERE word = ?
            """, (word,))
            
            word_info = cursor.fetchone()
            if word_info:
                meanings, examples, related_words, tags, note = word_info
                
                word_data = {
                    "单词": word,
                    "释义": json.loads(meanings),
                    "例句": json.loads(examples) if examples else [],
                    "相关单词": json.loads(related_words) if related_words else [],
                    "标签": json.loads(tags) if tags else [],
                    "备注": note if note else "",
                    "复习次数": review_count,
                    "上次复习时间": last_review_date,
                    "下次复习时间": next_review_date,
                    "正确次数": correct_count,
                    "错误次数": error_count
                }
                
                review_words.append(word_data)
        
        conn.close()
        return review_words
    
    except Exception as e:
        print(f"Error getting review words: {e}")
        return []

def update_word_memory_status(book_name, color, word, is_correct):
    """
    更新单词的记忆状态
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        word (str): 单词
        is_correct (bool): 是否回答正确
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 获取当前记忆状态
        cursor.execute("""
        SELECT review_count, correct_count, error_count
        FROM memory_data
        WHERE word = ?
        """, (word,))
        
        row = cursor.fetchone()
        if not row:
            conn.close()
            return
        
        review_count, correct_count, error_count = row
        review_count += 1
        today = datetime.now().strftime("%Y-%m-%d")
        
        if is_correct:
            correct_count += 1
            # 更新下次复习时间
            review_stage = min(review_count, len(MEMORY_INTERVALS) - 1)
            next_review_date = (datetime.now() + timedelta(days=MEMORY_INTERVALS[review_stage])).strftime("%Y-%m-%d")
        else:
            error_count += 1
            # 错误的单词第二天就复习
            next_review_date = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
        
        # 更新记忆状态
        cursor.execute("""
        UPDATE memory_data SET 
            review_count = ?,
            last_review_date = ?,
            next_review_date = ?,
            correct_count = ?,
            error_count = ?
        WHERE word = ?
        """, (review_count, today, next_review_date, correct_count, error_count, word))
        
        conn.commit()
        conn.close()
    
    except Exception as e:
        print(f"Error updating word memory status: {e}")
        raise Exception(f"更新单词记忆状态失败: {str(e)}")
db_memory.py结束

font.py开始
#font.py
from PySide6.QtGui import QFont, QPalette, QColor

# 使用通用字体族，确保在任何中文Windows系统上都能正常显示
normal_font = QFont("Microsoft YaHei, SimSun, sans-serif", 12)

meaning_font = QFont("Microsoft YaHei, SimSun, sans-serif", 13)
meaning_font.setBold(True)

sentence_font = QFont("Microsoft YaHei, SimSun, sans-serif", 13)
sentence_font.setBold(True)
sentence_font_platte = QPalette()
sentence_font_platte.setColor(QPalette.WindowText, QColor("gray"))

word_font = QFont("Microsoft YaHei, SimSun, sans-serif", 15)
word_font.setBold(True)

note_font = QFont("SimSun, Microsoft YaHei, sans-serif")

# 对于英文字体，添加备选字体
main_word_font = QFont("Georgia, Times New Roman, serif", 35)
main_word_font.setBold(True)
main_word_font.setWordSpacing(2.5)

list_word_font = QFont("Georgia, Times New Roman, serif", 12)
list_word_font.setBold(True)
font.py结束

memory_curve.py开始
# memory_curve.py
import os
import sys
import pandas as pd
import random
from datetime import datetime, timedelta
from PySide6.QtCore import Qt, QTimer
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QLineEdit, QMessageBox, QFrame, QTextEdit
)
from font import meaning_font, main_word_font, list_word_font, sentence_font
from styles import PRIMARY_BUTTON_STYLE, SECONDARY_BUTTON_STYLE, TEXT_EDIT_STYLE, LINE_EDIT_STYLE
from db_memory import load_memory_data, save_memory_data, get_review_words, update_word_memory_status

# 艾宾浩斯遗忘曲线复习间隔（单位：天）
MEMORY_INTERVALS = [0, 1, 2, 4, 7, 15, 30]

class MemoryCurveApp(QWidget):
    def __init__(self, path):
        super().__init__()
        self.path = os.path.dirname(os.path.abspath(sys.argv[0]))  # 使用可执行文件所在目录
        self.book_name = os.path.basename(path).split('_')[1]  # 获取单词本名称
        self.book_color = os.path.basename(path).split('_')[2]  # 获取单词本颜色
        
        # 初始化数据
        self.current_word_index = 0
        self.correct_count = 0
        self.total_count = 0
        self.review_words = []
        
        # 初始化界面
        self.init_ui()
        self.load_memory_data()
        self.load_review_words()
        
    def init_ui(self):
        self.setWindowTitle(f"背单词 - {self.book_name}")
        self.resize(800, 600)
        
        main_layout = QVBoxLayout()
        
        # 顶部信息栏
        info_layout = QHBoxLayout()
        self.progress_label = QLabel("进度: 0/0")
        self.correct_label = QLabel("正确率: 0%")
        info_layout.addWidget(self.progress_label)
        info_layout.addStretch()
        info_layout.addWidget(self.correct_label)
        main_layout.addLayout(info_layout)
        
        # 分隔线
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line)
        
        # 释义区域
        self.meaning_area = QTextEdit()
        self.meaning_area.setReadOnly(True)
        self.meaning_area.setFont(meaning_font)
        self.meaning_area.setStyleSheet(TEXT_EDIT_STYLE)
        main_layout.addWidget(self.meaning_area)
        
        # 下划线提示区域
        self.hint_label = QLabel("")
        self.hint_label.setAlignment(Qt.AlignCenter)
        self.hint_label.setFont(main_word_font)
        main_layout.addWidget(self.hint_label)
        
        # 输入区域
        input_layout = QHBoxLayout()
        self.word_input = QLineEdit()
        self.word_input.setPlaceholderText("请输入单词")
        self.word_input.setFont(list_word_font)
        self.word_input.setStyleSheet(LINE_EDIT_STYLE)
        self.word_input.returnPressed.connect(self.check_answer)
        self.word_input.textChanged.connect(self.update_hint_display)
        input_layout.addWidget(self.word_input)
        
        self.check_button = QPushButton("确认")
        self.check_button.setStyleSheet(PRIMARY_BUTTON_STYLE)
        self.check_button.clicked.connect(self.check_answer)
        input_layout.addWidget(self.check_button)
        
        main_layout.addLayout(input_layout)
        
        # 结果显示区域
        self.result_label = QLabel("")
        self.result_label.setAlignment(Qt.AlignCenter)
        self.result_label.setFont(main_word_font)
        main_layout.addWidget(self.result_label)
        
        # 例句区域
        self.example_area = QTextEdit()
        self.example_area.setReadOnly(True)
        self.example_area.setFont(sentence_font)
        self.example_area.setStyleSheet(TEXT_EDIT_STYLE)
        self.example_area.setVisible(False)  # 初始隐藏
        main_layout.addWidget(self.example_area)
        
        # 按钮区域
        button_layout = QHBoxLayout()
        
        self.hint_button = QPushButton("提示")
        self.hint_button.setStyleSheet(SECONDARY_BUTTON_STYLE)
        self.hint_button.clicked.connect(self.show_letter_hint)
        button_layout.addWidget(self.hint_button)
        
        self.show_answer_button = QPushButton("显示答案")
        self.show_answer_button.setStyleSheet(SECONDARY_BUTTON_STYLE)
        self.show_answer_button.clicked.connect(self.show_answer)
        button_layout.addWidget(self.show_answer_button)
        
        self.next_button = QPushButton("下一个")
        self.next_button.setStyleSheet(PRIMARY_BUTTON_STYLE)
        self.next_button.clicked.connect(self.next_word)
        self.next_button.setEnabled(False)  # 初始禁用
        button_layout.addWidget(self.next_button)
        
        main_layout.addLayout(button_layout)
        
        self.setLayout(main_layout)
        
        # 初始化提示相关变量
        self.current_word = ""
        self.revealed_letters = 0
    
    def load_memory_data(self):
        """加载记忆数据"""
        try:
            # 使用SQLite数据库加载记忆数据
            self.memory_data = load_memory_data(self.book_name, self.book_color)
            
            if self.memory_data.empty:
                QMessageBox.warning(self, "提示", "记忆数据为空，将创建新的记忆数据。")
                
        except Exception as e:
            QMessageBox.warning(self, "错误", f"加载记忆数据失败: {str(e)}")
            self.memory_data = pd.DataFrame(columns=["单词", "复习次数", "上次复习时间", "下次复习时间", "正确次数", "错误次数"])
    
    def save_memory_data(self):
        """保存记忆数据"""
        try:
            # 使用SQLite数据库保存记忆数据
            save_memory_data(self.book_name, self.book_color, self.memory_data)
        except Exception as e:
            QMessageBox.warning(self, "错误", f"保存记忆数据失败: {str(e)}")
    
    def load_review_words(self):
        """加载需要复习的单词"""
        try:
            # 使用SQLite数据库获取今天需要复习的单词
            self.review_words = get_review_words(self.book_name, self.book_color)
            
            if not self.review_words:
                QMessageBox.information(self, "提示", "今天没有需要复习的单词!")
                return
            
            # 随机打乱顺序
            random.shuffle(self.review_words)
            
            self.total_count = len(self.review_words)
            self.current_word_index = 0
            self.correct_count = 0
            
            self.update_progress()
            self.show_current_word()
        except Exception as e:
            QMessageBox.warning(self, "错误", f"加载单词数据失败: {str(e)}")
    
    def update_progress(self):
        """更新进度信息"""
        if self.total_count > 0:
            self.progress_label.setText(f"进度: {self.current_word_index}/{self.total_count}")
            correct_rate = (self.correct_count / max(1, self.current_word_index)) * 100 if self.current_word_index > 0 else 0
            self.correct_label.setText(f"正确率: {correct_rate:.1f}%")
        else:
            self.progress_label.setText("进度: 0/0")
            self.correct_label.setText("正确率: 0%")
    
    def show_current_word(self):
        """显示当前单词的释义"""
        if not self.review_words or self.current_word_index >= len(self.review_words):
            QMessageBox.information(self, "完成", "恭喜你完成了今天的复习!")
            self.close()
            return
        
        # 重置界面状态
        self.word_input.clear()
        self.word_input.setEnabled(True)
        self.check_button.setEnabled(True)
        self.show_answer_button.setEnabled(True)
        self.hint_button.setEnabled(True)
        self.next_button.setEnabled(False)
        self.result_label.clear()
        self.example_area.clear()
        self.example_area.setVisible(False)
        
        # 显示释义
        current_word = self.review_words[self.current_word_index]
        self.current_word = current_word["单词"]  # 保存当前单词
        self.revealed_letters = 0  # 重置已提示的字母数
        
        meanings = current_word.get("释义", [])
        
        meanings_text = ""
        for i, meaning in enumerate(meanings):
            meanings_text += f"释义{i+1}: {meaning}\n\n"
        
        self.meaning_area.setText(meanings_text)
        
        # 显示下划线提示
        self.update_hint_display()
        
        self.word_input.setFocus()
    def update_hint_display(self):
        """根据单词长度和用户输入更新下划线提示"""
        if not hasattr(self, 'current_word') or not self.current_word:
            return
            
        # 确保current_word是字符串类型
        if not isinstance(self.current_word, str):
            self.current_word = str(self.current_word)
            
        word_length = len(self.current_word)
        user_input = self.word_input.text()
        
        # 创建下划线提示
        hint_text = ""
        for i in range(word_length):
            if i < self.revealed_letters:
                # 已提示的字母
                hint_text += f" {self.current_word[i]} "
            elif i < len(user_input):
                # 用户已输入的字母
                hint_text += f" {user_input[i]} "
            else:
                # 未输入的字母用下划线表示
                hint_text += " _ "
                
        self.hint_label.setText(hint_text)
    
    def show_letter_hint(self):
        """提示下一个字母"""
        if not self.current_word or self.revealed_letters >= len(self.current_word):
            return
            
        self.revealed_letters += 1
        self.update_hint_display()
        
        # 如果已经提示了所有字母，禁用提示按钮
        if self.revealed_letters >= len(self.current_word):
            self.hint_button.setEnabled(False)
    
    def check_answer(self):
        """检查答案"""
        if not self.review_words or self.current_word_index >= len(self.review_words):
            return
        try:
            user_input = self.word_input.text().strip().lower()
            current_word = self.review_words[self.current_word_index]
            
            # 确保current_word是字典类型且包含单词字段
            if not isinstance(current_word, dict) or "单词" not in current_word:
                raise ValueError("单词数据格式错误")
                
            correct_word = str(current_word["单词"]).strip().lower()
            
            if user_input == correct_word:
                # 答案正确
                self.result_label.setText("✓ 正确!")
                self.result_label.setStyleSheet("color: green;")
                self.correct_count += 1
                
                # 使用SQLite数据库更新单词记忆状态
                update_word_memory_status(self.book_name, self.book_color, current_word["单词"], True)
                
                # 更新内存中的数据以保持UI一致性
                word_idx = self.memory_data[self.memory_data["单词"] == current_word["单词"]].index[0]
                self.memory_data.at[word_idx, "正确次数"] = self.memory_data.at[word_idx, "正确次数"] + 1
                self.memory_data.at[word_idx, "复习次数"] = self.memory_data.at[word_idx, "复习次数"] + 1
                review_stage = min(self.memory_data.at[word_idx, "复习次数"], len(MEMORY_INTERVALS) - 1)
                next_review_date = datetime.now() + timedelta(days=MEMORY_INTERVALS[review_stage])
                self.memory_data.at[word_idx, "上次复习时间"] = datetime.now().strftime("%Y-%m-%d")
                self.memory_data.at[word_idx, "下次复习时间"] = next_review_date.strftime("%Y-%m-%d")
            else:
                # 答案错误
                self.result_label.setText(f"✗ 错误! 正确答案是: {current_word['单词']}")
                self.result_label.setStyleSheet("color: red;")
                
                # 使用SQLite数据库更新单词记忆状态
                update_word_memory_status(self.book_name, self.book_color, current_word["单词"], False)
                
                # 更新内存中的数据以保持UI一致性
                word_idx = self.memory_data[self.memory_data["单词"] == current_word["单词"]].index[0]
                self.memory_data.at[word_idx, "错误次数"] = self.memory_data.at[word_idx, "错误次数"] + 1
                self.memory_data.at[word_idx, "复习次数"] = self.memory_data.at[word_idx, "复习次数"] + 1
                self.memory_data.at[word_idx, "上次复习时间"] = datetime.now().strftime("%Y-%m-%d")
                self.memory_data.at[word_idx, "下次复习时间"] = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
                
                # 将当前单词添加到队列末尾，以便再次复习
                self.review_words.append(current_word)
            
            # 显示例句
            examples = current_word.get("例句", [])
            if examples:
                examples_text = ""
                for i, example in enumerate(examples):
                    examples_text += f"例句{i+1}: {example}\n\n"
                self.example_area.setText(examples_text)
                self.example_area.setVisible(True)
            
            # 禁用输入和检查按钮，启用下一个按钮
            self.word_input.setEnabled(False)
            self.check_button.setEnabled(False)
            self.show_answer_button.setEnabled(False)
            self.hint_button.setEnabled(False)  # 禁用提示按钮
            self.next_button.setEnabled(True)
            
            # 保存记忆数据
            self.save_memory_data()
            self.update_progress()
        except Exception as e:
            QMessageBox.warning(self, "错误", f"检查答案时发生错误: {str(e)}")
    def show_answer(self):
        """显示答案"""
        if not self.review_words or self.current_word_index >= len(self.review_words):
            return
        
        current_word = self.review_words[self.current_word_index]
        self.result_label.setText(f"答案: {current_word['单词']}")
        self.result_label.setStyleSheet("color: blue;")
        
        # 显示例句
        examples = current_word.get("例句", [])
        if examples:
            examples_text = ""
            for i, example in enumerate(examples):
                examples_text += f"例句{i+1}: {example}\n\n"
            self.example_area.setText(examples_text)
            self.example_area.setVisible(True)
        
        # 使用SQLite数据库更新单词记忆状态 - 显示答案视为错误
        update_word_memory_status(self.book_name, self.book_color, current_word["单词"], False)
        
        # 更新内存中的数据以保持UI一致性
        word_idx = self.memory_data[self.memory_data["单词"] == current_word["单词"]].index[0]
        self.memory_data.at[word_idx, "错误次数"] = self.memory_data.at[word_idx, "错误次数"] + 1
        self.memory_data.at[word_idx, "复习次数"] = self.memory_data.at[word_idx, "复习次数"] + 1
        self.memory_data.at[word_idx, "上次复习时间"] = datetime.now().strftime("%Y-%m-%d")
        self.memory_data.at[word_idx, "下次复习时间"] = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
        
        # 将当前单词添加到队列末尾，以便再次复习
        self.review_words.append(current_word)
        
        # 禁用输入和检查按钮，启用下一个按钮
        self.word_input.setEnabled(False)
        self.check_button.setEnabled(False)
        self.show_answer_button.setEnabled(False)
        self.hint_button.setEnabled(False)  # 禁用提示按钮
        self.next_button.setEnabled(True)
    
    def next_word(self):
        """进入下一个单词"""
        self.current_word_index += 1
        self.show_current_word()


    def closeEvent(self, event):
        """窗口关闭事件处理"""
        # 数据已经在每次更新时保存到SQLite数据库，不需要再次保存
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    if len(sys.argv) > 1:
        path = sys.argv[1]
        window = MemoryCurveApp(path)
        window.show()
        sys.exit(app.exec())
    else:
        print("请提供单词本路径")
memory_curve.py结束

python collect_py_files.py.py开始
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
collect_py_files.py

遍历根目录下所有 .py 文件，输出：
1. py_structure.txt          —— 目录结构（仅列出含 .py 的目录与文件）
2. combined_py_code.txt      —— 合并后的源码（带“开始/结束”标记）

用法：
    python collect_py_files.py <root_dir> [-s STRUCT_FILE] [-c COMBINED_FILE]
"""
from __future__ import annotations

import argparse
import os
from pathlib import Path
from typing import List


def find_py_files(root: Path) -> List[Path]:
    """递归收集 root 下的全部 .py 文件（按相对路径排序）"""
    return sorted(
        (p for p in root.rglob("*.py") if p.is_file()),
        key=lambda p: p.relative_to(root).as_posix()
    )


def write_structure(root: Path, py_files: List[Path], outfile: Path) -> None:
    """
    按目录层级写出仅含 .py 的“树状结构”：
    project/
        package/
            module.py
    """
    # 先收集每个目录下有哪些 py
    dirs_with_py: set[Path] = {p.parent for p in py_files}
    # 自底向上把父目录也加进来（以便保持层级完整）
    for d in list(dirs_with_py):
        while d != root:
            d = d.parent
            dirs_with_py.add(d)

    with outfile.open("w", encoding="utf-8") as f:
        def _walk(current: Path, depth: int = 0) -> None:
            indent = "    " * depth
            if current != root:  # 根目录名称通常显而易见，可省略
                f.write(f"{indent}{current.name}/\n")
            sub_indent = indent + "    "
            # 输出当前目录下的 .py 文件
            for py in sorted(p for p in current.iterdir() if p.suffix == ".py"):
                f.write(f"{sub_indent}{py.name}\n")
            # 递归子目录
            for sub in sorted(p for p in current.iterdir() if p.is_dir()):
                if sub in dirs_with_py:
                    _walk(sub, depth + 1)

        _walk(root)


def write_combined(root: Path, py_files: List[Path], outfile: Path) -> None:
    """把所有 .py 文件源码合并输出"""
    with outfile.open("w", encoding="utf-8") as f:
        for path in py_files:
            rel = path.relative_to(root).as_posix()
            f.write(f"{rel}开始\n")
            f.write(path.read_text(encoding="utf-8", errors="ignore"))
            f.write(f"\n{rel}结束\n\n")


def main() -> None:
    parser = argparse.ArgumentParser(...)
    parser.add_argument(
        "root_dir",
        nargs="?",  # 变成可选
        type=Path,
        default=Path.cwd(),  # 默认用当前工作目录
        help="根目录路径（默认=当前工作目录）"
    )
    parser.add_argument(
        "-s", "--structure-file",
        type=Path,
        default=Path("py_structure.txt"),
        help="目录结构输出文件（默认 py_structure.txt）"
    )
    parser.add_argument(
        "-c", "--combined-file",
        type=Path,
        default=Path("combined_py_code.txt"),
        help="合并源码输出文件（默认 combined_py_code.txt）"
    )
    args = parser.parse_args()

    root = args.root_dir.resolve()
    if not root.is_dir():
        raise SystemExit(f"错误：{root} 不是有效的目录。")

    py_files = find_py_files(root)
    if not py_files:
        print("未找到任何 .py 文件，未生成输出。")
        return

    write_structure(root, py_files, args.structure_file.resolve())
    write_combined(root, py_files, args.combined_file.resolve())

    print(f"已生成：\n  - {args.structure_file.resolve()}\n  - {args.combined_file.resolve()}")


if __name__ == "__main__":
    main()
python collect_py_files.py.py结束

repositories/__init__.py开始
"""Repository package public interface."""

from .word_repository import WordRepository

__all__: list[str] = [
    "WordRepository",
]

repositories/__init__.py结束

repositories/layout_repository.py开始
# repositories/layout_repository.py
"""持久化 Cover 布局 JSON（不做任何业务校验）"""
import json
import os
import sys
from typing import Any, Dict, List


def _layout_file_path() -> str:
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    return os.path.join(base_dir, "cover_layout.json")


class LayoutRepository:
    @staticmethod
    def load_layout() -> List[Dict[str, Any]]:
        """读取 cover_layout.json，异常时返回空列表"""
        path = _layout_file_path()
        if not os.path.exists(path):
            return []
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            return data.get("layout", [])
        except Exception:
            return []

    @staticmethod
    def save_layout(layout_items: List[Dict[str, Any]]) -> None:
        path = _layout_file_path()
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump({"layout": layout_items}, f, ensure_ascii=False, indent=2)
        except Exception as exc:
            raise RuntimeError(f"保存 cover 布局失败: {exc}") from exc

repositories/layout_repository.py结束

repositories/memory_repository.py开始
# repositories/memory_repository.py
"""
纯数据访问层：背单词 / 记忆曲线相关持久化
"""
import pandas as pd
from db_memory import (
    load_memory_data as _load,
    save_memory_data as _save,
    get_review_words as _review,
    update_word_memory_status as _update,
)


class MemoryRepository:
    """对 db_memory.py 做一次薄封装"""

    # ---------- DataFrame 全量读 / 写 ----------
    @staticmethod
    def load_memory_df(book: str, color: str) -> pd.DataFrame:
        return _load(book, color)

    @staticmethod
    def save_memory_df(book: str, color: str, df: pd.DataFrame) -> None:
        _save(book, color, df)

    # ---------- 业务片段 ----------
    @staticmethod
    def get_today_review_words(book: str, color: str) -> list[dict]:
        return _review(book, color)

    @staticmethod
    def update_word_status(book: str, color: str, word: str, is_correct: bool) -> None:
        _update(book, color, word, is_correct)

repositories/memory_repository.py结束

repositories/tag_repository.py开始
# repositories/tag_repository.py
"""
纯数据访问层：所有【标签】相关的持久化操作
"""
from db import get_all_tags as _get_all_tags, save_tags as _save_tags


class TagRepository:
    """封装 db.py 里的标签 API，保证 UI/Service 不直接依赖 db.py"""

    @staticmethod
    def list_tags(book_name: str, color: str) -> list[str]:
        """返回指定单词本的全部标签（按字典序）"""
        return _get_all_tags(book_name, color)

    @staticmethod
    def add_tag(book_name: str, color: str, new_tag: str) -> None:
        """向指定单词本追加单个标签（自动去重）"""
        tags = _get_all_tags(book_name, color)
        if new_tag not in tags:
            tags.append(new_tag)
            _save_tags(book_name, color, tags)

repositories/tag_repository.py结束

repositories/word_repository.py开始
"""repositories/word_repository.py
---------------------------------
Wrap db.py helpers so upper layers never import db directly.
"""
from __future__ import annotations

from typing import Any, Dict, List

from db import (
    load_words as _load_words,
    save_word as _save_word,
    delete_word as _delete_word,
)


class WordRepository:
    """Thin data-access wrapper."""

    # -------- Query --------
    @staticmethod
    def list_words(book_name: str, color: str) -> List[Dict[str, Any]]:
        return _load_words(book_name, color)

    # -------- Save / Update --------
    @staticmethod
    def save_word(
        book_name: str,
        color: str,
        data: Dict[str, Any],
        *,
        sync_to_total: bool = True,
    ) -> None:
        _save_word(book_name, color, data, sync_to_total=sync_to_total)

    # -------- Delete --------
    @staticmethod
    def delete_word(book_name: str, color: str, word: str) -> None:
        _delete_word(book_name, color, word)

repositories/word_repository.py结束

services/__init__.py开始
"""Service package public interface.

Re‑export the main service classes so callers can simply do:

    from services import WordBookService
"""

from .wordbook_service import WordBookService

__all__: list[str] = [
    "WordBookService",
]

services/__init__.py结束

services/cover_layout_service.py开始
# services/cover_layout_service.py
"""
Cover 布局业务封装：UI <-> Repository 中间层，便于后期加缓存、版本迁移等。
"""
from typing import Any, Dict, List
from repositories.layout_repository import LayoutRepository


class CoverLayoutService:
    @staticmethod
    def load() -> List[Dict[str, Any]]:
        return LayoutRepository.load_layout()

    @staticmethod
    def save(layout_items: List[Dict[str, Any]]) -> None:
        LayoutRepository.save_layout(layout_items)

services/cover_layout_service.py结束

services/folder_service.py开始
from __future__ import annotations

import os
import sys
from typing import List

from WordBookButton import WordBookButton

from UI.Folder_UI._background import update_all_folder_backgrounds


class FolderService:
    """Business‑logic layer for the cover page.

    * IO: scan 'books/' directory and build buttons
    * Simple visual high‑lighting for global search
    * Edit‑mode toggling (start / stop jitter)
    * Layout persistence (export / apply)
    """

    def __init__(self) -> None:
        # will be set to the ``CoverContent`` instance in ``build_buttons``
        self.content = None  # type: ignore

    # ------------------------------------------------------------------
    #               build & lay‑out buttons
    # ------------------------------------------------------------------
    def build_buttons(self, parent) -> List[WordBookButton]:
        """Create ``WordBookButton`` instances for each folder under *books/*.
        The *parent* argument is the ``CoverContent`` instance."""
        self.content = parent

        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        books_dir = os.path.join(base_dir, "books")
        os.makedirs(books_dir, exist_ok=True)

        buttons: list[WordBookButton] = []
        for folder in os.listdir(books_dir):
            if not folder.startswith("books_"):
                continue
            try:
                _, book_name, book_color = folder.split("_", 2)
            except ValueError:
                # malformed directory name – skip
                continue

            path = os.path.join(books_dir, folder)
            btn = WordBookButton(book_name, book_color, parent=parent, app=parent)
            btn.path = path
            buttons.append(btn)

        # -------- "新建单词本" button --------
        if parent.new_book_button.parent() is None:
            parent.new_book_button.setParent(parent)
        buttons.append(parent.new_book_button)

        return buttons

    def layout_buttons(self, content, buttons):
        content.buttons = buttons
        content.update_button_positions()
        update_all_folder_backgrounds(content, content.button_width, content.button_height)

    # ------------------------------------------------------------------
    #                    edit‑mode switch
    # ------------------------------------------------------------------
    def set_edit_mode(self, entering: bool, buttons: list[WordBookButton]) -> None:
        if self.content:
            self.content.edit_mode = entering

        for b in buttons:
            (b.start_jitter() if entering else b.stop_jitter())

        # make the "new book" button jitter as well
        if self.content:
            if entering:
                self.content.new_book_button.start_jitter()
            else:
                self.content.new_book_button.stop_jitter()

    # ------------------------------------------------------------------
    #                    search high‑light
    # ------------------------------------------------------------------
    def highlight_search(self, kw: str, buttons: list[WordBookButton]) -> None:
        kw_lc = kw.strip().lower()
        for b in buttons:
            if getattr(b, "is_new_button", False):
                continue
            matched = kw_lc and kw_lc in b.text().lower()
            b.setStyleSheet(
                b.styleSheet()
                + ("border:2px solid #e67e22;" if matched else "border:none;")
            )

    # ------------------------------------------------------------------
    #                    new‑word‑book dialog
    # ------------------------------------------------------------------
    def show_new_wordbook_dialog(self) -> bool:
        # 关键修改：把导入放进函数体里，彻底断开 cover ↔ service 的循环引用
        from UI.new_wordbook_dialog import NewWordBookDialog  # ★ 改动
        dlg = NewWordBookDialog()
        return dlg.exec() == dlg.Accepted

    # ------------------------------------------------------------------
    #                    layout persistence helpers
    # ------------------------------------------------------------------
    def export_layout(self, buttons: list[WordBookButton]):
        items = []
        for btn in buttons:
            if getattr(btn, "is_folder", False):
                items.append(
                    {
                        "type": "folder",
                        "name": btn.text(),
                        "color": getattr(btn, "color", "#a3d2ca"),
                        "is_expanded": getattr(btn, "is_expanded", False),
                        "sub_books": [sub.text() for sub in btn.sub_buttons],
                    }
                )
            else:
                items.append(
                    {
                        "type": "wordbook",
                        "name": btn.text(),
                        "color": getattr(btn, "color", "#a3d2ca"),
                    }
                )
        return items

    def apply_layout(self, layout_items, buttons: list[WordBookButton]) -> None:
        """Re‑create button order & folder hierarchy based on the JSON artefact
        previously produced by :py:meth:`export_layout`."""
        if not self.content:
            return

        # 1. current button index lookup
        name_to_btn = {btn.text(): btn for btn in buttons}
        new_buttons: list[WordBookButton] = []
        used_names: set[str] = set()

        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        books_dir = os.path.join(base_dir, "books")

        for item in layout_items:
            if item.get("type") == "wordbook":
                btn = name_to_btn.get(item["name"])
                if btn:
                    new_buttons.append(btn)
                    used_names.add(btn.text())

            elif item.get("type") == "folder":
                folder_btn = WordBookButton(
                    item["name"],
                    item.get("color", "#a3d2ca"),
                    parent=self.content,
                    app=self.content,
                )
                folder_btn.is_folder = True
                folder_btn.is_expanded = False
                folder_btn.sub_buttons = []

                for sub_name in item.get("sub_books", []):
                    src_btn = name_to_btn.get(sub_name)
                    if not src_btn:
                        continue

                    sub_btn = WordBookButton(
                        src_btn.text(),
                        getattr(src_btn, "color", "#a3d2ca"),
                        parent=self.content,
                        app=self.content,
                    )
                    sub_btn.is_sub_button = True
                    sub_btn.parent_folder = folder_btn
                    sub_btn.hide()  # collapsed by default
                    folder_btn.sub_buttons.append(sub_btn)

                    # bind click → open inside window
                    book_dir = f"books_{sub_btn.text()}_{sub_btn.color}"
                    book_path = os.path.join(books_dir, book_dir)
                    sub_btn.clicked.connect(
                        lambda _, p=book_path: self.content.show_word_book(p)
                    )

                    # remove original main‑button reference
                    src_btn.setParent(None)
                    src_btn.deleteLater()
                    name_to_btn.pop(sub_name, None)
                    used_names.add(sub_name)

                folder_btn.update_folder_icon()
                new_buttons.append(folder_btn)

        # 4. append any buttons that were not covered by the JSON
        for name, btn in name_to_btn.items():
            if name not in used_names:
                new_buttons.append(btn)

        # 5. write back and refresh layout
        buttons.clear()
        buttons.extend(new_buttons)
        self.content.buttons = buttons
        self.content.update_button_positions()
        update_all_folder_backgrounds(
            self.content, self.content.button_width, self.content.button_height
        )

services/folder_service.py结束

services/memory_service.py开始
# services/memory_service.py
"""
背单词 / 记忆曲线业务层。供 memory_curve.py 及未来其它 UI 使用。
"""
import pandas as pd
from datetime import datetime, timedelta

from repositories.memory_repository import MemoryRepository

# 复习间隔（与 db_memory 保持一致，集中管理更方便）
DEFAULT_INTERVALS = [0, 1, 2, 4, 7, 15, 30]


class MemoryService:
    # ---------- DataFrame 存取 ----------
    @staticmethod
    def load_memory_df(book: str, color: str) -> pd.DataFrame:
        return MemoryRepository.load_memory_df(book, color)

    @staticmethod
    def save_memory_df(book: str, color: str, df: pd.DataFrame) -> None:
        MemoryRepository.save_memory_df(book, color, df)

    # ---------- 今日待复习列表 ----------
    @staticmethod
    def get_review_words(book: str, color: str) -> list[dict]:
        return MemoryRepository.get_today_review_words(book, color)

    # ---------- 更新单词结果 ----------
    @staticmethod
    def record_answer(
        book: str, color: str, word: str, is_correct: bool, *,
        intervals: list[int] = DEFAULT_INTERVALS,
    ) -> None:
        """
        更新答题结果，并根据是否正确推算下一次复习时间（在 repo 内完成）。
        """
        MemoryRepository.update_word_status(book, color, word, is_correct)

services/memory_service.py结束

services/tag_service.py开始
# services/tag_service.py
"""
面向 UI 的标签业务层。
"""
from repositories.tag_repository import TagRepository

_MAIN_BOOK = "总单词册"
_MAIN_COLOR = "#FF0000"


class TagService:
    # ---------- 查询 ----------
    @staticmethod
    def list_tags(book: str, color: str) -> list[str]:
        return TagRepository.list_tags(book, color)

    # ---------- 新增 ----------
    @staticmethod
    def add_tag(book: str, color: str, tag: str) -> None:
        """向当前册添加标签，并确保同步到『总单词册』"""
        TagRepository.add_tag(book, color, tag)
        if book != _MAIN_BOOK:
            TagRepository.add_tag(_MAIN_BOOK, _MAIN_COLOR, tag)

services/tag_service.py结束

services/wordbook_service.py开始
"""services/wordbook_service.py
-------------------------------------------------
High‑level business logic façade used by every UI layer.
UI components must talk to this class instead of accessing repositories or
`db.py` directly.  The service orchestrates repositories, applies validation
or additional business rules (if any) and offers a *stable* API.
"""
from __future__ import annotations

from typing import Any, Dict, List

from repositories.word_repository import WordRepository


class WordBookService:
    """Business methods for word‑book CRUD operations."""

    # ------------------------------------------------------------------
    # READ
    # ------------------------------------------------------------------
    @staticmethod
    def list_words(book_name: str, book_color: str) -> List[Dict[str, Any]]:
        """Return all words from the specified book.

        Thin wrapper for :py:meth:`repositories.word_repository.WordRepository.list_words`.
        UI should always call this instead of repositories directly so that
        later we can introduce caching, filtering or async loading without
        touching UI code.
        """
        return WordRepository.list_words(book_name, book_color)

    # ------------------------------------------------------------------
    # CREATE / UPDATE (Up‑sert)
    # ------------------------------------------------------------------
    @staticmethod
    def save_word(
        book_name: str,
        book_color: str,
        data: Dict[str, Any],
        *,
        sync_to_total: bool = True,
    ) -> None:
        """Insert or update a word.

        Currently just delegates to the repository.  Validation hooks can be
        added here later (e.g. ensure the word field is not empty, strip
        whitespace, etc.).
        """
        WordRepository.save_word(
            book_name,
            book_color,
            data,
            sync_to_total=sync_to_total,
        )

    # ------------------------------------------------------------------
    # DELETE
    # ------------------------------------------------------------------
    @staticmethod
    def delete_word(book_name: str, book_color: str, word: str) -> None:
        """Delete a word from the specified book."""
        WordRepository.delete_word(book_name, book_color, word)

services/wordbook_service.py结束

styles.py开始
#styles.py
# 主题颜色
PRIMARY_COLOR = "#4CAF50"  # 绿色，可以修改
PRIMARY_COLOR_LIGHT = "#81c784"
SECONDARY_COLOR = "#2196F3" #蓝色，可以修改
SECONDARY_COLOR_LIGHT = "#64b5f6"

# 文字颜色
TEXT_COLOR = "#212121"
GRAY_COLOR = "#757575"
WHITE_COLOR = "#FFFFFF"

# 按钮样式
PRIMARY_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: {PRIMARY_COLOR};
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: {PRIMARY_COLOR_LIGHT};
    }}
    QPushButton:pressed {{
        background-color: {PRIMARY_COLOR};
    }}
"""

SECONDARY_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: {SECONDARY_COLOR};
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: {SECONDARY_COLOR_LIGHT};
    }}
    QPushButton:pressed {{
        background-color: {SECONDARY_COLOR};
    }}
"""

TEXT_EDIT_STYLE = """
    QTextEdit {
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5;
        padding: 4px;
        font-size: 23px;
    }
    QTextEdit:focus {
        border: 1px solid #444;
    }
"""

LINE_EDIT_STYLE = """
    QLineEdit {
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5;
        padding: 4px;
        font-size: 23px;
    }
    QLineEdit:focus {
        border: 1px solid #444;
    }
"""
SCROLL_AREA_STYLE = """
    QScrollArea {
        border: none;
    }
    QScrollArea > QWidget > QWidget {
        background-color: #f0f0f0;
    }
"""
TAG_COMBOBOX_STYLE = """
    QComboBox {
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: white;
        padding: 4px;
        font-size: 14px;
    }
    QComboBox:focus {
        border: 1px solid #444;
    }
"""
TAG_LABEL_STYLE = """
    QLabel {
        background-color: #e0e0e0;
        border-radius: 8px;
        padding: 3px 8px;
        margin-right:5px;
        margin-bottom:5px;

    }
"""

GREEN_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: {PRIMARY_COLOR};
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: {PRIMARY_COLOR_LIGHT};
    }}
    QPushButton:pressed {{
        background-color: {PRIMARY_COLOR};
    }}
"""

RED_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: #FF4D4D;
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: #FF8080;
    }}
    QPushButton:pressed {{
        background-color: #FF4D4D;
    }}
"""

GRAY_INPUT_STYLE = """
    QLineEdit {
        border: 2px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5; /* 稍微置灰的背景 */
        padding: 4px;
        font-size: 23px;
        min-height: 30px;
    }
    QLineEdit:focus {
        border: 2px solid #444;
    }
"""

GRAY_TEXT_EDIT_STYLE = """
    QTextEdit {
        border: 2px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5; /* 稍微置灰的背景 */
        padding: 4px;
        font-size: 23px;
        min-height: 30px;
    }
     QTextEdit:focus {
        border: 2px solid #444;
    }
"""

# 备注部分的样式
NOTE_TEXT_EDIT_STYLE = """
    QTextEdit {
        background-color: #e5e5e5;  /* 浅灰背景 */
        border: 1px solid #ddd;     /* 浅灰边框 */
        border-radius: 4px;         /* 圆角 */
        padding: 5px;               /* 内边距 */
        font-size: 26px;            /* 字体大小 */
        color: #333;                /* 深灰文字 */
    }
"""
styles.py结束

utils.py开始
#_utils.py
import os
import sys
print("开始加载pandas")
import pandas as pd

def get_word_book_path(book_name, color):
    """
    Get the path to the word book folder.

    Args:
        book_name (str): The name of the word book.
        color (str): The color of the word book.

    Returns:
        str: The path to the word book folder.
    """
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    directory = os.path.join(base_dir, "books")
    os.makedirs(directory, exist_ok=True)
    folder_name = f"books_{book_name}_{color}"
    path = os.path.join(directory, folder_name)
    return path


def get_tags_path(book_name, color):
    """
    Get the path to the tags.txt file.

    Args:
        book_name (str): The name of the word book.
        color (str): The color of the word book.

    Returns:
        str: The path to the tags.txt file.
    """
    path = get_word_book_path(book_name, color)
    return os.path.join(path, "tags.txt")

def get_excel_path(book_name, color):
    """
    Get the path to the words.xlsx file.

    Args:
        book_name (str): The name of the word book.
        color (str): The color of the word book.

    Returns:
        str: The path to the words.xlsx file.
    """
    path = get_word_book_path(book_name, color)
    return os.path.join(path, "words.xlsx")


def get_total_tags_path():
    """Get the path to the total word book's tags.txt file."""
    return get_tags_path("总单词册", "#FF0000")

def get_total_excel_path():
    """Get the path to the total word book's words.xlsx file."""
    return get_excel_path("总单词册", "#FF0000")

def clean_data(data):
    """Clean data to avoid writing NaN, None, and empty lists to Excel."""
    for key in data:
      if isinstance(data[key], list):
        # If the list is empty, it should be [] and not be converted to string
        if not data[key]:
            continue  # keep list as is
      elif pd.isna(data[key]) or (isinstance(data[key], str) and data[key].lower() == 'nan'):
            # Replace NaN values or "nan" string with an empty string
            data[key] = ""
    return data

# 此函数已被移除，数据合并逻辑已在db.py的save_word_to_total函数中实现

def get_all_word_books(exclude_main=True):
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    directory = os.path.join(base_dir, "books")
    word_books = []
    for folder in os.listdir(directory):
        if folder.startswith("books_"):
            if exclude_main and folder == "books_总单词册_#FF0000":
                continue
            word_books.append(os.path.join(directory, folder))
    return word_books

def get_note_text(self, word):
    if self.book_name == "总单词册":
        from utils import get_all_word_books
        import sqlite3
        import os
        all_word_books = get_all_word_books(exclude_main=True)
        notes_with_sources = []
        for wb_path in all_word_books:
            wb_name = os.path.basename(wb_path).split('_')[1]
            db_path = os.path.join(wb_path, "wordbook.db")
            if os.path.exists(db_path):
                try:
                    conn = sqlite3.connect(db_path)
                    cursor = conn.cursor()
                    word_str = str(word["单词"]).strip()
                    cursor.execute("SELECT note FROM words WHERE word = ?", (word_str,))
                    result = cursor.fetchone()
                    if result and result[0]:
                        note_str = result[0]
                        if note_str.strip():
                            notes_with_sources.append(f"来自 {wb_name}: {note_str}")
                    conn.close()
                except Exception as e:
                    print(f"Error getting note from {wb_name}: {e}")
        return "\n\n".join(notes_with_sources) if notes_with_sources else "无备注"
    else:
        note = word.get('备注', '无备注')
        return str(note) if note else "无备注"

utils.py结束

