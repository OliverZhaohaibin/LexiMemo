UI/__init__.py开始
from UI.word_book_inside.word_book_window import WordBookWindow
from UI.word_book_inside.word_detail_panel import WordDetailPanel
from UI.word_book_inside.word_edit_panel import WordEditPanel
from UI.word_book_inside.word_list_panel import WordListPanel

__all__ = [
    "WordBookWindow",
    "WordListPanel",
    "WordDetailPanel",
    "WordEditPanel",
]

UI/__init__.py结束

UI/element/MultiSelectComboBox.py开始
# MultiSelectComboBox.py
from PySide6.QtGui import QStandardItemModel, QStandardItem
from PySide6.QtWidgets import QComboBox
from PySide6.QtCore import Qt
from db import get_all_tags


class MultiSelectComboBox(QComboBox):
    def __init__(self, parent=None, book_name="总单词册", book_color="#FF0000"):
        super(MultiSelectComboBox, self).__init__(parent)
        self.book_name = book_name
        self.book_color = book_color
        self.setModel(QStandardItemModel(self))
        self.add_all_tags_item()
        self.all_tags_item_changed = False
        self.model().itemChanged.connect(self.handle_item_changed)

    def add_all_tags_item(self):
        self.all_tags_item = QStandardItem("全部标签")
        self.all_tags_item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
        self.all_tags_item.setData(Qt.Unchecked, Qt.CheckStateRole)
        self.model().appendRow(self.all_tags_item)

    def addItem(self, text, checked=False):
        if text == "全部标签":
            return
        item = QStandardItem(text)
        item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
        item.setData(Qt.Checked if checked else Qt.Unchecked, Qt.CheckStateRole)
        self.model().appendRow(item)

    def selectedItems(self):
        selected = []
        for index in range(1, self.model().rowCount()):  # Skip "全部标签" at index 0
            item = self.model().item(index)
            if item.checkState() == Qt.Checked:
                selected.append(item.text())
        return selected

    def clear(self):
        self.model().clear()
        self.add_all_tags_item()

    def allItems(self):
        return get_all_tags(self.book_name, self.book_color)

    def handle_item_changed(self, item):
        if self.all_tags_item_changed:
            return
        self.all_tags_item_changed = True
        try:
            if item == self.all_tags_item:
                state = item.checkState()
                for i in range(1, self.model().rowCount()):
                    self.model().item(i).setCheckState(state)
            elif item != self.all_tags_item:
                if item.checkState() == Qt.Unchecked and self.all_tags_item.checkState() == Qt.Checked:
                    self.all_tags_item.setCheckState(Qt.Unchecked)
                elif all(self.model().item(i).checkState() == Qt.Checked for i in range(1, self.model().rowCount())):
                    self.all_tags_item.setCheckState(Qt.Checked)
        finally:
            self.all_tags_item_changed = False
UI/element/MultiSelectComboBox.py结束

UI/element/__init__.py开始

UI/element/__init__.py结束

UI/folder_ui/_animations.py开始
# UI/folder_ui/_animations.py开始
from PySide6.QtCore import QPropertyAnimation, QParallelAnimationGroup, QEasingCurve, QPoint, QRect, QTimer
from PySide6.QtWidgets import QGraphicsOpacityEffect
from typing import Dict, List  # Import Dict and List

# Import necessary components from sibling _modules
from ._background import FolderBackground  # update_folder_background is called by update_button_positions


def create_folder_toggle_animation(folder_button, target_positions: List[QPoint], button_width, button_height,
                                   spacing):
    """
    创建文件夹展开/关闭的动画

    Args:
        folder_button: 文件夹按钮 (WordBookButton instance)
        target_positions: 子按钮目标位置列表 (for expansion)
        button_width: 按钮宽度
        button_height: 按钮高度
        spacing: 间距

    Returns:
        动画组
    """
    master_anim_group = QParallelAnimationGroup()

    # folder_button.is_expanded has been set to the *target* state before calling this
    is_expanding = folder_button.is_expanded
    duration_base = 450 if is_expanding else 250
    duration_increment = 100 if is_expanding else 40

    for index, sub_btn in enumerate(folder_button.sub_buttons):
        if is_expanding:
            sub_btn.show()  # Must be visible for animation
            sub_btn.setWindowOpacity(0)  # Start transparent for fade-in
            start_pos = folder_button.pos()
            end_pos = target_positions[index] if index < len(target_positions) else folder_button.pos()
        else:  # Collapsing
            start_pos = sub_btn.pos()
            end_pos = folder_button.pos()

        pos_anim = QPropertyAnimation(sub_btn, b"pos")
        pos_anim.setDuration(duration_base + index * duration_increment)
        pos_anim.setStartValue(start_pos)
        pos_anim.setEndValue(end_pos)
        pos_anim.setEasingCurve(QEasingCurve.OutBack if is_expanding else QEasingCurve.InBack)
        master_anim_group.addAnimation(pos_anim)

        opacity_anim = QPropertyAnimation(sub_btn, b"windowOpacity")
        opacity_anim.setDuration(duration_base - 50 if duration_base > 50 else duration_base)
        opacity_anim.setStartValue(0 if is_expanding else 1)
        opacity_anim.setEndValue(1 if is_expanding else 0)
        opacity_anim.setEasingCurve(QEasingCurve.InOutQuad)
        master_anim_group.addAnimation(opacity_anim)

    # folder_button.app is CoverContent which has _post_folder_animation from FolderAnimationMixin
    if hasattr(folder_button, 'app') and folder_button.app and hasattr(folder_button.app, '_post_folder_animation'):
        master_anim_group.finished.connect(
            lambda: folder_button.app._post_folder_animation(folder_button)
        )
    elif hasattr(folder_button, 'app') and folder_button.app and hasattr(folder_button.app, 'update_button_positions'):
        # Fallback if _post_folder_animation is not directly on app (should not happen with current structure)
        master_anim_group.finished.connect(
            folder_button.app.update_button_positions
        )

    return master_anim_group


def create_button_position_animation(button, target_pos, duration=200, easing_curve=QEasingCurve.OutBack):
    """
    创建按钮位置动画
    """
    animation = QPropertyAnimation(button, b"pos")
    animation.setDuration(duration)
    animation.setStartValue(button.pos())
    animation.setEndValue(target_pos)
    animation.setEasingCurve(easing_curve)
    return animation


class FolderAnimationMixin:
    """混入类：提供文件夹展开 / 折叠相关全部动画 & 批量折叠/恢复能力。
       Assumes self is CoverContent.
    """

    def toggle_folder(self, folder_button):
        """切换单个文件夹的展开 / 折叠状态（含动画）。"""
        if not hasattr(folder_button, "is_folder") or not folder_button.is_folder:
            return

        current_anim_group = getattr(folder_button, "folder_animation_group", None)
        if current_anim_group and current_anim_group.state() == QParallelAnimationGroup.Running:
            return

        # Determine target state and set it on the button
        target_is_expanding = not folder_button.is_expanded
        folder_button.is_expanded = target_is_expanding

        self._ensure_background_frames(folder_button)  # Ensure frame exists, show/hide handled by animation

        if target_is_expanding:
            for sub in folder_button.sub_buttons:
                sub.show()
                sub.setWindowOpacity(0)

        # Calculate final positions for ALL buttons based on the NEW state of the toggled folder
        final_pos_map, new_book_target_pos = self._calculate_final_positions(folder_button, target_is_expanding)

        sub_targets_for_current_folder = [final_pos_map[s] for s in folder_button.sub_buttons if s in final_pos_map]

        folder_toggle_anim = create_folder_toggle_animation(
            folder_button, sub_targets_for_current_folder,
            self.button_width, self.button_height, self.spacing
        )

        bg_geom_anim, bg_opacity_anim = self._build_background_anims(
            folder_button, sub_targets_for_current_folder, target_is_expanding
        )

        move_other_items_group = self._build_move_group(folder_button, final_pos_map, new_book_target_pos)
        other_folders_bg_anim_group = self._build_other_bg_group(folder_button, final_pos_map)

        master_animation_group = QParallelAnimationGroup()
        master_animation_group.addAnimation(folder_toggle_anim)
        master_animation_group.addAnimation(bg_geom_anim)
        master_animation_group.addAnimation(bg_opacity_anim)
        master_animation_group.addAnimation(move_other_items_group)
        master_animation_group.addAnimation(other_folders_bg_anim_group)

        # _post_folder_animation is connected by create_folder_toggle_animation's finished signal
        folder_button.folder_animation_group = master_animation_group
        master_animation_group.start()

    def collapse_all_folders(self):
        """批量折叠界面上 *所有* 已展开文件夹（并记录状态）。"""
        if not hasattr(self, 'buttons'): return

        self.folder_expanded_states: Dict = {}
        self.all_folders_collapsed = True  # Mark that a "collapse all" operation was performed

        any_folder_animated = False
        for btn in self.buttons:  # self.buttons is from CoverContent
            if hasattr(btn, 'is_folder') and btn.is_folder and \
                    hasattr(btn, 'is_expanded') and btn.is_expanded:

                self.folder_expanded_states[btn] = True  # Record it was expanded

                current_anim_group = getattr(btn, "folder_animation_group", None)
                if not current_anim_group or current_anim_group.state() != QParallelAnimationGroup.Running:
                    btn.is_expanded = False  # CRITICAL: Set state BEFORE creating animation

                    anim = create_folder_toggle_animation(
                        btn, [], self.button_width, self.button_height, self.spacing
                    )
                    btn.folder_animation_group = anim
                    anim.start()
                    any_folder_animated = True

        if not any_folder_animated and hasattr(self, 'update_button_positions'):
            # If no folders were actually collapsed (e.g., all were already closed),
            # still trigger a layout update to ensure consistency, especially if exiting edit mode.
            QTimer.singleShot(0, self.update_button_positions)

    def expand_all_folders(self):
        """恢复上一次 `collapse_all_folders` 保存的展开状态。"""
        if not hasattr(self, 'buttons'): return

        # Only proceed if a "collapse all" op was done and states were saved & not empty
        if not getattr(self, "all_folders_collapsed", False) or \
                not hasattr(self, "folder_expanded_states") or \
                not self.folder_expanded_states:
            if hasattr(self, 'update_button_positions'):
                QTimer.singleShot(0, self.update_button_positions)  # Ensure layout is current
            return

        any_folder_animated = False
        for btn_from_state, was_expanded in self.folder_expanded_states.items():
            # Check if button still exists in the current list of buttons on CoverContent
            if btn_from_state not in self.buttons:
                continue

            # Ensure we are targeting a folder that was marked as expanded and is currently not
            if was_expanded and hasattr(btn_from_state, 'is_folder') and btn_from_state.is_folder and \
                    hasattr(btn_from_state, 'is_expanded') and not btn_from_state.is_expanded:

                current_anim_group = getattr(btn_from_state, "folder_animation_group", None)
                if not current_anim_group or current_anim_group.state() != QParallelAnimationGroup.Running:
                    btn_from_state.is_expanded = True  # Set target state to expanding

                    for sub in btn_from_state.sub_buttons:
                        sub.show()
                        sub.setWindowOpacity(0)

                    # Calculate target positions for sub-buttons for this specific folder's expansion
                    final_pos_map, _ = self._calculate_final_positions(btn_from_state,
                                                                       True)  # True for is_expanding_current_folder
                    target_positions_for_subs = [final_pos_map[s] for s in btn_from_state.sub_buttons if
                                                 s in final_pos_map]

                    anim = create_folder_toggle_animation(
                        btn_from_state, target_positions_for_subs,
                        self.button_width, self.button_height, self.spacing
                    )
                    btn_from_state.folder_animation_group = anim
                    anim.start()
                    any_folder_animated = True

        self.folder_expanded_states.clear()  # Clear states after attempting expansion
        self.all_folders_collapsed = False

        # A final layout update after a delay to ensure all animations settle.
        # Individual animations also call _post_folder_animation -> update_button_positions.
        if hasattr(self, 'update_button_positions'):
            # Delay slightly more than the longest potential animation (duration_base + N*duration_increment for sub_buttons)
            # Max sub_buttons is 9. Longest collapse is 250 + 8*40 = 570. Longest expand 450 + 8*100 = 1250.
            # A generic delay for safety.
            QTimer.singleShot(600, self.update_button_positions)

    def _ensure_background_frames(self, folder_button):
        """Ensures the folder_button being toggled (and other already expanded ones)
           have a background frame widget ready. Visibility is handled by animations.
        """
        buttons_needing_frames = []
        if hasattr(self, 'buttons'):
            for btn in self.buttons:
                if hasattr(btn, 'is_folder') and btn.is_folder:
                    # If it's the button being toggled OR it's another folder that is already expanded
                    if btn is folder_button or (hasattr(btn, 'is_expanded') and btn.is_expanded):
                        buttons_needing_frames.append(btn)

        if not buttons_needing_frames and (hasattr(folder_button, 'is_folder') and folder_button.is_folder):
            buttons_needing_frames.append(folder_button)

        for btn_with_frame in buttons_needing_frames:
            if not hasattr(btn_with_frame, "background_frame") or btn_with_frame.background_frame is None:
                btn_with_frame.background_frame = FolderBackground(self.scroll_content)  # self is CoverContent
                eff = QGraphicsOpacityEffect(btn_with_frame.background_frame)
                # Opacity is set by animation, but default to 1 if not animated.
                eff.setOpacity(1.0)
                btn_with_frame.background_frame.setGraphicsEffect(eff)

            # Ensure it's visible and under other elements initially if it's being animated to show
            # Or just ensure it's there for animation. Visibility is managed by animation logic mostly.
            btn_with_frame.background_frame.lower()
            # Don't show() here; let animation control visibility. If it's expanding, opacity starts at 0.
            # If it's collapsing, it's already visible.

    def _calculate_final_positions(self, folder_button_being_toggled, is_expanding_current_folder):
        # self refers to CoverContent
        bw, bh, sp = self.button_width, self.button_height, self.spacing
        avail_w = self.scroll_content.width() or self.scroll_area.viewport().width()
        x, y = sp, sp + (getattr(self, "top_margin", 40) or 40)
        final_pos: Dict['WordBookButton', QPoint] = {}  # Use actual button type if available

        buttons_for_layout = []
        if hasattr(self, 'buttons'):
            buttons_for_layout = self.buttons

        buttons_per_row = max(1, (avail_w - sp) // (bw + sp))
        main_button_idx = 0

        for btn in buttons_for_layout:
            if getattr(btn, "is_dragging", False): continue  # Skip dragging button for calculation

            if main_button_idx > 0 and main_button_idx % buttons_per_row == 0:
                y += bh + sp
                x = sp
            final_pos[btn] = QPoint(x, y)

            # Determine if this folder (btn) will be expanded in the final layout
            is_this_folder_expanded_in_final_state = False
            if hasattr(btn, 'is_folder') and btn.is_folder:
                if btn is folder_button_being_toggled:
                    is_this_folder_expanded_in_final_state = is_expanding_current_folder
                elif hasattr(btn, 'is_expanded') and btn.is_expanded:  # Another folder that remains expanded
                    is_this_folder_expanded_in_final_state = True

            if is_this_folder_expanded_in_final_state:
                y += bh + sp  # Space for folder button itself, sub-buttons start below
                sub_x = sp  # Sub-buttons start from the left, using normal spacing for first item

                fsp = sp * 1.5  # Folder internal spacing for subsequent items in a row
                # Sub-buttons per row calculation should consider the specific layout for sub-buttons
                sub_buttons_per_row = max(1, int((avail_w - sp - (sp - fsp)) // (
                            bw + fsp)))  # Adjusted for potentially tighter packing

                for idx, sub_btn in enumerate(btn.sub_buttons):
                    if getattr(sub_btn, "is_dragging", False): continue

                    if idx > 0 and idx % sub_buttons_per_row == 0:
                        y += bh + fsp  # Move to next row for sub-buttons
                        sub_x = sp

                    final_pos[sub_btn] = QPoint(sub_x, y)
                    sub_x += (bw + fsp)

                if btn.sub_buttons:  # If there were sub-buttons, add space after them
                    y += bh + sp  # Use normal spacing after the block of sub-buttons
                x = sp  # Next main button starts from left
                main_button_idx = -1  # Reset column counter for main buttons
            else:  # Normal button or collapsed folder
                x += bw + sp

            main_button_idx += 1

        new_book_target = QPoint(0, 0)  # Default
        if hasattr(self, 'new_book_button'):
            if main_button_idx > 0 and main_button_idx % buttons_per_row == 0:
                y += bh + sp
                x = sp
            elif not buttons_for_layout:  # No main buttons, new_book_button is first
                x = sp
                y = sp + (getattr(self, "top_margin", 40) or 40)

            new_book_target = QPoint(x, y)

        return final_pos, new_book_target

    def _sub_targets(self, folder_button):  # Used by expand_all_folders
        # True because we are calculating for an expansion scenario
        final_pos_map, _ = self._calculate_final_positions(folder_button, True)
        return [final_pos_map[s] for s in folder_button.sub_buttons if s in final_pos_map]

    def _build_background_anims(self, folder_button, sub_targets, is_expanding):
        bw, bh, sp = self.button_width, self.button_height, self.spacing

        def calc_rect_for_bg(parent_folder_pos_in_final_layout, sub_button_final_positions):
            if not sub_button_final_positions:  # No sub-buttons, rect is around folder button
                return QRect(parent_folder_pos_in_final_layout.x() - sp // 2,
                             parent_folder_pos_in_final_layout.y() - sp // 2,
                             bw + sp, bh + sp)

            min_x = min((p.x() for p in sub_button_final_positions))
            min_y = min((p.y() for p in sub_button_final_positions))
            max_x = max((p.x() for p in sub_button_final_positions)) + bw
            max_y = max((p.y() for p in sub_button_final_positions)) + bh
            margin = sp // 2  # Standard margin for background
            return QRect(min_x - margin, min_y - margin, max_x - min_x + 2 * margin, max_y - min_y + 2 * margin)

        bg_frame = folder_button.background_frame
        bg_eff = bg_frame.graphicsEffect()  # type: QGraphicsOpacityEffect

        # Final position of the folder button itself from the calculated map
        folder_final_pos = self._calculate_final_positions(folder_button, is_expanding)[0].get(folder_button,
                                                                                               folder_button.pos())

        if is_expanding:
            # Start geom from folder's current position, end at rect around sub-targets
            # Opacity from 0 to 1
            bg_start_geom = QRect(folder_button.pos(), folder_button.size())  # Or folder_final_pos if it moved
            bg_end_geom = calc_rect_for_bg(folder_final_pos, sub_targets)

            bg_frame.setGeometry(bg_start_geom)  # Set initial geometry for expansion animation
            bg_frame.show()  # Make sure it's visible to animate opacity
            bg_eff.setOpacity(0.0)
        else:  # Collapsing
            # Start geom from current frame geom, end at folder's final position
            # Opacity from 1 to 0
            bg_start_geom = bg_frame.geometry()
            bg_end_geom = QRect(folder_final_pos, folder_button.size())
            # Opacity is already 1.0 if it was visible

        geom_anim = QPropertyAnimation(bg_frame, b"geometry")
        geom_anim.setDuration(450)
        geom_anim.setEasingCurve(QEasingCurve.OutBack if is_expanding else QEasingCurve.InBack)
        geom_anim.setStartValue(bg_start_geom)
        geom_anim.setEndValue(bg_end_geom)

        opac_anim = QPropertyAnimation(bg_eff, b"opacity")
        opac_anim.setDuration(350)
        opac_anim.setEasingCurve(QEasingCurve.InOutQuad)
        if is_expanding:
            opac_anim.setStartValue(0.0)
            opac_anim.setEndValue(1.0)
        else:  # Collapsing
            opac_anim.setStartValue(bg_eff.opacity())  # Current opacity
            opac_anim.setEndValue(0.0)
            # Hide frame and reset opacity after collapse animation
            opac_anim.finished.connect(lambda: (
                bg_frame.hide(),
                bg_eff.setOpacity(1.0)  # Reset for next time
            ))
        return geom_anim, opac_anim

    def _build_move_group(self, folder_button_being_toggled, final_pos_map, new_book_target_pos):
        # self refers to CoverContent
        group = QParallelAnimationGroup()

        for btn, target_pos_for_btn in final_pos_map.items():
            is_sub_of_current_toggled_folder = btn in folder_button_being_toggled.sub_buttons
            is_current_toggled_folder_itself = btn is folder_button_being_toggled

            if not is_sub_of_current_toggled_folder and \
                    not is_current_toggled_folder_itself and \
                    not getattr(btn, "is_dragging", False):
                if btn.pos() != target_pos_for_btn:
                    group.addAnimation(
                        create_button_position_animation(btn, target_pos_for_btn, 450)
                    )

        if hasattr(self, 'new_book_button') and self.new_book_button.pos() != new_book_target_pos:
            group.addAnimation(
                create_button_position_animation(self.new_book_button, new_book_target_pos, 450)
            )
        return group

    def _build_other_bg_group(self, folder_button_being_toggled, final_pos_map):
        # self refers to CoverContent
        group = QParallelAnimationGroup()
        bw, bh, sp = self.button_width, self.button_height, self.spacing

        def calc_rect_for_other_bg(parent_folder_final_pos, sub_button_final_positions):
            # Same logic as in _build_background_anims's calc_rect_for_bg
            if not sub_button_final_positions:
                return QRect(parent_folder_final_pos.x() - sp // 2, parent_folder_final_pos.y() - sp // 2, bw + sp,
                             bh + sp)
            min_x = min((p.x() for p in sub_button_final_positions))
            min_y = min((p.y() for p in sub_button_final_positions))
            max_x = max((p.x() for p in sub_button_final_positions)) + bw
            max_y = max((p.y() for p in sub_button_final_positions)) + bh
            margin = sp // 2
            return QRect(min_x - margin, min_y - margin, max_x - min_x + 2 * margin, max_y - min_y + 2 * margin)

        for btn in self.buttons:  # self.buttons from CoverContent
            if hasattr(btn, 'is_folder') and btn.is_folder and \
                    hasattr(btn, 'is_expanded') and btn.is_expanded and \
                    btn is not folder_button_being_toggled:  # Only for *other* expanded folders

                if hasattr(btn, "background_frame") and btn.background_frame is not None:
                    # Get final positions for this "other" folder and its sub-buttons
                    other_folder_final_pos = final_pos_map.get(btn, btn.pos())
                    other_folder_sub_button_final_pos = [final_pos_map[s] for s in btn.sub_buttons if
                                                         s in final_pos_map]

                    target_bg_rect = calc_rect_for_other_bg(other_folder_final_pos, other_folder_sub_button_final_pos)

                    if target_bg_rect != btn.background_frame.geometry() and not target_bg_rect.isEmpty():
                        anim = QPropertyAnimation(btn.background_frame, b"geometry")
                        anim.setDuration(450)
                        anim.setEasingCurve(QEasingCurve.OutBack)  # Consistent easing
                        anim.setStartValue(btn.background_frame.geometry())
                        anim.setEndValue(target_bg_rect)
                        group.addAnimation(anim)
        return group

    def _post_folder_animation(self, folder_button):
        """动画结束后的统一收尾。"""
        # print(f"_post_folder_animation for {folder_button.text()}, is_expanded: {folder_button.is_expanded}") # DEBUG
        if not folder_button.is_expanded:  # Collapsed
            for sub_btn in folder_button.sub_buttons:
                sub_btn.hide()
                sub_btn.setWindowOpacity(1.0)  # Reset opacity for next potential show

            if hasattr(folder_button, 'background_frame') and folder_button.background_frame:
                folder_button.background_frame.hide()
                if folder_button.background_frame.graphicsEffect():
                    folder_button.background_frame.graphicsEffect().setOpacity(1.0)  # Reset effect
        else:  # Expanded
            for sub_btn in folder_button.sub_buttons:
                sub_btn.setWindowOpacity(1.0)  # Ensure fully opaque after expansion
            if hasattr(folder_button, 'background_frame') and folder_button.background_frame:
                if folder_button.background_frame.graphicsEffect():
                    folder_button.background_frame.graphicsEffect().setOpacity(1.0)

        # Crucial: update positions for all buttons, which also updates backgrounds
        if hasattr(self, 'update_button_positions'):
            self.update_button_positions()


__all__ = [
    "FolderAnimationMixin",
    "create_folder_toggle_animation",
    "create_button_position_animation",
]
# UI/folder_ui/_animations.py结束
UI/folder_ui/_animations.py结束

UI/folder_ui/_background.py开始
from PySide6.QtCore import QRect, QPropertyAnimation, QEasingCurve, QAbstractAnimation
from PySide6.QtWidgets import QFrame, QGraphicsOpacityEffect


class FolderBackground(QFrame):
    """文件夹子按钮背景框类"""
    def __init__(self, parent):
        super().__init__(parent)
        self.setStyleSheet("background-color: rgba(240, 240, 240, 0.5); border: 2px dashed #888888;")
        self.setFrameShape(QFrame.Box)
        self.lower()  # 确保背景框在按钮下方
        self.hide()

def calculate_folder_background_rect(folder_button, sub_buttons, button_width, button_height, spacing):
    """计算文件夹背景框的矩形区域"""
    if not folder_button.is_expanded or not sub_buttons:
        return None
    
    # 计算包含所有子按钮的矩形区域
    visible_sub_buttons = [btn for btn in sub_buttons if btn.isVisible()]
    if not visible_sub_buttons:
        return None
        
    min_x = min([btn.x() for btn in visible_sub_buttons])
    min_y = min([btn.y() for btn in visible_sub_buttons])
    max_x = max([btn.x() + button_width for btn in visible_sub_buttons])
    max_y = max([btn.y() + button_height for btn in visible_sub_buttons])
    
    # 添加边距
    margin = spacing // 2
    return QRect(min_x - margin, min_y - margin, max_x - min_x + margin * 2, max_y - min_y + margin * 2)

def update_folder_background(app, folder_button):
    """
    更新单个文件夹的灰色背景框 —— 带动画：
      • 位置/尺寸变化：250 ms OutCubic
      • 显示时淡入：250 ms OutQuad
      • 隐藏时淡出：200 ms InQuad
    """

    # 1. 初次创建背景框
    if not hasattr(folder_button, "background_frame"):
        folder_button.background_frame = FolderBackground(app.scroll_content)
        folder_button.background_frame.lower()

        # 绑定透明度效果（适用于子控件）
        effect = QGraphicsOpacityEffect(folder_button.background_frame)
        effect.setOpacity(1.0)
        folder_button.background_frame.setGraphicsEffect(effect)

    frame = folder_button.background_frame
    effect = frame.graphicsEffect()  # type: QGraphicsOpacityEffect

    # 2. 计算应否显示以及目标矩形
    target_rect = calculate_folder_background_rect(
        folder_button,
        folder_button.sub_buttons,
        app.button_width,
        app.button_height,
        app.spacing,
    )

    # ---------- 需要显示 / 更新 ---------- #
    if folder_button.is_expanded and folder_button.sub_buttons and target_rect:
        # 几何动画（尺寸 / 位置）
        if frame.geometry() != target_rect:
            geom_anim = QPropertyAnimation(frame, b"geometry", frame)
            geom_anim.setDuration(250)
            geom_anim.setEasingCurve(QEasingCurve.OutCubic)
            geom_anim.setStartValue(frame.geometry() if frame.isVisible() else target_rect)
            geom_anim.setEndValue(target_rect)
            geom_anim.start(QAbstractAnimation.DeleteWhenStopped)

        # 若当前隐藏 → 淡入
        if frame.isHidden():
            frame.setGeometry(target_rect)
            frame.show()
            effect.setOpacity(0.0)

            fade_in = QPropertyAnimation(effect, b"opacity", frame)
            fade_in.setDuration(250)
            fade_in.setEasingCurve(QEasingCurve.OutQuad)
            fade_in.setStartValue(0.0)
            fade_in.setEndValue(1.0)
            fade_in.start(QAbstractAnimation.DeleteWhenStopped)

    # ---------- 需要隐藏 ---------- #
    else:
        if frame.isVisible():
            fade_out = QPropertyAnimation(effect, b"opacity", frame)
            fade_out.setDuration(200)
            fade_out.setEasingCurve(QEasingCurve.InQuad)
            fade_out.setStartValue(effect.opacity())
            fade_out.setEndValue(0.0)

            def _after_hide():
                frame.hide()
                effect.setOpacity(1.0)  # 复位，以便下次直接显示

            fade_out.finished.connect(_after_hide)
            fade_out.start(QAbstractAnimation.DeleteWhenStopped)

def update_all_folder_backgrounds(app, button_width, button_height):
    """更新所有文件夹的背景框"""
    # 先隐藏所有背景框，确保Z顺序正确
    for btn in app.buttons:
        if btn.is_folder and hasattr(btn, 'background_frame'):
            btn.background_frame.lower()
    
    # 然后更新所有文件夹背景
    for btn in app.buttons:
        if btn.is_folder:
            update_folder_background(app, btn)
UI/folder_ui/_background.py结束

UI/folder_ui/_frame.py开始
from PySide6.QtWidgets import QFrame


class ButtonFrame(QFrame):
    """
    自定义框架类，用于显示不同类型的边框提示
    """
    def __init__(self, parent, border_style):
        super().__init__(parent)
        self.setFrameShape(QFrame.Box)
        self.setLineWidth(2)
        self.setStyleSheet(border_style)
        self.hide()
UI/folder_ui/_frame.py结束

UI/folder_ui/_hints.py开始
# UI/folder_ui/_hints.py开始
from PySide6.QtCore import QRect
from ._layout import calculate_folder_area # Assumes calculate_folder_area is in _layout.py

class FolderHintMixin:
    """Unified management for hint frames.
    Host class (e.g., CoverContent) needs:
    - QFrame attributes: self.frame, self.blue_reorder_frame, self.red_removal_frame
    - bool: self.frame_visible
    - int: self.button_width, self.button_height, self.spacing
    - QWidget: self.scroll_content (for its width)
    """
    def show_frame(self, btn1, btn2):
        """Shows a blue dashed frame around two buttons to indicate a merge possibility."""
        if not hasattr(self, 'frame'): return
        left = min(btn1.x(), btn2.x()) - 10
        top = min(btn1.y(), btn2.y()) - 10
        right = max(btn1.x() + self.button_width, btn2.x() + self.button_width) + 10
        bottom = max(btn1.y() + self.button_height, btn2.y() + self.button_height) + 10
        self.frame.setGeometry(left, top, right - left, bottom - top)
        self.frame.show()
        self.frame_visible = True

    def hide_frame(self):
        """Hides the blue merge hint frame."""
        if hasattr(self, 'frame'):
            self.frame.hide()
        self.frame_visible = False

    def is_button_in_frame(self, button) -> bool:
        """Checks if the center of a button is within the visible blue merge hint frame."""
        if not self.frame_visible or not hasattr(self, 'frame'):
            return False
        button_rect = QRect(button.pos(), button.size())
        return self.frame.geometry().contains(button_rect.center())

    def show_blue_reorder_frame(self, parent_folder):
        """Shows a blue dashed frame indicating the reorder area within an expanded folder."""
        if not hasattr(self, 'blue_reorder_frame') or not hasattr(self, 'scroll_content'): return

        # Use calculate_folder_area from ._layout
        min_x_subs_only, min_y_subs_only, max_x_subs_only, max_y_subs_only = calculate_folder_area(
            parent_folder, parent_folder.sub_buttons, self.button_width, self.button_height
        )
        margin = 10
        # The reorder frame should span the width of the scroll content
        # and word_book_cover the vertical extent of sub-buttons.
        # Top starts from the top of the sub-button area.
        # If no sub_buttons, use parent_folder's bottom as reference.
        if parent_folder.sub_buttons:
            top = min_y_subs_only - margin
            height = (max_y_subs_only - min_y_subs_only) + 2 * margin
        else: # Fallback if no sub_buttons, frame below folder button
            top = parent_folder.y() + self.button_height + self.spacing - margin
            height = self.button_height + 2 * margin # A default height

        self.blue_reorder_frame.setGeometry(0, top, self.scroll_content.width(), height)
        self.blue_reorder_frame.show()
        self.blue_reorder_frame.raise_()


    def hide_blue_reorder_frame(self):
        """Hides the blue reorder hint frame."""
        if hasattr(self, 'blue_reorder_frame'):
            self.blue_reorder_frame.hide()

    def show_red_removal_frame(self, parent_folder):
        """Shows a red dashed frame indicating the area outside which a sub-button is considered "removed"."""
        if not hasattr(self, 'red_removal_frame'): return

        # The removal frame should be slightly larger than the folder's total area
        # including the folder button itself and its sub-buttons.
        all_buttons_for_area = [parent_folder] + parent_folder.sub_buttons
        min_x, min_y, max_x, max_y = calculate_folder_area(
            parent_folder, # This first arg is mostly for initial pos if sub_buttons is empty
            all_buttons_for_area, # Pass all relevant buttons for area calculation
            self.button_width,
            self.button_height
        )
        margin = 20 # A larger margin for the removal frame
        left = min_x - margin
        top = min_y - margin
        width = (max_x - min_x) + 2 * margin
        height = (max_y - min_y) + 2 * margin
        self.red_removal_frame.setGeometry(left, top, width, height)
        self.red_removal_frame.show()
        self.red_removal_frame.raise_()


    def hide_red_removal_frame(self):
        """Hides the red removal hint frame."""
        if hasattr(self, 'red_removal_frame'):
            self.red_removal_frame.hide()

__all__ = ["FolderHintMixin"]
# UI/folder_ui/_hints.py结束
UI/folder_ui/_hints.py结束

UI/folder_ui/_layout.py开始
# UI/folder_ui/_layout.py开始
from PySide6.QtCore import QPoint, QRect, QParallelAnimationGroup  # Moved QParallelAnimationGroup here for broader use
from typing import List, TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from UI.word_book_button import WordBookButton  # Or your specific button class


def calculate_main_button_positions(
        buttons: List['WordBookButton'],
        button_width: int,
        button_height: int,
        spacing: int,
        central_widget_width: int,
        top_margin: int = 40  # Added top_margin for flexibility
) -> List[QPoint]:
    """
    计算主界面按钮的位置
    """
    target_positions = []
    current_x = spacing
    current_y = spacing + top_margin

    main_buttons_for_layout = [btn for btn in buttons if
                               not btn.is_sub_button and not getattr(btn, 'is_new_button', False)]

    buttons_per_row = max(1, (central_widget_width - spacing) // (button_width + spacing))

    idx = 0
    for btn in buttons:
        if btn.is_sub_button or getattr(btn, 'is_new_button', False):
            continue

        if idx > 0 and idx % buttons_per_row == 0:
            current_y += button_height + spacing
            current_x = spacing

        target_positions.append(QPoint(current_x, current_y))
        current_x += button_width + spacing
        idx += 1

    return target_positions


def calculate_sub_button_positions(
        folder_button: 'WordBookButton',
        button_width: int,
        button_height: int,
        spacing: int,
        central_widget_width: int,
        folder_extra_width: int
) -> List[QPoint]:
    """
    计算文件夹内子按钮的位置.
    """
    target_positions = []
    if not folder_button.sub_buttons:
        return target_positions

    folder_internal_spacing = spacing * 1.5

    start_y_for_subs = folder_button.y() + button_height + spacing

    current_x = folder_internal_spacing
    current_y = start_y_for_subs

    sub_buttons_per_row = max(1, int((central_widget_width - folder_internal_spacing) // (
                button_width + folder_internal_spacing)))

    for idx, sub_btn in enumerate(folder_button.sub_buttons):
        if idx > 0 and idx % sub_buttons_per_row == 0:
            current_y += button_height + folder_internal_spacing
            current_x = folder_internal_spacing

        target_positions.append(QPoint(current_x, current_y))
        current_x += button_width + folder_internal_spacing

    return target_positions


def calculate_folder_area(
        folder_button: 'WordBookButton',
        sub_buttons: List['WordBookButton'],
        button_width: int,
        button_height: int
) -> tuple[int, int, int, int]:
    """
    计算文件夹区域（只包括传入的子按钮, 不包括文件夹按钮本身,除非sub_buttons为空）
    """
    if not sub_buttons:
        min_x = folder_button.x()
        min_y = folder_button.y()
        max_x = folder_button.x() + button_width
        max_y = folder_button.y() + button_height
        return min_x, min_y, max_x, max_y

    min_x = min(btn.x() for btn in sub_buttons)
    min_y = min(btn.y() for btn in sub_buttons)
    max_x = max(btn.x() + button_width for btn in sub_buttons)
    max_y = max(btn.y() + button_height for btn in sub_buttons)

    return min_x, min_y, max_x, max_y


def calculate_reorder_area(
        folder_button: 'WordBookButton',
        button_width: int,
        button_height: int,
        spacing: int,
        central_widget_width: int,
        folder_extra_width: int
) -> QRect:
    """
    计算文件夹内重排序区域.
    """
    if not folder_button.sub_buttons:
        left = 0
        top = folder_button.y() + button_height + spacing
        width = central_widget_width
        height = button_height + spacing
        return QRect(left, top, int(width), int(height))

    folder_internal_spacing = spacing * 1.5

    min_y_sub = min(btn.y() for btn in folder_button.sub_buttons)
    max_y_sub = max(btn.y() + button_height for btn in folder_button.sub_buttons)

    left = 0
    top = min_y_sub - folder_internal_spacing / 2
    width = central_widget_width
    height = (max_y_sub - min_y_sub) + folder_internal_spacing

    return QRect(left, int(top), int(width), int(height))


class FolderLayoutMixin:
    """
    把『按钮网格布局 / 拖拽排序』相关算法统一放到这里。
    """

    def update_button_positions(self):
        if not hasattr(self, "buttons") or not self.buttons:
            return

        available_width = self.scroll_content.width() or self.scroll_area.viewport().width()
        bw, bh, sp = self.button_width, self.button_height, self.spacing
        top_margin = getattr(self, "top_margin", 40)

        current_x = sp
        current_y = sp + top_margin

        buttons_per_row = max(1, (available_width - sp) // (bw + sp))

        main_button_idx = 0
        for btn in self.buttons:
            if getattr(btn, "is_dragging", False):
                continue

            if main_button_idx > 0 and main_button_idx % buttons_per_row == 0:
                current_y += bh + sp
                current_x = sp
            btn.move(current_x, current_y)

            if btn.is_folder and btn.is_expanded:
                folder_internal_spacing = sp * 1.5
                current_y += bh + sp
                sub_current_x = folder_internal_spacing

                sub_buttons_per_row = max(1, int((available_width - folder_internal_spacing) // (
                            bw + folder_internal_spacing)))

                for sub_idx, sub_btn in enumerate(btn.sub_buttons):
                    if getattr(sub_btn, "is_dragging", False):
                        continue

                    if sub_idx > 0 and sub_idx % sub_buttons_per_row == 0:
                        current_y += bh + folder_internal_spacing
                        sub_current_x = folder_internal_spacing

                    sub_btn.move(sub_current_x, current_y)
                    sub_btn.show()
                    sub_current_x += bw + folder_internal_spacing

                if btn.sub_buttons:
                    current_y += bh + folder_internal_spacing
                current_x = sp
                main_button_idx = -1

                from ._background import update_folder_background
                update_folder_background(self, btn)
            else:
                current_x += bw + sp

            main_button_idx += 1

        if hasattr(self, 'new_book_button'):
            if current_x + bw > available_width - sp:
                current_y += bh + sp
                current_x = sp
            elif main_button_idx == 0 and not self.buttons:
                current_x = sp
                current_y = sp + top_margin

            self.new_book_button.move(current_x, current_y)

        min_height_needed = current_y + bh + sp
        self.scroll_content.setMinimumHeight(min_height_needed)

        from ._background import update_all_folder_backgrounds
        update_all_folder_backgrounds(self, bw, bh)

    def update_button_order(self, dragged_button: 'WordBookButton'):
        if dragged_button.is_sub_button or not hasattr(self, "buttons"):
            return

        other_buttons = [b for b in self.buttons if b is not dragged_button and not getattr(b, 'is_new_button', False)]

        all_main_buttons = [b for b in self.buttons if not b.is_sub_button and not getattr(b, 'is_new_button', False)]

        targets = calculate_main_button_positions(
            all_main_buttons, self.button_width, self.button_height,
            self.spacing, self.scroll_content.width(), getattr(self, "top_margin", 40)
        )
        if not targets: return

        dragged_center = dragged_button.pos() + QPoint(self.button_width // 2, self.button_height // 2)

        closest_slot_index = 0
        min_dist = float('inf')

        num_slots = len(all_main_buttons)

        for i in range(num_slots):
            slot_pos = targets[i] if i < len(targets) else targets[-1]
            slot_center = slot_pos + QPoint(self.button_width // 2, self.button_height // 2)
            dist = (dragged_center - slot_center).manhattanLength()
            if dist < min_dist:
                min_dist = dist
                closest_slot_index = i

        if dragged_button in self.buttons:
            self.buttons.remove(dragged_button)

        current_main_buttons = [b for b in self.buttons if
                                not b.is_sub_button and not getattr(b, 'is_new_button', False)]

        new_main_buttons_order = []
        other_iter = iter(current_main_buttons)

        for i in range(len(current_main_buttons) + 1):
            if i == closest_slot_index:
                new_main_buttons_order.append(dragged_button)
            else:
                try:
                    new_main_buttons_order.append(next(other_iter))
                except StopIteration:
                    break

        self.buttons = new_main_buttons_order

        self.animate_button_positions(dragged_button)

    def animate_button_positions(self, dragged_button: Optional['WordBookButton'] = None):
        all_main_buttons = [b for b in self.buttons if not b.is_sub_button and not getattr(b, 'is_new_button', False)]

        targets = calculate_main_button_positions(
            all_main_buttons,
            self.button_width, self.button_height, self.spacing,
            self.scroll_content.width(), getattr(self, "top_margin", 40)
        )

        for i, btn in enumerate(all_main_buttons):
            if i < len(targets) and btn is not dragged_button and not getattr(btn, "is_dragging", False):
                btn.move(targets[i])

        current_x = self.spacing
        current_y = self.spacing + getattr(self, "top_margin", 40)
        available_width = self.scroll_content.width() or self.scroll_area.viewport().width()
        bw, bh, sp = self.button_width, self.button_height, self.spacing
        buttons_per_row = max(1, (available_width - sp) // (bw + sp))

        num_main_items = len(all_main_buttons)

        final_row_idx = (num_main_items - 1) // buttons_per_row if num_main_items > 0 else -1
        final_col_idx = (num_main_items - 1) % buttons_per_row if num_main_items > 0 else -1

        current_y += final_row_idx * (bh + sp) if final_row_idx >= 0 else 0
        current_x += (final_col_idx + 1) * (bw + sp) if final_col_idx >= 0 else 0

        if hasattr(self, 'new_book_button'):
            if num_main_items == 0:
                current_x = sp
                current_y = sp + getattr(self, "top_margin", 40)
            elif current_x + bw > available_width - sp:
                current_y += bh + sp
                current_x = sp

            if not getattr(self.new_book_button, "is_dragging", False) and \
                    self.new_book_button.pos() != QPoint(current_x, current_y):
                from ._animations import create_button_position_animation
                anim = create_button_position_animation(self.new_book_button, QPoint(current_x, current_y),
                                                        duration=100)
                anim.start()

    def finalize_button_order(self):
        all_main_buttons = [b for b in self.buttons if not b.is_sub_button and not getattr(b, 'is_new_button', False)]

        targets = calculate_main_button_positions(
            all_main_buttons, self.button_width, self.button_height,
            self.spacing, self.scroll_content.width(), getattr(self, "top_margin", 40)
        )

        # QParallelAnimationGroup imported at the top of the file now
        from ._animations import create_button_position_animation

        anim_group = QParallelAnimationGroup(self)
        for i, btn in enumerate(all_main_buttons):
            if i < len(targets) and btn.pos() != targets[i]:
                anim = create_button_position_animation(btn, targets[i], duration=300)
                anim_group.addAnimation(anim)

        if hasattr(self, 'new_book_button'):
            current_x = self.spacing
            current_y = self.spacing + getattr(self, "top_margin", 40)
            available_width = self.scroll_content.width() or self.scroll_area.viewport().width()
            bw, bh, sp = self.button_width, self.button_height, self.spacing
            buttons_per_row = max(1, (available_width - sp) // (bw + sp))

            num_main_items = len(all_main_buttons)
            final_row_idx = (num_main_items - 1) // buttons_per_row if num_main_items > 0 else -1
            final_col_idx = (num_main_items - 1) % buttons_per_row if num_main_items > 0 else -1

            current_y += final_row_idx * (bh + sp) if final_row_idx >= 0 else 0
            current_x += (final_col_idx + 1) * (bw + sp) if final_col_idx >= 0 else 0

            if num_main_items == 0:
                current_x = sp
                current_y = sp + getattr(self, "top_margin", 40)
            elif current_x + bw > available_width - sp:
                current_y += bh + sp
                current_x = sp

            new_book_final_pos = QPoint(current_x, current_y)
            if self.new_book_button.pos() != new_book_final_pos:
                anim = create_button_position_animation(self.new_book_button, new_book_final_pos, duration=300)
                anim_group.addAnimation(anim)

        anim_group.finished.connect(self.update_button_positions)
        anim_group.start()

    def update_sub_button_order(self, folder_button: 'WordBookButton',
                                dragged_sub_button: Optional['WordBookButton'] = None, realtime: bool = False):
        targets = calculate_sub_button_positions(
            folder_button, self.button_width, self.button_height,
            self.spacing, self.scroll_content.width(),
            getattr(self, 'folder_extra_width', 0)
        )

        if dragged_sub_button:
            d_center = dragged_sub_button.pos() + QPoint(self.button_width // 2, self.button_height // 2)

            closest_idx = 0
            if targets:
                closest_idx = min(
                    range(len(targets)),
                    key=lambda i: (targets[i] + QPoint(self.button_width // 2,
                                                       self.button_height // 2) - d_center).manhattanLength()
                )

            if dragged_sub_button in folder_button.sub_buttons:
                folder_button.sub_buttons.remove(dragged_sub_button)

            new_sub_order = folder_button.sub_buttons[:]
            new_sub_order.insert(closest_idx, dragged_sub_button)
            folder_button.sub_buttons = new_sub_order

        if realtime:
            self.finalize_sub_button_order_realtime(folder_button, dragged_button=dragged_sub_button)
        else:
            self.finalize_sub_button_order(folder_button, dragged_button=dragged_sub_button)

    def finalize_sub_button_order_realtime(self, folder_button: 'WordBookButton',
                                           dragged_button: Optional['WordBookButton'] = None):
        targets = calculate_sub_button_positions(
            folder_button, self.button_width, self.button_height, self.spacing,
            self.scroll_content.width(), getattr(self, 'folder_extra_width', 0)
        )

        for i, btn in enumerate(folder_button.sub_buttons):
            if i < len(targets) and btn is not dragged_button and not getattr(btn, "is_dragging", False):
                btn.move(targets[i])

        from ._background import update_folder_background
        update_folder_background(self, folder_button)

    def finalize_sub_button_order(self, folder_button: 'WordBookButton',
                                  dragged_button: Optional['WordBookButton'] = None):
        targets = calculate_sub_button_positions(
            folder_button, self.button_width, self.button_height, self.spacing,
            self.scroll_content.width(), getattr(self, 'folder_extra_width', 0)
        )

        # QParallelAnimationGroup imported at the top of the file now
        from ._animations import create_button_position_animation

        anim_group = QParallelAnimationGroup(self)
        for i, btn in enumerate(folder_button.sub_buttons):
            if i < len(targets) and btn is not dragged_button and not getattr(btn, "is_dragging",
                                                                              False) and btn.pos() != targets[i]:
                anim = create_button_position_animation(btn, targets[i], duration=300)
                anim_group.addAnimation(anim)

        from ._background import update_folder_background
        anim_group.finished.connect(lambda: update_folder_background(self, folder_button))
        anim_group.start()


__all__ = [
    "FolderLayoutMixin",
    "calculate_main_button_positions",
    "calculate_sub_button_positions",
    "calculate_folder_area",
    "calculate_reorder_area",
]
# UI/folder_ui/_layout.py结束
UI/folder_ui/_layout.py结束

UI/folder_ui/_operations.py开始
# UI/folder_ui/_operations.py开始
from __future__ import annotations
import os
import sys

from UI.word_book_button import WordBookButton  # Assuming WordBookButton is in root


# Helper functions for folder operations (adapted from original folder_ui/folder_operations.py)

def _create_sub_button_instance(
    original_button: WordBookButton,
    parent_folder:  WordBookButton,
    scroll_content,
    app_instance,
) -> WordBookButton:
    """生成文件夹中的子按钮（兼容新版 WordBookButton）。"""
    # ▶ 1) 构造——新版 ctor 仅 (title, color, parent)
    sub_btn = WordBookButton(
        original_button.text(),
        original_button.color,
        parent=scroll_content,
    )
    # ▶ 2) 恢复旧代码期望的附加属性
    sub_btn.app           = app_instance          # 被多处回调使用
    sub_btn.is_sub_button = True
    sub_btn.parent_folder = parent_folder
    sub_btn.path          = original_button.path  # 打开单词本所需

    # ▶ 3) 重新绑定点击 → CoverContent.show_word_book
    if hasattr(app_instance, "show_word_book"):
        try:
            sub_btn.clicked.disconnect()
        except Exception:
            pass
        sub_btn.clicked.connect(
            lambda _checked=False, p=sub_btn.path: app_instance.show_word_book(p)
        )

    sub_btn.hide()                                # 初始隐藏，动画/布局后再显示
    return sub_btn


def _internal_add_button_to_folder(button_to_add: WordBookButton, folder: WordBookButton, scroll_content,
                                   app_instance) -> WordBookButton:
    sub_btn = _create_sub_button_instance(button_to_add, folder, scroll_content, app_instance)
    folder.sub_buttons.append(sub_btn)
    folder.update_folder_icon()
    return sub_btn


def _internal_remove_sub_button_from_folder(sub_btn_to_remove: WordBookButton, main_buttons_list: list[WordBookButton]):
    parent_folder = sub_btn_to_remove.parent_folder
    if parent_folder:
        if sub_btn_to_remove in parent_folder.sub_buttons:
            parent_folder.sub_buttons.remove(sub_btn_to_remove)

        # The sub_btn_to_remove is already a WordBookButton instance.
        # It just needs its state changed and to be added to the main list.
        sub_btn_to_remove.is_sub_button = False
        sub_btn_to_remove.parent_folder = None
        # It's already parented to scroll_content, no need to re-parent.
        # Add it to the main list of buttons for layout.
        if sub_btn_to_remove not in main_buttons_list:
            # Add to a sensible position, e.g., after its ex-parent or at the end
            try:
                idx = main_buttons_list.index(parent_folder)
                main_buttons_list.insert(idx + 1, sub_btn_to_remove)
            except ValueError:
                main_buttons_list.append(sub_btn_to_remove)

        sub_btn_to_remove.show()  # Make it visible as a main button

        if hasattr(parent_folder, 'update_folder_icon'):
            parent_folder.update_folder_icon()
        return parent_folder
    return None


def _internal_check_and_remove_folder_if_needed(folder_btn: WordBookButton, main_buttons_list: list[WordBookButton],
                                                scroll_content):
    if len(folder_btn.sub_buttons) < 2:  # Dissolve if less than 2 items
        if folder_btn in main_buttons_list:
            main_buttons_list.remove(folder_btn)

        # Move remaining sub-buttons (0 or 1) to the main list
        for btn_to_repromote in folder_btn.sub_buttons:
            btn_to_repromote.is_sub_button = False
            btn_to_repromote.parent_folder = None
            # btn_to_repromote is already parented to scroll_content
            if btn_to_repromote not in main_buttons_list:
                # Add to a sensible position, e.g., where the folder was or at the end
                main_buttons_list.append(btn_to_repromote)  # Simplest: add to end
            btn_to_repromote.show()

        if hasattr(folder_btn, 'background_frame') and folder_btn.background_frame:
            folder_btn.background_frame.hide()
            folder_btn.background_frame.deleteLater()

        folder_btn.hide()
        folder_btn.deleteLater()  # Remove the folder button widget itself
        return True  # Folder was dissolved
    return False


class FolderOperationMixin:
    """
    业务操作 Mixin.
    Host class (CoverContent) needs:
        buttons (List[WordBookButton]), scroll_content,
        button_width, button_height, spacing,
        edit_mode, proximity_pair, frame_visible (from HintMixin)
        update_button_positions() (from LayoutMixin),
        toggle_folder() (from AnimationMixin),
        hide_frame() (from HintMixin),
        show_word_book() (own method),
        controller (CoverController, for saving layout)
    """

    def remove_sub_button_from_folder(self, sub_btn: WordBookButton):
        # `self` is CoverContent
        parent_folder = _internal_remove_sub_button_from_folder(sub_btn, self.buttons)
        if not parent_folder:
            return

        if self.edit_mode:
            sub_btn.start_jitter()  # Start jitter on the now main button

        # Check if the parent folder needs to be dissolved
        dissolved = _internal_check_and_remove_folder_if_needed(parent_folder, self.buttons, self.scroll_content)

        self.update_button_positions()  # Refresh layout

        if hasattr(self, 'controller') and hasattr(self.controller, 'save_current_layout'):
            self.controller.save_current_layout()

    def merge_folders(self):
        # `self` is CoverContent
        if not getattr(self, "proximity_pair", None):
            return

        btn1, btn2 = self.proximity_pair

        # --- A. Add a normal button to an existing folder ---
        if btn2.is_folder and not btn1.is_folder:  # btn1 (dragged) into btn2 (folder)
            self._add_to_existing_folder(src_btn=btn1, folder_btn=btn2)
        elif btn1.is_folder and not btn2.is_folder:  # btn2 (dragged) into btn1 (folder)
            self._add_to_existing_folder(src_btn=btn2, folder_btn=btn1)

        # --- B. Merge two normal buttons into a new folder ---
        elif not btn1.is_folder and not btn2.is_folder:
            self._create_new_folder(btn1, btn2)

        # --- C. Merging folder into folder (not typically supported by simple drag) ---
        # else: # Both are folders, or one is folder and other is also folder (complex case)
        # print("Folder to Folder merge not implemented via simple proximity.")
        # self.hide_frame()
        # return

        self.update_button_positions()
        self.hide_frame()  # From HintMixin

        if hasattr(self, 'controller') and hasattr(self.controller, 'save_current_layout'):
            self.controller.save_current_layout()

    def _add_to_existing_folder(self, src_btn: WordBookButton, folder_btn: WordBookButton):
        # `self` is CoverContent
        new_sub_btn = _internal_add_button_to_folder(src_btn, folder_btn, self.scroll_content, self)

        if src_btn in self.buttons:
            self.buttons.remove(src_btn)
        src_btn.hide()
        src_btn.deleteLater()  # Original button is replaced by new_sub_btn

        if self.edit_mode:
            new_sub_btn.start_jitter()
            # If folder was not expanded, expand it to show the new sub_button
            if not folder_btn.is_expanded:
                self.toggle_folder(folder_btn)  # From AnimationMixin
        elif folder_btn.is_expanded:  # If already expanded, just update positions
            self.update_button_positions()  # This will show the new_sub_btn

        # If not in edit mode and folder is collapsed, sub_btn is added but stays hidden until folder expands
        # update_button_positions will handle overall layout.

        folder_btn.update_folder_icon()

    def _create_new_folder(self, btn1: WordBookButton, btn2: WordBookButton):
        """拖两个主按钮合并 → 新建文件夹。"""
        folder_name = f"Folder {len([b for b in self.buttons if b.is_folder]) + 1}"
        folder_color = btn1.color

        # ▶ 新版构造；随后补挂 app 属性
        folder_btn = WordBookButton(folder_name, folder_color, parent=self.scroll_content)
        folder_btn.app = self
        folder_btn.is_folder = True
        folder_btn.is_expanded = False
        folder_btn.sub_buttons = []
        folder_btn.move(btn1.pos())  # 先放到原按钮位置

        # 子按钮实例化（复用上面新改的工具函数）
        sub1 = _create_sub_button_instance(btn1, folder_btn, self.scroll_content, self)
        sub2 = _create_sub_button_instance(btn2, folder_btn, self.scroll_content, self)
        folder_btn.sub_buttons.extend([sub1, sub2])

        # 移除原按钮
        for old in (btn1, btn2):
            if old in self.buttons:
                self.buttons.remove(old)
            old.hide();
            old.deleteLater()

        # 挂到主列表并更新 UI
        self.buttons.append(folder_btn)
        folder_btn.show()
        folder_btn.update_folder_icon()

        if self.edit_mode:
            folder_btn.start_jitter();
            sub1.start_jitter();
            sub2.start_jitter()
            self.toggle_folder(folder_btn)  # 编辑模式下自动展开
        else:
            self.toggle_folder(folder_btn)


__all__ = ["FolderOperationMixin"]
# UI/folder_ui/_operations.py结束
UI/folder_ui/_operations.py结束

UI/folder_ui/_utils.py开始
import math
from typing import Sequence, Tuple, Union
from PySide6.QtCore import QPoint, QRect
import os
import sys
from pathlib import Path
from PIL import Image

def calculate_button_distance(btn1, btn2, button_width, button_height):
    """
    计算两个按钮中心点之间的距离
    """
    center1 = btn1.pos() + QPoint(button_width // 2, button_height // 2)
    center2 = btn2.pos() + QPoint(button_width // 2, button_height // 2)
    dx = center1.x() - center2.x()
    dy = center1.y() - center2.y()
    return math.sqrt(dx * dx + dy * dy)


def is_button_in_frame(button, frame):
    """
    检查按钮是否在框架内
    """
    button_rect = QRect(button.pos(), button.size())
    frame_rect = QRect(frame.pos(), frame.size())
    return frame_rect.contains(button_rect)


def create_folder_icon(
    sub_icon_paths: Sequence[Union[str, Path]],
    folder_name: str,
    out_path: Union[str, Path] = None,
    *,
    cell_size: int = 120,                 # ⬆️ 缩略图默认尺寸
    grid_size: Tuple[int, int] = (3, 3),
    spacing: int = 1,                    # ⬇️ 间距默认
    bg_color: Tuple[int, int, int, int] = (255, 255, 255, 0),
) -> str:
    """
    将最多 9 张子图标拼成一个九宫格缩略图（iOS 文件夹风格）。

    Parameters
    ----------
    sub_icon_paths : Sequence[str | Path]
        子按钮图标的文件路径列表。
    folder_name : str
        文件夹名称，用于生成输出文件名（格式为 ``folder_<文件夹名称>.png``）。
    out_path : str | Path, optional
        输出文件路径；为空则自动写入 <程序目录>/icon/ 目录，且文件名遵循
        ``folder_<文件夹名称>.png`` 的规则。
    cell_size : int, default 120
        单个子图在九宫格里的边长（像素）。
    grid_size : (int, int), default (3, 3)
        网格列数 × 行数。
    spacing : int, default 1
        子图之间以及与外边缘的间距。
    bg_color : (R, G, B, A), default (255, 255, 255, 0)
        背景颜色（含透明度）。

    Returns
    -------
    str
        合成图保存的绝对路径
    """
    # ---------- 计算整体尺寸 ----------
    cols, rows = grid_size
    total_w = cols * cell_size + (cols + 1) * spacing
    total_h = rows * cell_size + (rows + 1) * spacing
    canvas = Image.new("RGBA", (total_w, total_h), bg_color)

    # ---------- 粘贴子图 ----------
    for idx, icon_path in enumerate(sub_icon_paths[: rows * cols]):
        try:
            icon = Image.open(icon_path).convert("RGBA").resize(
                (cell_size, cell_size), Image.LANCZOS
            )
        except (FileNotFoundError, OSError):
            continue

        col = idx % cols
        row = idx // cols
        x = spacing + col * (cell_size + spacing)
        y = spacing + row * (cell_size + spacing)
        canvas.alpha_composite(icon, (x, y))

    # ---------- 保存 ----------
    if out_path is None:
        base_dir = Path(os.path.dirname(os.path.abspath(sys.argv[0]))) / "icon"
        base_dir.mkdir(parents=True, exist_ok=True)
        # 统一命名：folder_<文件夹名称>.png
        out_path = base_dir / f"folder_{folder_name}.png"

    out_path = Path(out_path)
    canvas.save(out_path)
    return str(out_path)
UI/folder_ui/_utils.py结束

UI/folder_ui/api.py开始
# UI/folder_ui/api.py开始
"""Public façade for the *Folder UI* subsystem.

External modules – notably *CoverContent*, *WordBookButton*, or any editor
plugins – should import all Folder‑related UI behaviour exclusively from this
module.  Doing so decouples them from the internal physical layout of the
package, which may evolve over time.

Example
-------
from UI.folder_ui.api import FolderLayoutMixin, ButtonFrame # Corrected import example

All symbols listed in ``__all__`` below are guaranteed to remain stable across
minor releases.
"""

from __future__ import annotations

from ._layout import (
    FolderLayoutMixin,
    calculate_main_button_positions,
    calculate_sub_button_positions,
    calculate_folder_area,
    calculate_reorder_area
)
from ._operations import FolderOperationMixin
from ._animations import (
    FolderAnimationMixin,
    create_folder_toggle_animation,
    create_button_position_animation
)
from ._background import (
    update_all_folder_backgrounds,
    update_folder_background,
    FolderBackground,
)
from ._hints import FolderHintMixin
from ._frame import ButtonFrame # This is the generic frame for hints
from ._utils import create_folder_icon, calculate_button_distance, is_button_in_frame

__all__: list[str] = [
    "FolderLayoutMixin",
    "calculate_main_button_positions", # Exporting helper if needed directly
    "calculate_sub_button_positions",
    "calculate_folder_area",
    "calculate_reorder_area",
    "FolderOperationMixin",
    "FolderAnimationMixin",
    "create_folder_toggle_animation", # Exporting helper if needed directly
    "create_button_position_animation",
    "FolderHintMixin",
    "update_all_folder_backgrounds",
    "update_folder_background",
    "FolderBackground",
    "ButtonFrame",
    "create_folder_icon",
    "calculate_button_distance",
    "is_button_in_frame",
]
# UI/folder_ui/api.py结束
UI/folder_ui/api.py结束

UI/folder_ui/button.py开始
import math
from typing import Optional, Tuple

from PySide6.QtCore import Qt, QPoint, QPropertyAnimation, QRect, QEasingCurve, QParallelAnimationGroup, QSize
from PySide6.QtGui import QPainter
from PySide6.QtWidgets import QPushButton, QStyleOptionButton, QStyle
from PySide6.QtCore import Property


class DraggableButton(QPushButton):
    def __init__(self, text, parent, app=None):
        super().__init__(text, parent)
        self.parent_widget = parent
        self.app = app  # 主应用窗口引用
        self.drag_start_position = QPoint()
        self.is_dragging = False
        self.setFixedSize(100, 50)
        self.is_folder = False  # 是否为文件夹按钮
        self.sub_buttons = []  # 存储子按钮
        self.is_expanded = False  # 文件夹是否展开

        # 新增属性，用于标识是否为文件夹内的子按钮
        self.is_sub_button = False
        self.parent_folder = None  # 若为子按钮，记录所属文件夹
        self.drag_out_threshold_exceeded = False  # 标记是否拖出阈值

        # 抖动动画相关
        self.jitter_animation_group = QParallelAnimationGroup(self)
        self.jitter_animations = []  # 存储动画对象，方便管理
        self._rotation = 0  # 用于旋转动画的属性

        # 新增：文件夹展开/关闭动画组属性，防止重复触发
        self.folder_animation_group = None
        # ➤➤➤ 新增：删除小按钮（右上角 ✕） ← iOS 风格
        self.delete_button = QPushButton("✕", self)
        self.delete_button.setFixedSize(22, 22)
        self.delete_button.move(self.width() - self.delete_button.width(), 0)
        self.delete_button.setStyleSheet("""
                   QPushButton {
                       background-color: #FF4D4D;
                       color: #FFFFFF;
                       border: none;
                       border-radius: 11px;
                       font-weight: bold;
                   }
                   QPushButton:hover { background-color: #FF8080; }
               """)
        self.delete_button.hide()
        self.delete_button.clicked.connect(self.on_delete_clicked)

    # ✕ 按钮点击 —— 主按钮走 delete_word_book，子按钮走 remove_sub_button_from_folder
    def on_delete_clicked(self):
        """✕ 按钮点击：主按钮、子按钮统一直接删除单词册。

        现在加入保护：主单词册（“总单词册”）永远不可删除。
        """
        # —— 主单词册保护 —— #
        if self.text() == "总单词册":
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(
                self,
                "提示",
                "『总单词册』是主单词册，无法删除！"
            )
            return

        # —— 原有逻辑 —— #
        if getattr(self, "is_new_button", False):
            return  # “新建单词册” 不可删

        if hasattr(self.app, "delete_word_book"):
            self.app.delete_word_book(self)

    def start_jitter(self):
        if self.jitter_animation_group.state() == QPropertyAnimation.Running:
            return  # 避免重复启动

        duration = 200  # 动画时长增加到200毫秒，使抖动更平滑
        rotation_angle = 3  # 旋转角度保持不变

        # 清空之前的动画
        self.jitter_animation_group.stop()
        self.jitter_animation_group.clear()
        self.jitter_animations = []

        # 优化旋转动画的关键帧分布，使动画更加平滑
        animation_rotation = QPropertyAnimation(self, b"rotation")
        animation_rotation.setDuration(duration)
        animation_rotation.setKeyValueAt(0, 0)
        animation_rotation.setKeyValueAt(0.3, -rotation_angle)
        animation_rotation.setKeyValueAt(0.5, 0)
        animation_rotation.setKeyValueAt(0.7, rotation_angle)
        animation_rotation.setKeyValueAt(1, 0)
        self.jitter_animations.append(animation_rotation)

        for anim in self.jitter_animations:
            self.jitter_animation_group.addAnimation(anim)

        self.jitter_animation_group.setLoopCount(-1)  # 无限循环
        self.jitter_animation_group.start()
        # ➤ 更新 ✕ 按钮可见性
        self.update_delete_button_visibility()

    # 根据当前是否处于编辑模式决定 ✕ 是否可见
    def update_delete_button_visibility(self):
        """根据是否处于编辑模式决定 ✕ 按钮可见性，并禁止主单词册出现✕ 按钮。"""
        show = (
            self.app
            and getattr(self.app, "edit_mode", False)
            and not getattr(self, "is_new_button", False)
            and self.text() != "总单词册"          # ⭐ 关键：主单词册不显示删除按钮
        )
        self.delete_button.move(self.width() - self.delete_button.width(), 0)
        self.delete_button.setVisible(show)

    def stop_jitter(self):
        if self.jitter_animation_group.state() == QPropertyAnimation.Running:
            self.jitter_animation_group.stop()
            self._rotation = 0
            self.update()
        # ➤ 隐藏 ✕ 按钮
        self.update_delete_button_visibility()

    # 添加rotation属性的getter和setter方法，用于旋转动画
    @Property(float)
    def rotation(self):
        return self._rotation

    @rotation.setter
    def rotation(self, angle):
        self._rotation = angle
        self.update()  # 触发重绘

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # 保存当前状态
        painter.save()

        # 如果有旋转角度，应用旋转变换
        if self._rotation != 0:
            painter.translate(self.width() / 2, self.height() / 2)
            painter.rotate(self._rotation)
            painter.translate(-self.width() / 2, -self.height() / 2)

        # 绘制按钮背景
        option = QStyleOptionButton()
        option.initFrom(self)
        option.state = QStyle.State_Enabled
        if self.isDown():
            option.state |= QStyle.State_Sunken
        elif self.isChecked():
            option.state |= QStyle.State_On
        elif not self.isFlat():
            option.state |= QStyle.State_Raised
        option.rect = self.rect()
        self.style().drawControl(QStyle.CE_PushButton, option, painter, self)

        # 绘制按钮文本
        painter.setPen(self.palette().buttonText().color())
        painter.drawText(self.rect(), Qt.AlignCenter, self.text())

        # 恢复状态
        painter.restore()

    def mousePressEvent(self, event):
        """
        左键按下 —— 准备拖动（仅编辑模式）

        ✨ 关键点
        ------------------------------------------------------------------
        1. 依旧调用 collapse_all_folders() 折叠全部文件夹；
        2. 记录 _cursor_offset（鼠标位于按钮内的相对坐标）；
        3. 折叠后启动一个 10 ms 周期的 QTimer（持续 0-800 ms）：
              • 每次 timeout → _recenter()，同步滚动条并把按钮
                调整到「当前鼠标全局坐标 − _cursor_offset」处，
                同时更新 drag_start_position。
           因为 _recenter() 每次都取实时鼠标位置，所以拖动过程
           中的任何鼠标移动都会被立即补偿。
        """
        """按下：开启拖拽 + 启动补偿计时器（800 ms 后自动停止）。"""
        if event.button() == Qt.LeftButton and self.app.edit_mode:
            from PySide6.QtCore import QTimer, QPoint
            from PySide6.QtGui  import QCursor

            # —— ① 缓存原位置 —— #
            self._origin_pos = self.pos()

            # —— ② 启动拖拽 —— #
            cursor_global       = event.globalPosition().toPoint()
            btn_global          = self.mapToGlobal(QPoint(0, 0))
            self._cursor_offset = cursor_global - btn_global
            self.drag_start_position = cursor_global
            self.raise_()
            self.is_dragging = True
            self.setStyleSheet("background-color: lightblue;")

            # —— ③ 折叠文件夹 + 创建补偿计时器 —— #
            if not self.is_sub_button and callable(getattr(self.app, "collapse_all_folders", None)):
                scroll_area = getattr(self.app, "scroll_area", None)
                old_scroll  = scroll_area.verticalScrollBar().value() if scroll_area else None
                self.app.collapse_all_folders()

                def _recenter():
                    if scroll_area and old_scroll is not None:
                        sb = scroll_area.verticalScrollBar()
                        sb.setValue(min(old_scroll, sb.maximum()))
                    cursor_now    = QCursor.pos()
                    target_global = cursor_now - self._cursor_offset
                    shift         = target_global - self.mapToGlobal(QPoint(0, 0))
                    if shift:
                        self.move(self.pos() + shift)
                    self.drag_start_position = cursor_now

                self._recenter_timer = QTimer(self)
                self._recenter_timer.setInterval(10)
                self._recenter_timer.timeout.connect(_recenter)
                self._recenter_timer.start()
                _recenter()  # 立即补偿首帧

                # —— ④ 800 ms 后安全停止 —— #
                QTimer.singleShot(800, self._stop_recenter_timer)

        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if not (event.buttons() & Qt.LeftButton) or not self.is_dragging or not self.app.edit_mode:
            return

        delta = event.globalPosition().toPoint() - self.drag_start_position
        new_pos = self.pos() + delta
        self.move(new_pos)
        self.drag_start_position = event.globalPosition().toPoint()

        # 如果是文件夹内的子按钮，则执行拖出或重排序逻辑
        if self.is_sub_button and self.parent_folder and self.app.edit_mode:
            # 计算文件夹内子按钮的布局区域
            folder_spacing = self.app.spacing * 1.5
            available_width = self.app.central_widget.width() - folder_spacing * 1.5 + self.app.folder_extra_width
            buttons_per_row = max(1, available_width // (self.app.button_width + folder_spacing))
            rows = (len(self.parent_folder.sub_buttons) + buttons_per_row - 1) // buttons_per_row

            # 计算重排序区域的边界
            reorder_area_left = self.parent_folder.x() - folder_spacing
            reorder_area_top = self.parent_folder.y() + self.app.button_height
            reorder_area_width = available_width + folder_spacing * 1.01
            reorder_area_height = (rows * (self.app.button_height + folder_spacing)) + folder_spacing * 1.01
            reorder_area = QRect(reorder_area_left, reorder_area_top, reorder_area_width, reorder_area_height)

            # 判断按钮是否在重排序区域内
            button_rect = QRect(self.pos(), self.size())
            if reorder_area.contains(button_rect.center()):
                # 显示蓝色框表示文件夹内重排序区域
                self.app.show_blue_reorder_frame(self.parent_folder)
                self.app.hide_red_removal_frame()
                self.drag_out_threshold_exceeded = False
                # 实时更新文件夹内子按钮排序（直接更新位置，无动画）
                self.app.update_sub_button_order(self.parent_folder, dragged_sub_button=self, realtime=True)
            else:
                # 超过阈值，显示红色框提示拖出文件夹
                self.app.hide_blue_reorder_frame()
                self.app.show_red_removal_frame(self.parent_folder)
                self.drag_out_threshold_exceeded = True
        else:
            # 主界面按钮执行原有的靠近检测和排序
            self.app.check_button_proximity(self)
            self.app.update_button_order(self)

    def mouseReleaseEvent(self, event):
        """
                拖拽释放 / 普通点击统一入口
                • 拖拽场景：保持子按钮重排序、文件夹合并等原有逻辑
                • 点击场景：编辑模式下仅做拖拽；非编辑模式才允许打开 / 展开
                同时在 super() 之后 setDown(False) 立即复位 pressed 颜色
                """
        """释放：停止补偿计时器；正常收尾（排序 / 合并 / 回弹）"""
        if self.app.edit_mode and self.is_dragging:
            self.is_dragging = False
            self.setStyleSheet("")

            # —— A. 子按钮 —— #
            if self.is_sub_button and self.parent_folder:
                if not self.drag_out_threshold_exceeded:
                    self.app.update_sub_button_order(
                        self.parent_folder, dragged_sub_button=self, realtime=False
                    )
                else:
                    self.app.remove_sub_button_from_folder(self)
                self.app.hide_blue_reorder_frame()
                self.app.hide_red_removal_frame()
                self.drag_out_threshold_exceeded = False

            # —— B. 主按钮 —— #
            else:
                if self.app.frame_visible and self.app.is_button_in_frame(self):
                    self.app.merge_folders()
                self.app.finalize_button_order()
                self.app.hide_frame()
                if not self.is_sub_button:
                    self.app.expand_all_folders()

            self.app.update_button_positions()

        elif not self.app.edit_mode and getattr(self, "is_folder", False):
            self.app.toggle_folder(self)

            # —— ★ 安全停止补偿计时器 —— #
        self._stop_recenter_timer()

        super().mouseReleaseEvent(event)
        self.setDown(False)
        self.update()

    # ============================================================
#  Button —— 计时器安全处理
# ============================================================

    def _stop_recenter_timer(self):
        """安全停止并销毁 _recenter_timer（若存在）。"""
        if hasattr(self, "_recenter_timer") and self._recenter_timer:
            if self._recenter_timer.isActive():
                self._recenter_timer.stop()
            self._recenter_timer.deleteLater()
            self._recenter_timer = None

UI/folder_ui/button.py结束

UI/new_wordbook_dialog.py开始
# UI/new_wordbook_dialog.py
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QLineEdit, QPushButton, QDialogButtonBox,
    QColorDialog, QMessageBox
)
from PySide6.QtGui import QColor


class NewWordBookDialog(QDialog):
    """输入『名称 + 颜色』的简单对话框"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("新建单词本")
        self.resize(320, 150)

        self._build_ui()
        self.book_name: str | None = None
        self.book_color: str = "#a3d2ca"   # 默认色

    # ------------------------------------------------------------
    def _build_ui(self):
        lay = QVBoxLayout(self)

        self.name_edit = QLineEdit(placeholderText="单词本名称")
        lay.addWidget(self.name_edit)

        self.color_btn = QPushButton("选择颜色 (#a3d2ca)")
        self.color_btn.clicked.connect(self._choose_color)
        lay.addWidget(self.color_btn)

        btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btns.accepted.connect(self._accept)
        btns.rejected.connect(self.reject)
        lay.addWidget(btns)

    # ------------------------------------------------------------
    def _choose_color(self):
        c = QColorDialog.getColor(QColor(self.book_color), self, "选择颜色")
        if c.isValid():
            self.book_color = c.name()
            self.color_btn.setText(f"选择颜色 ({self.book_color})")
            self.color_btn.setStyleSheet(f"background:{self.book_color}")

    def _accept(self):
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "错误", "名称不能为空！")
            return
        self.book_name = name
        self.accept()
UI/new_wordbook_dialog.py结束

UI/word_book_button/__init__.py开始
"""
Convenience re-exports so callers can simply:

    from ui.wordbook_button import WordBookButton, WordBookButtonViewModel
"""

from .view import WordBookButtonView
from .viewmodel import WordBookButtonViewModel

# Alias for backward-compat: treat the *view* as “the button widget”.
WordBookButton = WordBookButtonView

__all__ = [
    "WordBookButtonView",
    "WordBookButtonViewModel",
    "WordBookButton",
]

UI/word_book_button/__init__.py结束

UI/word_book_button/view.py开始
from __future__ import annotations
import os, sys
from pathlib import Path

from PySide6.QtCore import (
    Qt, QPoint, QSize, QTimer, Property, QPropertyAnimation, QEasingCurve, Signal
)
from PySide6.QtGui import (
    QColor, QPainter, QPixmap, QAction, QCursor
)
from PySide6.QtWidgets import (
    QPushButton, QMenu, QInputDialog
)

# -------- 常量 -------- #
_ICON_DIR          = "icon"
_BASE_ICON_NAME    = "word_book_cover.webp"   # 白底透明
_DEFAULT_ICON_SIZE = 110                      # px

# ============================================================
class WordBookButtonView(QPushButton):
    """保持旧视觉/交互（含点击暗化 + 抖动）的新按钮 View。"""

    # ============ 向外暴露的信号（旧逻辑仍接收） ============ #
    renameRequested = Signal(str)
    deleteRequested = Signal()
    openRequested   = Signal()

    # ----------------- 构造 ----------------- #
    def __init__(self, title: str, color: str, parent=None) -> None:
        super().__init__(title, parent)

        # —— 对外公开字段 —— #
        self.color       = color
        self.icon_size   = getattr(parent, "button_width", _DEFAULT_ICON_SIZE)
        self.icon_path   = self._ensure_icon_file(color)
        self.icon_pixmap = QPixmap(self.icon_path).scaled(
            self.icon_size, self.icon_size,
            Qt.KeepAspectRatio, Qt.SmoothTransformation
        )

        # —— 基本外观 —— #
        self.setCursor(Qt.PointingHandCursor)
        self.setCheckable(False)
        self.setStyleSheet(
            "QPushButton {background: transparent; border: none; color:#333; font-weight:bold;}"
        )

        # —— 点击暗化状态 —— #
        self._dark_opacity = 0.0
        self._fade_anim: QPropertyAnimation | None = None
        self._long_press_timer = QTimer(self, singleShot=True, interval=110)
        self._long_press_timer.timeout.connect(self._on_long_press)

        # —— 抖动动画 —— #
        self._jitter_anim: QPropertyAnimation | None = None
        self._jitter_offset: float = 0.0  # -3 ~ 3 像素

    # ===================== 抖动 ===================== #
    def start_jitter(self) -> None:
        if self._jitter_anim:
            return
        self._jitter_anim = QPropertyAnimation(self, b"jitterOffset")
        self._jitter_anim.setStartValue(-3)
        self._jitter_anim.setEndValue(3)
        self._jitter_anim.setDuration(180)
        self._jitter_anim.setEasingCurve(QEasingCurve.InOutSine)
        self._jitter_anim.setLoopCount(-1)
        self._jitter_anim.start()

    def stop_jitter(self) -> None:
        if self._jitter_anim:
            self._jitter_anim.stop()
            self._jitter_anim.deleteLater()
            self._jitter_anim = None
        self.jitterOffset = 0.0

    # Property 供动画用
    def _get_jitter(self) -> float:         return self._jitter_offset
    def _set_jitter(self, v: float) -> None:
        self._jitter_offset = v
        self.update()
    jitterOffset = Property(float, _get_jitter, _set_jitter)

    # ===================== 鼠标交互 ===================== #
    def mousePressEvent(self, ev):  # noqa: N802
        if ev.button() == Qt.LeftButton:
            self._set_dark(1.0)           # 立即暗化
            self._long_press_timer.start()
        super().mousePressEvent(ev)

    def mouseReleaseEvent(self, ev):  # noqa: N802
        if ev.button() == Qt.LeftButton:
            self._long_press_timer.stop()
            self._fade_dark()
        super().mouseReleaseEvent(ev)

    def mouseDoubleClickEvent(self, ev):  # noqa: N802
        self.openRequested.emit()
        super().mouseDoubleClickEvent(ev)

    # 长按定时器回调
    def _on_long_press(self):
        if self.isDown():                 # 按住不放 → 开始淡出
            self._fade_dark()

    # ===================== 右键菜单 ===================== #
    def contextMenuEvent(self, ev):  # noqa: N802
        m = QMenu(self)
        a1 = QAction("重命名", self)
        a2 = QAction("删除", self)
        a1.triggered.connect(self._prompt_rename)
        a2.triggered.connect(self.deleteRequested)
        m.addAction(a1); m.addAction(a2)
        m.exec(ev.globalPos())

    def _prompt_rename(self):
        new_name, ok = QInputDialog.getText(self, "重命名单词本", "新名称：")
        if ok and new_name.strip():
            self.renameRequested.emit(new_name.strip())

    # ===================== 暗化动画 ===================== #
    def _set_dark(self, value: float):
        self._dark_opacity = max(0.0, min(1.0, value))
        self.update()

    def _fade_dark(self):
        if self._fade_anim and self._fade_anim.state() == QPropertyAnimation.Running:
            self._fade_anim.stop()
        self._fade_anim = QPropertyAnimation(self, b"darkOpacity", self)
        self._fade_anim.setStartValue(self._dark_opacity)
        self._fade_anim.setEndValue(0.0)
        self._fade_anim.setDuration(150)
        self._fade_anim.start()

    def _get_dark(self) -> float:         return self._dark_opacity
    def _set_dark_prop(self, v: float):   self._set_dark(v)
    darkOpacity = Property(float, _get_dark, _set_dark_prop)

    # ===================== 绘制 ===================== #
    def paintEvent(self, _):  # noqa: N802
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # 1. 抖动平移
        painter.translate(self._jitter_offset, 0)

        # 2. 悬浮高亮 / 按下背景
        if self.underMouse() or self.isDown():
            bg = QColor(self.color).lighter(130 if self.isDown() else 180)
            painter.setPen(Qt.NoPen)
            painter.setBrush(bg)
            painter.drawRoundedRect(self.rect(), 14, 14)

        # 3. 图标
        ix = (self.width() - self.icon_pixmap.width()) // 2
        painter.drawPixmap(ix, 0, self.icon_pixmap)

        # 4. 暗化遮罩
        if self._dark_opacity > 0.01:
            c = QColor(0, 0, 0, int(150 * self._dark_opacity))
            painter.fillRect(self.rect(), c)

        # 5. 文字
        text_y = self.icon_size + 6
        rect   = self.rect().adjusted(4, text_y, -4, -4)
        painter.setPen(Qt.black)
        fm = painter.fontMetrics()
        txt = fm.elidedText(self.text(), Qt.ElideRight, rect.width())
        painter.drawText(rect, Qt.AlignHCenter | Qt.AlignTop, txt)

    # ===================== 图标生成 ===================== #
    def _ensure_icon_file(self, color: str) -> str:
        """若不存在已着色图标则生成并返回路径。"""
        base = Path(os.path.abspath(sys.argv[0])).parent
        icon_dir = base / _ICON_DIR
        icon_dir.mkdir(exist_ok=True)

        fn_color = color.lstrip("#")
        out_path = icon_dir / f"colored_icon_{fn_color}.png"
        if out_path.exists():
            return str(out_path)

        src = icon_dir / _BASE_ICON_NAME
        if not src.exists():
            pix = QPixmap(self.icon_size, self.icon_size); pix.fill(QColor(color))
            pix.save(out_path)
            return str(out_path)

        try:
            from PIL import Image
            im = Image.open(src).convert("RGBA")
            r, g, b = QColor(color).red(), QColor(color).green(), QColor(color).blue()
            datas = [(r, g, b, a) if a > 0 else (255, 255, 255, 0) for (*_, a) in im.getdata()]
            im.putdata(datas)
            im.save(out_path)
        except Exception:
            pix = QPixmap(self.icon_size, self.icon_size); pix.fill(QColor(color))
            pix.save(out_path)
        return str(out_path)

UI/word_book_button/view.py结束

UI/word_book_button/viewmodel.py开始
from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import QObject, Signal

from repositories.wordbook_repository import  WordBook
from services.wordbook_service import WordBookService
from UI.word_book_button.view import WordBookButtonView


class WordBookButtonViewModel(QObject):
    """
    Glue between pure-view (Qt widget) and pure-business (Service).
    Keeps lightweight state that the View *renders*.
    """

    # Re-expose intent signals upward (Controller may also subscribe)
    rename_requested = Signal(str)
    delete_requested = Signal()
    open_requested = Signal()

    def __init__(
        self,
        book: WordBook,
        view: WordBookButtonView,
        service: Optional[WordBookService] = None,
        parent=None,
    ) -> None:
        super().__init__(parent)
        self._book = book
        self._view = view
        self._svc = service or WordBookService.get_instance()

        # 1) Forward View → VM public signals
        view.renameRequested.connect(self.rename_requested)
        view.deleteRequested.connect(self.delete_requested)
        view.openRequested.connect(self.open_requested)

        # 2) Handle View → business directly when Controller absent
        view.renameRequested.connect(self._on_rename)
        view.deleteRequested.connect(self._on_delete)
        view.openRequested.connect(self._on_open)

    # ------------------------------------------------------------------ #
    # Public API (used by Controller or outer UI)
    # ------------------------------------------------------------------ #
    @property
    def book(self) -> WordBook:
        return self._book

    def update_domain(self, book: WordBook) -> None:
        """Replace the underlying domain obj & refresh view."""
        self._book = book
        self._view.setText(book.name)

    def notify_deleted(self) -> None:
        """Disable the button visually after deletion."""
        self._view.setEnabled(False)

    def open_in_editor(self) -> None:
        """Default behaviour: open book path in OS explorer (overrideable)."""
        from PySide6.QtGui import QDesktopServices, QGuiApplication
        if self._book.path:
            QDesktopServices.openUrl(Path(self._book.path).as_uri())
        else:
            QGuiApplication.beep()

    # ------------------------------------------------------------------ #
    # Internal slots (View ➜ direct business)
    # ------------------------------------------------------------------ #
    def _on_rename(self, new_name: str) -> None:
        updated = self._svc.rename(self._book, new_name)
        self.update_domain(updated)

    def _on_delete(self) -> None:
        self._svc.delete(self._book)
        self.notify_deleted()

    def _on_open(self) -> None:
        self.open_in_editor()

UI/word_book_button/viewmodel.py结束

UI/word_book_cover/__init__.py开始

UI/word_book_cover/__init__.py结束

UI/word_book_cover/cover_content.py开始
# UI/cover_content.py开始
from __future__ import annotations
from typing import TYPE_CHECKING

from PySide6.QtCore import QEvent, Qt
from PySide6.QtWidgets import QWidget, QScrollArea, QMessageBox
from PySide6.QtGui import QResizeEvent

from UI.folder_ui.api import (
    FolderAnimationMixin,
    FolderLayoutMixin,
    FolderHintMixin,
    FolderOperationMixin,
    update_all_folder_backgrounds,
    ButtonFrame,
    calculate_button_distance
)
from UI.word_book_button import WordBookButton
from UI.word_book_button import WordBookButtonView, WordBookButtonViewModel
from controllers.wordbook_button_controller import WordBookButtonController
from repositories.wordbook_repository import WordBook


from UI.word_book_inside.word_book_window import WordBookWindow

if TYPE_CHECKING:
    from controllers.cover_controller import CoverController


class CoverContent(
    QWidget,
    FolderAnimationMixin,
    FolderLayoutMixin,
    FolderHintMixin,
    FolderOperationMixin
):
    """Scroll‑area content that actually lays out the word‑book buttons and
    handles drag‑and‑drop / folder UI interactions.  It fulfils all
    dependencies required by the 4 FolderUI mixins.
    """

    def __init__(self, parent: QScrollArea) -> None:
        super().__init__(parent)
        if not isinstance(parent, QScrollArea):
            raise ValueError("CoverContent must be constructed with its QScrollArea as parent")

        self.scroll_area: QScrollArea = parent
        self.scroll_content: CoverContent = self
        self.controller: CoverController | None = None

        self.button_width: int = 120
        self.button_height: int = 150
        self.spacing: int = 20
        self.top_margin: int = 60
        self.folder_extra_width: int = 0

        self.edit_mode: bool = False
        self.buttons: list[WordBookButton] = []
        self.proximity_pair = None
        self.proximity_threshold = 100  # ADJUSTED FROM 68 (was too small for 120px wide buttons)

        self.frame = ButtonFrame(self, "border:2px dashed #3498db; background:rgba(52,152,219,.1);")
        self.blue_reorder_frame = ButtonFrame(self, "border:2px dashed blue; background:rgba(0,0,255,.1);")
        self.red_removal_frame = ButtonFrame(self, "border:2px dashed red; background:rgba(255,0,0,.1);")
        self.frame_visible: bool = False

        self.new_book_button = WordBookButton("新建单词本", "#a3d2ca", parent=self)
        self.new_book_button.app = self
        self.new_book_button.is_new_button = True
        self.new_book_button.is_folder = False
        self.new_book_button.is_sub_button = False

        self.scroll_area.viewport().installEventFilter(self)
        self._child_windows: list[WordBookWindow] = []
        self.setAcceptDrops(True)

    def check_button_proximity(self, dragged_button: WordBookButton):
        """Checks proximity for merging non-folder button with another non-folder button,
           or adding a non-folder button to an existing folder."""
        if dragged_button.is_sub_button or \
                getattr(dragged_button, 'is_new_button', False) or \
                dragged_button.is_folder:
            self.hide_frame()
            self.proximity_pair = None
            return

        closest_target = None
        min_distance_to_target = float('inf')

        for target_btn in self.buttons:
            if target_btn is dragged_button or \
                    target_btn.is_sub_button or \
                    getattr(target_btn, 'is_new_button', False):
                continue

            distance = calculate_button_distance(dragged_button, target_btn, self.button_width, self.button_height)

            if distance < min_distance_to_target:
                min_distance_to_target = distance
                closest_target = target_btn

        if closest_target and min_distance_to_target < self.proximity_threshold:
            self.show_frame(dragged_button, closest_target)
            self.proximity_pair = (dragged_button, closest_target)
        else:
            self.hide_frame()
            self.proximity_pair = None

    def show_word_book(self, path: str, target_word: str | None = None) -> None:
        if self.edit_mode and not getattr(self, 'opening_during_edit_allowed', False):
            return
        win = WordBookWindow(path, target_word=target_word)
        self._child_windows.append(win)
        win.setAttribute(Qt.WA_DeleteOnClose)
        win.destroyed.connect(lambda: self._child_windows.remove(win) if win in self._child_windows else None)
        win.show()

    def delete_word_book(self, button_to_delete: WordBookButton):
        if self.controller:
            self.controller.delete_word_book(button_to_delete)
        else:
            QMessageBox.warning(self, "Error", "Controller not available for deletion.")

    def resizeEvent(self, event: QResizeEvent) -> None:
        super().resizeEvent(event)
        self.update_button_positions()

    def eventFilter(self, obj, ev: QEvent) -> bool:
        if obj is self.scroll_area.viewport():
            if ev.type() == QEvent.Type.Wheel:
                if self.frame_visible: self.hide_frame()
                if self.blue_reorder_frame.isVisible(): self.hide_blue_reorder_frame()
                if self.red_removal_frame.isVisible(): self.hide_red_removal_frame()
            elif ev.type() == QEvent.Type.Resize:
                self.update_button_positions()

        return super().eventFilter(obj, ev)

# UI/cover_content.py结束
UI/word_book_cover/cover_content.py结束

UI/word_book_cover/cover_view.py开始
# ui/cover_view.py
from __future__ import annotations

from PySide6.QtCore    import Qt, Signal, QEvent

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QScrollArea,
    QPushButton, QLineEdit, QListWidget, QLabel
)
from UI.word_book_cover.cover_content import CoverContent
from styles import SECONDARY_BUTTON_STYLE, TEXT_EDIT_STYLE


class CoverView(QWidget):
    """
    纯 UI：标题栏 = 编辑按钮 + 全局搜索框
    中部 = ScrollArea，内部由 Controller 绝对定位各 WordBookButton
    """

    editToggled         = Signal(bool)
    searchTextChanged   = Signal(str)
    suggestionSelected  = Signal(str)     # 用户点击 / 回车确定的词

    # ------------------------------------------------------------
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("背单词程序")
        self.resize(660, 720)

        # ========= ① 头部 =========
        self.edit_btn = QPushButton("编辑")
        self.edit_btn.setFixedSize(60, 30)
        self.edit_btn.setStyleSheet(SECONDARY_BUTTON_STYLE)

        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("在全部单词册内搜索 …")
        self.search_bar.setFixedHeight(33)
        self.search_bar.setStyleSheet(TEXT_EDIT_STYLE)
        self.search_bar.installEventFilter(self)

        head = QHBoxLayout()
        head.setContentsMargins(0, 0, 0, 0)
        head.addWidget(self.edit_btn)
        head.addWidget(self.search_bar, 1)

        # ========= ② ScrollArea =========
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)

        # ⭐ 改用 CoverContent（自带文件夹功能）
        self.content = CoverContent(self.scroll_area)
        self.scroll_area.setWidget(self.content)

        # —— 初次启动提示 —— #
        self.empty_hint = QLabel("还没有单词本，点击下面的『新建单词本』按钮开始吧！", self.content)
        self.empty_hint.setAlignment(Qt.AlignCenter)

        # ========= ③ 根布局 =========
        root = QVBoxLayout(self)
        root.addLayout(head)
        root.addWidget(self.scroll_area)

        # ========= ④ 下拉建议列表 =========
        self.suggestions_list = QListWidget()
        self.suggestions_list.setWindowFlags(
            Qt.FramelessWindowHint
            | Qt.WindowStaysOnTopHint
            | Qt.NoDropShadowWindowHint
        )
        self.suggestions_list.setAttribute(Qt.WA_ShowWithoutActivating, True)
        self.suggestions_list.setFocusPolicy(Qt.NoFocus)
        self.suggestions_list.itemClicked.connect(self._on_suggestion_clicked)
        self.suggestions_list.hide()

        # ========= ⑤ 信号外发 =========
        self.edit_btn.clicked.connect(self._toggle_edit)
        self.search_bar.textChanged.connect(self.searchTextChanged)


    # ------------------------------------------------------------
    #               Controller 调用的 UI API
    # ------------------------------------------------------------
    def _toggle_edit(self) -> None:
        entering = self.edit_btn.text() == "编辑"
        self.edit_btn.setText("退出" if entering else "编辑")
        self.editToggled.emit(entering)

    # —— 清空 / 添加按钮 —— #
    def clear_wordbook_buttons(self) -> None:
        """
        删除当前所有单词本按钮，但保留“新建单词本”按钮，
        并让 CoverContent 自己维护 buttons 列表。
        """
        # CoverContent 在 build_buttons 时挂载了 .buttons
        for btn in list(getattr(self.content, "buttons", [])):
            if getattr(btn, "is_new_button", False):
                continue
            btn.setParent(None)
            btn.deleteLater()
            self.content.buttons.remove(btn)
        self.empty_hint.show()
    def add_wordbook_button(self, button: QPushButton) -> None:
        self.empty_hint.hide()
        button.setParent(self.content)
        button.show()

    # ------------------------------------------------------------
    #           下拉建议：由 Controller 调用
    # ------------------------------------------------------------
    def show_suggestions(self, words: list[str]) -> None:
        if not words:
            self.suggestions_list.hide()
            return

        self.suggestions_list.clear()
        self.suggestions_list.addItems(words)

        # 确定大小 & 位置
        row_h   = self.suggestions_list.sizeHintForRow(0) or 24
        max_row = min(8, len(words))
        self.suggestions_list.setFixedSize(
            self.search_bar.width(),
            max_row * row_h + 2
        )
        global_pos = self.search_bar.mapToGlobal(self.search_bar.rect().bottomLeft())
        self.suggestions_list.move(global_pos)
        self.suggestions_list.show()
        self.suggestions_list.setCurrentRow(0)

    def hide_suggestions(self) -> None:
        self.suggestions_list.hide()

    def _on_suggestion_clicked(self, item) -> None:
        self.hide_suggestions()
        self.search_bar.setText(item.text())
        self.suggestionSelected.emit(item.text())

    # ------------------------------------------------------------
    #      让 ↑ ↓ ↵ 在搜索框里直接操作建议列表
    # ------------------------------------------------------------
    def eventFilter(self, obj, event):
        if obj is self.search_bar and event.type() == QEvent.KeyPress:
            if not self.suggestions_list.isVisible():
                return super().eventFilter(obj, event)

            key = event.key()
            row = self.suggestions_list.currentRow()
            count = self.suggestions_list.count()

            if key == Qt.Key_Down:
                row = 0 if row < 0 else min(row + 1, count - 1)
                self.suggestions_list.setCurrentRow(row)
                return True
            elif key == Qt.Key_Up:
                row = count - 1 if row < 0 else max(row - 1, 0)
                self.suggestions_list.setCurrentRow(row)
                return True
            elif key in (Qt.Key_Return, Qt.Key_Enter):
                item = self.suggestions_list.currentItem()
                if item:
                    self._on_suggestion_clicked(item)
                return True

        return super().eventFilter(obj, event)

UI/word_book_cover/cover_view.py结束

UI/word_book_inside/word_book_window.py开始
from __future__ import annotations

import os
from PySide6.QtWidgets import QSplitter, QWidget, QVBoxLayout, QApplication
from PySide6.QtCore import Qt

from UI.word_book_inside.word_list_panel import WordListPanel
from UI.word_book_inside.word_detail_panel import WordDetailPanel
from UI.word_book_inside.word_edit_panel import WordEditPanel
from services.wordbook_service import WordBookService as WS


class WordBookWindow(QWidget):
    """顶层壳（替代原 inside.WordBookApp）。"""

    def __init__(self, path: str, target_word: str | None = None):
        super().__init__()
        self.path = path
        self.book_name = os.path.basename(path).split("_")[1]
        self.book_color = os.path.basename(path).split("_")[2]
        self.setWindowTitle(f"单词本 - {self.book_name}")
        self.resize(1200, 800)

        self._build_ui()
        if target_word:
            self._jump_to_word(target_word)

    # ------------------------------------------------------------------
    def _build_ui(self):
        lay = QVBoxLayout(self)
        self.split = QSplitter(Qt.Horizontal)
        self.list_panel = WordListPanel(self.book_name, self.book_color)
        self.list_panel.word_selected.connect(self._on_word_selected)
        self.list_panel.add_word_click.connect(self._on_add_word)
        self.list_panel.memory_click.connect(self._on_memory)
        self.split.addWidget(self.list_panel)

        self.detail_panel = WordDetailPanel()
        self.detail_panel.edit_requested.connect(self._enter_edit_mode)
        self.split.addWidget(self.detail_panel)
        self.split.setSizes([350, 850])
        lay.addWidget(self.split)

        self._current_word: dict | None = None
        self._dlg_add = None  # 保留对话框引用，避免被 GC

    # ------------------------------------------------------------------
    # 交互
    # ------------------------------------------------------------------
    def _on_word_selected(self, word: dict):
        self._current_word = word
        self.detail_panel.show_word(word)

    def _on_add_word(self):
        from add_new_word import WordEntryUI
        # 保持引用，避免立即被销毁
        self._dlg_add = WordEntryUI(self.path)
        self._dlg_add.save_successful.connect(lambda *_: self.list_panel.reload_words())
        self._dlg_add.show()

    def _on_memory(self):
        from memory_curve import MemoryCurveApp
        self._mem = MemoryCurveApp(self.path)
        self._mem.show()

    # ------------------------------------------------------------------
    # 编辑
    # ------------------------------------------------------------------
    def _enter_edit_mode(self, word: dict):
        self._edit_panel = WordEditPanel(word, self.book_name, self.book_color)
        self._edit_panel.edit_saved.connect(self._save_edit)
        self._edit_panel.cancelled.connect(self._exit_edit_mode)
        self.split.replaceWidget(1, self._edit_panel)

    def _save_edit(self, updated: dict):
        try:
            WS.save_word(self.book_name, self.book_color, updated)
            self.list_panel.reload_words()
            self._current_word = updated
        except Exception as exc:
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(self, "错误", str(exc))
            return
        self._exit_edit_mode()

    def _exit_edit_mode(self):
        self.split.replaceWidget(1, self.detail_panel)
        if self._current_word:
            self.detail_panel.show_word(self._current_word)

    # ------------------------------------------------------------------
    def _jump_to_word(self, word_name: str):
        for w in WS.list_words(self.book_name, self.book_color):
            if str(w["单词"]).strip().lower() == str(word_name).strip().lower():
                self._on_word_selected(w)
                break


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("需要传入 books_... 文件夹路径！")
        sys.exit(1)

    app = QApplication(sys.argv)
    win = WordBookWindow(sys.argv[1])
    win.show()
    sys.exit(app.exec())

UI/word_book_inside/word_book_window.py结束

UI/word_book_inside/word_detail_panel.py开始
from __future__ import annotations

from collections import OrderedDict

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QTextEdit, QPushButton, QTabWidget, QFrame,
)
from PySide6.QtCore import Signal, Qt

from styles import PRIMARY_BUTTON_STYLE, TEXT_EDIT_STYLE, LINE_EDIT_STYLE, TAG_LABEL_STYLE
from font import meaning_font, main_word_font, sentence_font, sentence_font_platte, list_word_font

class WordDetailPanel(QWidget):
    """右侧只读详情视图。"""

    edit_requested = Signal(dict)   # 当用户点击“编辑”

    def __init__(self, parent: QWidget | None = None):
        super().__init__(parent)
        self._build_ui()
        self._current_word: dict | None = None

    # ------------------------------------------------------------------
    def _build_ui(self):
        self.layout = QVBoxLayout(self)
        self.word_label = QLabel()
        self.word_label.setFont(main_word_font)
        self.word_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.word_label)

        self.tab = QTabWidget()
        self.layout.addWidget(self.tab, 1)

        # 占位——无数据时
        self.placeholder = QLabel("请选择左侧单词…", alignment=Qt.AlignCenter)
        self.layout.addWidget(self.placeholder)

    # ------------------------------------------------------------------
    def show_word(self, word: dict):
        self._current_word = word
        self.placeholder.hide()
        self.word_label.setText(str(word["单词"]))

        # 清空旧 tab
        while self.tab.count():
            self.tab.removeTab(0)

        # 构建『释义 & 例句』
        self._build_meaning_example_tab(word)
        # 备注
        self._build_note_tab(word)
        # 标签
        self._build_tag_tab(word)
        # 相关单词
        self._build_related_tab(word)

        # 编辑按钮
        if not hasattr(self, "_btn_edit"):
            self._btn_edit = QPushButton("编辑")
            self._btn_edit.setStyleSheet(PRIMARY_BUTTON_STYLE)
            self._btn_edit.clicked.connect(lambda: self.edit_requested.emit(self._current_word))
            self.layout.addWidget(self._btn_edit)

    # ------------------------------------------------------------------
    def _build_meaning_example_tab(self, w: dict):
        wid = QWidget(); lay = QVBoxLayout(wid)
        meanings, examples = w.get("释义", []), w.get("例句", [])
        if len(examples) < len(meanings):
            examples += [""] * (len(meanings) - len(examples))
        grouped: OrderedDict[str, list[str]] = OrderedDict()
        for m, e in zip(meanings, examples):
            grouped.setdefault(str(m).strip(), [])
            if e:
                grouped[str(m).strip()].append(e)

        for idx, (m, exs) in enumerate(grouped.items(), start=1):
            self._add_row(lay, f"释义{idx}:", m, multiline=False, bold=True)
            if exs:
                for j, ex in enumerate(exs, start=1):
                    self._add_row(lay, f"例句{idx}.{j}:", ex, multiline=True)
            else:
                self._add_row(lay, f"例句{idx}.1:", "", multiline=True)
            if idx < len(grouped):
                sep = QFrame(); sep.setFrameShape(QFrame.HLine); sep.setFrameShadow(QFrame.Sunken)
                lay.addWidget(sep)
        self.tab.addTab(wid, "释义 & 例句")

    def _build_note_tab(self, w: dict):
        wid = QWidget(); lay = QVBoxLayout(wid)
        self._add_row(lay, "备注:", w.get("备注", "无备注"), multiline=True)
        self.tab.addTab(wid, "备注")

    def _build_tag_tab(self, w: dict):
        wid = QWidget(); lay = QVBoxLayout(wid)
        tags = w.get("标签", [])
        txt = ", ".join(tags) if tags else "无标签"
        self._add_row(lay, "标签:", txt)
        self.tab.addTab(wid, "标签")

    def _build_related_tab(self, w: dict):
        rel = w.get("相关单词", [])
        txt = ", ".join(rel) if rel else "无"
        wid = QWidget(); lay = QVBoxLayout(wid)
        self._add_row(lay, "关联单词:", txt)
        self.tab.addTab(wid, "相关")

    # ------------------------------------------------------------------
    def _add_row(self, layout: QVBoxLayout, label_text: str, content: str, *, multiline=False, bold=False):
        lbl = QLabel(label_text)
        if bold:
            lbl.setFont(meaning_font)
        layout.addWidget(lbl)
        if multiline:
            te = QTextEdit()
            te.setReadOnly(True)
            te.setStyleSheet(TEXT_EDIT_STYLE)
            te.setPlainText(str(content))
            te.setFixedHeight(90)
            layout.addWidget(te)
        else:
            val = QLabel(str(content))
            layout.addWidget(val)

UI/word_book_inside/word_detail_panel.py结束

UI/word_book_inside/word_edit_panel.py开始
from __future__ import annotations

from datetime import datetime
from typing import List, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QGridLayout, QLineEdit, QTextEdit, QLabel, QPushButton, QHBoxLayout, QMessageBox
)
from PySide6.QtCore import Signal

from styles import (
    GREEN_BUTTON_STYLE, RED_BUTTON_STYLE, LINE_EDIT_STYLE, TEXT_EDIT_STYLE,
    SECONDARY_BUTTON_STYLE
)
from font import meaning_font, sentence_font, sentence_font_platte
from UI.element.MultiSelectComboBox import MultiSelectComboBox


class WordEditPanel(QWidget):
    """右侧：编辑模式。传入原 word dict 的副本进行编辑。"""

    edit_saved = Signal(dict)  # 发射保存后的完整 word dict
    cancelled = Signal()

    def __init__(self, word: dict, book_name: str, book_color: str, parent: QWidget | None = None):
        super().__init__(parent)
        self.book_name, self.book_color = book_name, book_color
        self.original = word.copy()
        self._build_ui()

    # ------------------------------------------------------------------
    # 构建界面
    # ------------------------------------------------------------------
    def _build_ui(self):
        self.layout = QVBoxLayout(self)
        # 释义-例句区
        self.meaning_grid = QGridLayout(); self.layout.addLayout(self.meaning_grid)
        self._rows: List[Tuple[QLineEdit, QTextEdit, QLabel, QLabel]] = []
        for idx, (m, e) in enumerate(zip(self.original.get("释义", []), self.original.get("例句", []))):
            self._rows.append(self._add_row(idx, m, e))
        if not self._rows:
            self._rows.append(self._add_row(0))

        ctrl = QHBoxLayout()
        btn_add = QPushButton("+"); btn_add.setFixedSize(30, 30); btn_add.setStyleSheet(GREEN_BUTTON_STYLE)
        btn_add.clicked.connect(self._add_row_clicked)
        btn_rm = QPushButton("-"); btn_rm.setFixedSize(30, 30); btn_rm.setStyleSheet(RED_BUTTON_STYLE)
        btn_rm.clicked.connect(self._remove_row_clicked)
        ctrl.addWidget(btn_add); ctrl.addWidget(btn_rm)
        self.layout.addLayout(ctrl)

        # 备注
        self.note_edit = QTextEdit(); self.note_edit.setPlainText(self.original.get("备注", ""))
        self.note_edit.setStyleSheet(TEXT_EDIT_STYLE)
        self.layout.addWidget(QLabel("备注:")); self.layout.addWidget(self.note_edit)

        # 标签多选
        self.tag_combo = MultiSelectComboBox(book_name=self.book_name, book_color=self.book_color)
        for t in self.tag_combo.allItems():
            self.tag_combo.addItem(t, t in self.original.get("标签", []))
        self.layout.addWidget(QLabel("标签:")); self.layout.addWidget(self.tag_combo)

        # 按钮
        btn_row = QHBoxLayout()
        btn_save = QPushButton("保存"); btn_save.setStyleSheet(SECONDARY_BUTTON_STYLE); btn_save.clicked.connect(self._on_save)
        btn_cancel = QPushButton("取消"); btn_cancel.setStyleSheet(RED_BUTTON_STYLE); btn_cancel.clicked.connect(lambda: self.cancelled.emit())
        btn_row.addWidget(btn_save); btn_row.addWidget(btn_cancel)
        self.layout.addLayout(btn_row)

    # ------------------------------------------------------------------
    # 行操作
    # ------------------------------------------------------------------
    def _add_row_clicked(self):
        idx = len(self._rows)
        self._rows.append(self._add_row(idx))

    def _remove_row_clicked(self):
        if len(self._rows) <= 1:
            return
        row_idx = len(self._rows) - 1
        base = row_idx * 2
        for r in (base, base + 1):
            for c in range(4):
                item = self.meaning_grid.itemAtPosition(r, c)
                if item and item.widget():
                    item.widget().deleteLater()
        self._rows.pop()

    def _add_row(self, row: int, meaning: str = "", example: str = ""):
        base_row = row * 2
        err_m = QLabel("", styleSheet="color:red;"); err_e = QLabel("", styleSheet="color:red;")
        err_m.hide(); err_e.hide()
        self.meaning_grid.addWidget(err_m, base_row, 1); self.meaning_grid.addWidget(err_e, base_row, 3)

        lab_m = QLabel(f"释义{row + 1}:"); lab_m.setFont(meaning_font)
        inp_m = QLineEdit(meaning); inp_m.setStyleSheet(LINE_EDIT_STYLE)
        lab_e = QLabel(f"例句{row + 1}:")
        lab_e.setFont(sentence_font); lab_e.setPalette(sentence_font_platte)
        inp_e = QTextEdit(); inp_e.setFixedHeight(90); inp_e.setStyleSheet(TEXT_EDIT_STYLE); inp_e.setPlainText(example)

        self.meaning_grid.addWidget(lab_m, base_row + 1, 0)
        self.meaning_grid.addWidget(inp_m, base_row + 1, 1)
        self.meaning_grid.addWidget(lab_e, base_row + 1, 2)
        self.meaning_grid.addWidget(inp_e, base_row + 1, 3)
        return inp_m, inp_e, err_m, err_e

    # ------------------------------------------------------------------
    # 保存逻辑
    # ------------------------------------------------------------------
    def _on_save(self):
        pairs: List[Tuple[str, str, QLabel, QLabel]] = []
        for inp_m, inp_e, err_m, err_e in self._rows:
            err_m.hide(); err_m.setText("")
            err_e.hide(); err_e.setText("")
            pairs.append((inp_m.text().strip(), inp_e.toPlainText().strip(), err_m, err_e))

        valid, has_pair = True, False
        for m, e, em, ee in pairs:
            if m and e:
                has_pair = True
            elif m and not e:
                ee.setText("*必填"); ee.show(); valid = False
            elif e and not m:
                em.setText("*必填"); em.show(); valid = False
        if not has_pair:
            QMessageBox.warning(self, "错误", "至少填写一对释义+例句！")
            return
        if not valid:
            return

        meanings, examples = [], []
        for m, e, *_ in pairs:
            if m and e:
                meanings.append(m); examples.append(e)

        updated = self.original.copy()
        updated.update({
            "释义": meanings,
            "例句": examples,
            "备注": self.note_edit.toPlainText().strip(),
            "标签": self.tag_combo.selectedItems(),
            "时间": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        })
        self.edit_saved.emit(updated)

UI/word_book_inside/word_edit_panel.py结束

UI/word_book_inside/word_list_panel.py开始
from __future__ import annotations

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QLineEdit, QLabel, QPushButton,
    QScrollArea, QHBoxLayout
)
from PySide6.QtCore import Signal, Qt, QTimer

from UI.element.MultiSelectComboBox import MultiSelectComboBox
from services.wordbook_service import WordBookService as WS
from styles import PRIMARY_BUTTON_STYLE, SECONDARY_BUTTON_STYLE, LINE_EDIT_STYLE
from font import list_word_font
from utils import get_tags_path


class WordListPanel(QWidget):
    """左侧：搜索框 + 标签过滤 + 单词列表"""

    # --- 对外信号 --- #
    word_selected = Signal(dict)   # 单词按钮被点击，发射完整单词 dict
    add_word_click = Signal()      # "添加新单词" 按钮
    memory_click = Signal()        # "背单词" 按钮

    def __init__(self, book_name: str, book_color: str, parent: QWidget | None = None):
        super().__init__(parent)
        self.book_name = book_name
        self.book_color = book_color
        self._timer: QTimer | None = None
        self.full_words: list[dict] = []
        self._build_ui()
        self._load_tags_to_filter()
        self.reload_words()

    # ------------------------------------------------------------------
    # UI
    # ------------------------------------------------------------------
    def _build_ui(self):
        lay = QVBoxLayout(self)

        # ---- 搜索框 ---- #
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("查找…")
        self.search_bar.setStyleSheet(LINE_EDIT_STYLE)
        self.search_bar.textChanged.connect(self._debounce_filter)
        lay.addWidget(self.search_bar)

        # ---- 标签过滤 ---- #
        tag_row = QHBoxLayout()
        tag_row.addWidget(QLabel("过滤标签:"))
        self.tag_filter_combo = MultiSelectComboBox(book_name=self.book_name, book_color=self.book_color)
        self.tag_filter_combo.model().itemChanged.connect(self.filter_words)
        tag_row.addWidget(self.tag_filter_combo)
        lay.addLayout(tag_row)

        # ---- 控制按钮 ---- #
        btn_add = QPushButton("添加新单词")
        btn_add.setStyleSheet(PRIMARY_BUTTON_STYLE)
        btn_add.clicked.connect(self.add_word_click)
        lay.addWidget(btn_add)

        btn_mem = QPushButton("背单词")
        btn_mem.setStyleSheet(SECONDARY_BUTTON_STYLE)
        btn_mem.clicked.connect(self.memory_click)
        lay.addWidget(btn_mem)

        # ---- 列表区 ---- #
        self._list_container = QWidget()
        self._list_layout = QVBoxLayout(self._list_container)
        self._list_layout.setAlignment(Qt.AlignTop)

        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(self._list_container)
        lay.addWidget(scroll, 1)  # stretch

    # ------------------------------------------------------------------
    # 数据加载
    # ------------------------------------------------------------------
    def reload_words(self):
        self.full_words = WS.list_words(self.book_name, self.book_color)
        self._display_words(self.full_words)

    def _display_words(self, words: list[dict]):
        # 清空旧
        while self._list_layout.count():
            w = self._list_layout.takeAt(0).widget()
            if w:
                w.deleteLater()

        for wd in words:
            btn = QPushButton(str(wd["单词"]))
            btn.setFont(list_word_font)
            btn.clicked.connect(lambda _, d=wd: self.word_selected.emit(d))
            self._list_layout.addWidget(btn)

        self._list_layout.addStretch(1)

    # ------------------------------------------------------------------
    # 过滤逻辑
    # ------------------------------------------------------------------
    def _debounce_filter(self):
        if self._timer is None:
            self._timer = QTimer(self)
            self._timer.setSingleShot(True)
            self._timer.timeout.connect(self.filter_words)
        self._timer.start(300)

    def filter_words(self):
        kw = self.search_bar.text().strip().lower()
        tags = self.tag_filter_combo.selectedItems()

        def ok(w: dict):
            has_kw = kw in str(w["单词"]).lower()
            has_tag = not tags or any(t in w.get("标签", []) for t in tags)
            return has_kw and has_tag

        self._display_words([w for w in self.full_words if ok(w)])

    # ------------------------------------------------------------------
    # 初始化标签下拉
    # ------------------------------------------------------------------
    def _load_tags_to_filter(self):
        self.tag_filter_combo.clear()
        tags_path = get_tags_path(self.book_name, self.book_color)
        if not tags_path or not tags_path.endswith("tags.txt"):
            return
        try:
            with open(tags_path, "r", encoding="utf-8") as f:
                for t in f.read().splitlines():
                    self.tag_filter_combo.addItem(t)
        except FileNotFoundError:
            pass

UI/word_book_inside/word_list_panel.py结束

WordBookButton.py开始
# WordBookButton.py开始
from PySide6.QtWidgets import QPushButton, QLineEdit, QMessageBox, QMenu
from PySide6.QtGui import QColor, QPainter, QPixmap, QFont, QCursor
from PySide6.QtCore import Qt, QRect, QPoint, QPropertyAnimation, QTimer, QEasingCurve, Property, Signal, QSize
from PySide6.QtGui import QColorConstants

from PIL import Image
import os
import sys
from font import normal_font
from PySide6.QtGui import QCursor  # Ensure QCursor is imported


class WordBookButton(QPushButton):
    """自定义单词本按钮，支持拖拽、文件夹展开/折叠、子按钮拖出等交互。"""
    nameChangedNeedsLayoutSave = Signal()

    DRAG_THRESHOLD = 5  # Pixels mouse must move to be considered a drag

    def __init__(self, title: str, color: str, parent=None, app=None):  # app is CoverContent
        super().__init__(title, parent)
        self.app = app

        self.color = color
        self.path: str | None = None
        self.is_folder = False
        self.is_expanded = False
        self.is_sub_button = False
        self.parent_folder: WordBookButton | None = None
        self.sub_buttons: list[WordBookButton] = []

        self.is_dragging = False
        self.mouse_press_pos_local: QPoint | None = None  # Store local mouse position on press
        self._cursor_offset = QPoint()
        self.drag_out_threshold_exceeded = False
        self._origin_pos = QPoint()  # Original widget position before drag

        self._rotation = 0.0
        if hasattr(self.app, "button_width") and hasattr(self.app, "button_height"):
            self.setFixedSize(QSize(self.app.button_width, self.app.button_height))
        else:
            self.setFixedSize(QSize(120, 150))

        cover_font = QFont(normal_font)
        cover_font.setBold(True)
        self.setFont(cover_font)
        self.icon_size = self.app.button_width if self.app and hasattr(self.app, 'button_width') else 120

        icon_path = self.create_colored_icon(color)
        self.icon_path = icon_path
        self.icon_pixmap = QPixmap(icon_path).scaled(self.icon_size, self.icon_size, Qt.KeepAspectRatio,
                                                     Qt.SmoothTransformation)

        self.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                border: none;
                text-align: center;
                color: #333333; 
            }}
        """)

        self.name_edit = QLineEdit(self)
        self.name_edit.hide()
        self.name_edit.setAlignment(Qt.AlignCenter)
        self.name_edit.setStyleSheet(
            "QLineEdit { border: 1px solid #888; border-radius: 4px; background-color: rgba(255, 255, 255, 0.9); }")
        self.name_edit.returnPressed.connect(self.finish_name_edit)
        self.name_edit.editingFinished.connect(self.finish_name_edit)
        self.rename_source = "edit"

        self.delete_button = QPushButton("✕", self)
        self.delete_button.setFixedSize(22, 22)
        self.delete_button.setStyleSheet(
            "QPushButton { background-color: #FF4D4D; color: #FFFFFF; border: none; border-radius: 11px; font-weight: bold; } QPushButton:hover { background-color: #FF8080; }")
        self.delete_button.hide()
        self.delete_button.clicked.connect(self.on_delete_clicked)
        self.delete_button.setCursor(Qt.ArrowCursor)

        self.setMouseTracking(True)

        self._fade_opacity: float = 1.0
        self._fade_anim: QPropertyAnimation | None = None
        self._long_press_timer: QTimer | None = None
        self._suppress_dark: bool = False
        self.folder_animation_group = None
        self._recenter_timer: QTimer | None = None

        from PySide6.QtCore import QParallelAnimationGroup
        self.jitter_animation_group = QParallelAnimationGroup(self)
        self.jitter_animations = []
        if not self.is_sub_button:  # 只有主按钮才需要
            self.clicked.connect(self._on_clicked)

        # 同文件，再加一个方法
    def _on_clicked(self, checked=False):
        """
        非编辑模式下，左键单击主文件夹按钮 → 展开 / 折叠。
        其它情况（编辑模式、子按钮）交给原逻辑处理。
        """
        if self.app and not self.app.edit_mode and self.is_folder and not self.is_dragging:
            self.app.toggle_folder(self)
    @staticmethod
    def lighten_color(color_str: str, factor: float = 0.6) -> str:
        q_color = QColor(color_str)
        return q_color.lighter(120 + int(factor * 30)).name()

    def create_colored_icon(self, color: str) -> str:
        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        icon_dir = os.path.join(base_dir, "icon")
        os.makedirs(icon_dir, exist_ok=True)

        color_filename_part = color.replace("#", "")
        icon_path = os.path.join(icon_dir, f"colored_icon_{color_filename_part}.png")

        if os.path.exists(icon_path):
            return icon_path

        base_image_path = os.path.join(base_dir, "icon", "word_book_cover.webp")
        if not os.path.exists(base_image_path):
            pixmap = QPixmap(QSize(self.icon_size, self.icon_size))
            pixmap.fill(QColor(color))
            pixmap.save(icon_path)
            return icon_path

        base_image = Image.open(base_image_path).convert("RGBA")
        datas = base_image.getdata()
        new_data = []
        target_color_pil = Image.new("RGBA", (1, 1), color).getdata()[0]

        for item in datas:
            if not (item[0] > 200 and item[1] > 200 and item[2] > 200 and item[3] < 50):
                new_data.append(target_color_pil)
            else:
                new_data.append((255, 255, 255, 0))

        base_image.putdata(new_data)
        base_image.save(icon_path)
        return icon_path

    def update_folder_icon(self):
        from UI.folder_ui.api import create_folder_icon

        if not self.is_folder or not self.sub_buttons:
            if not self.is_folder and hasattr(self, 'color'):
                original_icon_path = self.create_colored_icon(self.color)
                self.icon_path = original_icon_path
                self.icon_pixmap = QPixmap(original_icon_path).scaled(self.icon_size, self.icon_size,
                                                                      Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.update()
            return

        sub_icon_paths = [sub.icon_path for sub in self.sub_buttons[:9] if hasattr(sub, 'icon_path') and sub.icon_path]
        if not sub_icon_paths:
            empty_folder_icon_path = self.create_colored_icon(self.color)
            self.icon_path = empty_folder_icon_path
            self.icon_pixmap = QPixmap(empty_folder_icon_path).scaled(self.icon_size, self.icon_size,
                                                                      Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.update()
            return

        icon_path = create_folder_icon(sub_icon_paths=sub_icon_paths, folder_name=self.text())
        self.icon_path = icon_path
        self.icon_pixmap = QPixmap(icon_path).scaled(self.icon_size, self.icon_size, Qt.KeepAspectRatio,
                                                     Qt.SmoothTransformation)
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        if self.underMouse() or (self.isDown() and not self._suppress_dark):
            bg_color_str = self.color if self.isDown() and not self._suppress_dark and self.fadeOpacity > 0.01 else WordBookButton.lighten_color(
                self.color)
            bg_qcolor = QColor(bg_color_str)
            if self.isDown() and not self._suppress_dark:
                bg_qcolor.setAlphaF(self.fadeOpacity)

            painter.setPen(Qt.NoPen)
            painter.setBrush(bg_qcolor)
            painter.drawRoundedRect(self.rect(), 15, 15)

        painter.save()
        if self._rotation != 0:
            painter.translate(self.width() / 2, self.height() / 2)
            painter.rotate(self._rotation)
            painter.translate(-self.width() / 2, -self.height() / 2)

        if hasattr(self, "icon_pixmap") and not self.icon_pixmap.isNull():
            icon_x = (self.width() - self.icon_pixmap.width()) // 2
            icon_y = 0
            painter.drawPixmap(icon_x, icon_y, self.icon_pixmap)
        else:
            painter.setBrush(QColor(self.color))
            painter.drawRect(QRect((self.width() - self.icon_size) // 2, 0, self.icon_size, self.icon_size))

        painter.setPen(
            QColorConstants.Black if self.palette().buttonText().color() == QColorConstants.White else self.palette().buttonText().color())

        text_margin_top = 5
        text_rect_y = self.icon_size + text_margin_top
        text_rect_height = self.height() - text_rect_y - 5
        text_rect = QRect(0, text_rect_y, self.width(), text_rect_height)

        fm = painter.fontMetrics()
        elided_text = fm.elidedText(self.text(), Qt.ElideRight, text_rect.width() - 10)
        painter.drawText(text_rect, Qt.AlignHCenter | Qt.AlignTop, elided_text)

        painter.restore()

    def _update_cursor(self, pos: QPoint):
        if self.app and self.app.edit_mode:
            name_rect = QRect(0, self.icon_size + 5, self.width(), self.height() - self.icon_size - 5)
            if self.delete_button.isVisible() and self.delete_button.geometry().contains(pos):
                self.setCursor(Qt.ArrowCursor)
            elif name_rect.contains(pos):
                self.setCursor(Qt.IBeamCursor)
            else:
                self.setCursor(Qt.PointingHandCursor)
        else:  # Non-edit mode
            self.setCursor(Qt.PointingHandCursor)

    def enterEvent(self, event):
        self._update_cursor(event.pos())
        super().enterEvent(event)

    def mouseDoubleClickEvent(self, event):
        if self.app and self.app.edit_mode and not getattr(self, "is_new_button", False):
            name_rect = QRect(0, self.icon_size + 5, self.width(), self.height() - self.icon_size - 5)
            if name_rect.contains(event.pos()):
                self.start_name_edit()
                return
        # In non-edit mode, or if not clicking the name area,
        # a double click should behave like a single click for folders/wordbooks
        # This is handled by the single click logic in mouseReleaseEvent if not a drag
        # No need to call super().mouseDoubleClickEvent() as it might have unintended default behavior.
        # Instead, ensure our single click logic fires.
        # Let mouseReleaseEvent handle it.
        if event.button() == Qt.LeftButton:
            pass  # Let release handle it

    def start_name_edit(self):
        if getattr(self, "is_new_button", False): return
        self.stop_jitter()
        self.name_edit.setText(self.text())
        self.name_edit.selectAll()
        y_start = self.icon_size + 5
        self.name_edit.setGeometry(0, y_start, self.width(), self.height() - y_start)
        self.name_edit.show()
        QTimer.singleShot(0, self.name_edit.setFocus)

    def finish_name_edit(self):
        if not self.name_edit.isVisible(): return

        new_name = self.name_edit.text().strip()
        self.name_edit.hide()

        if not new_name or new_name == self.text():
            if self.app.edit_mode and self.rename_source == "edit": self.start_jitter()
            return

        sibling_names = [btn.text() for btn in self.app.buttons if btn is not self and not btn.is_sub_button]
        if self.is_sub_button and self.parent_folder:
            sibling_names = [sub.text() for sub in self.parent_folder.sub_buttons if sub is not self]

        if new_name in sibling_names:
            QMessageBox.warning(self, "重名冲突", "已有同名单词本或文件夹！")
            if self.app.edit_mode and self.rename_source == "edit": self.start_jitter()
            return

        old_name = self.text()
        old_path = self.path

        self.setText(new_name)

        if not self.is_folder:
            try:
                new_path = self.rename_wordbook_directory(old_name, new_name)
                self.path = new_path
                if hasattr(self.app, 'show_word_book'):
                    try:
                        self.clicked.disconnect()
                    except RuntimeError:
                        pass
                    self.clicked.connect(lambda checked=False, p=self.path: self.app.show_word_book(p))
            except Exception as e:
                QMessageBox.warning(self, "重命名失败", f"{e}")
                self.setText(old_name)
                self.path = old_path
                if self.app.edit_mode and self.rename_source == "edit": self.start_jitter()
                return
        else:
            self.update_folder_icon()

        if self.is_sub_button and self.parent_folder:
            self.parent_folder.update_folder_icon()

        self.app.update_button_positions()
        self.nameChangedNeedsLayoutSave.emit()

        if self.app.edit_mode and self.rename_source == "edit": self.start_jitter()
        self.rename_source = "edit"

    def rename_wordbook_directory(self, old_name: str, new_name: str) -> str:
        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        books_dir = os.path.join(base_dir, "books")
        old_folder_name = f"books_{old_name}_{self.color}"
        new_folder_name = f"books_{new_name}_{self.color}"
        old_path_on_disk = os.path.join(books_dir, old_folder_name)
        new_path_on_disk = os.path.join(books_dir, new_folder_name)

        if old_path_on_disk == new_path_on_disk: return new_path_on_disk

        if os.path.exists(new_path_on_disk):
            raise FileExistsError(f"目标文件夹 '{new_folder_name}' 已存在。")
        if not os.path.exists(old_path_on_disk):
            os.makedirs(new_path_on_disk, exist_ok=True)
            from db import init_db as db_init_db
            db_init_db(os.path.join(new_path_on_disk, "wordbook.db"))
            return new_path_on_disk

        os.rename(old_path_on_disk, new_path_on_disk)
        return new_path_on_disk

    def on_delete_clicked(self):
        if getattr(self, "is_new_button", False): return
        if self.text() == "总单词册" and not self.is_sub_button:
            QMessageBox.information(self, "提示", "『总单词册』是主单词册，无法删除！")
            return

        if hasattr(self.app, 'delete_word_book'):
            self.app.delete_word_book(self)

    def start_jitter(self):
        if getattr(self, "is_new_button", False): return
        if self.jitter_animation_group.state() == QPropertyAnimation.Running: return

        self.jitter_animation_group.stop()
        self.jitter_animation_group.clear()

        duration = 200
        rotation_angle = 2.0

        anim_rot = QPropertyAnimation(self, b"rotation")
        anim_rot.setDuration(duration)
        anim_rot.setLoopCount(-1)
        anim_rot.setKeyValueAt(0, 0)
        anim_rot.setKeyValueAt(0.3, -rotation_angle)
        anim_rot.setKeyValueAt(0.5, 0)
        anim_rot.setKeyValueAt(0.7, rotation_angle)
        anim_rot.setKeyValueAt(1, 0)
        self.jitter_animation_group.addAnimation(anim_rot)

        self.jitter_animation_group.start()
        self.update_delete_button_visibility()

    def stop_jitter(self):
        if self.jitter_animation_group.state() == QPropertyAnimation.Running:
            self.jitter_animation_group.stop()
        self._rotation = 0
        self.update()
        self.update_delete_button_visibility()

    @Property(float)
    def rotation(self):
        return self._rotation

    @rotation.setter
    def rotation(self, angle):
        self._rotation = angle
        self.update()

    def update_delete_button_visibility(self):
        show = (self.app and self.app.edit_mode and \
                not getattr(self, "is_new_button", False) and \
                not (self.text() == "总单词册" and not self.is_sub_button)
                )

        self.delete_button.move(self.width() - self.delete_button.width() - 2, 2)
        self.delete_button.setVisible(show)
        if show: self.delete_button.raise_()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._start_press_effect()
            self.mouse_press_pos_local = event.position().toPoint()  # Store local press position
            self.is_dragging = False  # Assume it's a click until drag threshold is met

            if self.app and self.app.edit_mode and not getattr(self, "is_new_button", False):
                self._origin_pos = self.pos()
                cursor_global = event.globalPosition().toPoint()
                button_global_tl = self.mapToGlobal(QPoint(0, 0))
                self._cursor_offset = cursor_global - button_global_tl
                self.raise_()  # Raise button for dragging

                # Recenter timer logic only if it's a main button and collapse is needed
                if not self.is_sub_button and hasattr(self.app, 'collapse_all_folders'):
                    scroll_area = getattr(self.app, "scroll_area", None)
                    old_scroll_value = scroll_area.verticalScrollBar().value() if scroll_area else 0
                    self.app.collapse_all_folders()

                    def _reposition_after_collapse():
                        # Check if still valid to reposition (e.g., button still exists, drag ongoing)
                        if not self.is_dragging and self.mouse_press_pos_local is None:  # Check if drag started
                            self._stop_recenter_timer()
                            return
                        if not self.parentWidget():  # Safety check
                            self._stop_recenter_timer()
                            return

                        if scroll_area:
                            current_max_scroll = scroll_area.verticalScrollBar().maximum()
                            scroll_area.verticalScrollBar().setValue(min(old_scroll_value, current_max_scroll))

                        current_mouse_global = QCursor.pos()
                        target_button_global_tl = current_mouse_global - self._cursor_offset
                        new_local_pos = self.parentWidget().mapFromGlobal(target_button_global_tl)

                        if (self.pos() - new_local_pos).manhattanLength() > 1:
                            self.move(new_local_pos)

                    self._recenter_timer = QTimer(self)
                    self._recenter_timer.setInterval(10)
                    self._recenter_timer.timeout.connect(_reposition_after_collapse)
                    self._recenter_timer.start()
                    _reposition_after_collapse()  # Try immediate reposition
                    QTimer.singleShot(800, self._stop_recenter_timer)  # Safety stop
            # For non-edit mode, or "new button", we still call super.mousePressEvent
            # to get the visual "pressed" state. The actual "clicked" signal is emitted on release.
            else:
                super().mousePressEvent(event)
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        from UI.folder_ui.api import calculate_folder_area, calculate_reorder_area
        self._update_cursor(event.pos())

        if not (event.buttons() & Qt.LeftButton and self.app and self.app.edit_mode and \
                not getattr(self, "is_new_button", False)):
            # If not a drag scenario, still call super for other mouse move behaviors
            super().mouseMoveEvent(event)
            return

        # Check drag threshold if not already dragging
        if not self.is_dragging and self.mouse_press_pos_local is not None:
            if (event.position().toPoint() - self.mouse_press_pos_local).manhattanLength() > self.DRAG_THRESHOLD:
                self.is_dragging = True
                # Potentially stop recenter timer here if it was started, as manual drag takes over
                self._stop_recenter_timer()

        if not self.is_dragging:
            # If not dragging yet (threshold not met), let super handle it
            super().mouseMoveEvent(event)
            return

        # --- Actual drag movement logic ---
        current_mouse_global = event.globalPosition().toPoint()
        target_button_global_tl = current_mouse_global - self._cursor_offset

        if self.parentWidget():
            new_local_pos = self.parentWidget().mapFromGlobal(target_button_global_tl)
            self.move(new_local_pos)
        else:
            self.is_dragging = False  # Safety: stop if parent is gone
            return

        # --- Folder interaction logic (only if dragging) ---
        if self.is_sub_button and self.parent_folder:
            reorder_rect = calculate_reorder_area(
                self.parent_folder, self.app.button_width, self.app.button_height,
                self.app.spacing, self.app.scroll_content.width(), getattr(self.app, 'folder_extra_width', 0)
            )
            button_center_in_scroll_content = self.mapTo(self.app, self.rect().center())

            if reorder_rect.contains(button_center_in_scroll_content):
                self.app.show_blue_reorder_frame(self.parent_folder)
                self.app.hide_red_removal_frame()
                self.drag_out_threshold_exceeded = False
                self.app.update_sub_button_order(self.parent_folder, dragged_sub_button=self, realtime=True)
            else:
                self.app.hide_blue_reorder_frame()
                self.app.show_red_removal_frame(self.parent_folder)
                self.drag_out_threshold_exceeded = True
        else:  # Main button drag
            self.app.check_button_proximity(self)
            self.app.update_button_order(self)  # This calls animate_button_positions

    def mouseReleaseEvent(self, event):
        self._stop_recenter_timer()
        self._end_press_effect()

        was_dragging_in_edit_mode = self.is_dragging  # is_dragging is now only true if threshold met

        # Reset dragging state and press position for next interaction
        self.is_dragging = False
        current_mouse_press_pos_local = self.mouse_press_pos_local
        self.mouse_press_pos_local = None

        if event.button() == Qt.LeftButton:
            if was_dragging_in_edit_mode:
                # --- Handle drag completion ---
                if self.is_sub_button and self.parent_folder:
                    if not self.drag_out_threshold_exceeded:
                        self.app.update_sub_button_order(self.parent_folder, dragged_sub_button=self, realtime=False)
                    else:
                        self.app.remove_sub_button_from_folder(self)
                    self.app.hide_blue_reorder_frame()
                    self.app.hide_red_removal_frame()
                else:  # Main button drag completion
                    if self.app.frame_visible and self.app.is_button_in_frame(self):
                        self.app.merge_folders()
                    self.app.finalize_button_order()
                    self.app.hide_frame()

                if not self.is_sub_button:  # After main button drag
                    if hasattr(self.app, 'expand_all_folders'):
                        self.app.expand_all_folders()

                if hasattr(self.app, 'controller') and hasattr(self.app.controller, 'save_current_layout'):
                    self.app.controller.save_current_layout()

                self.setDown(False)  # Reset visual pressed state
                self.update()
                return  # IMPORTANT: Do not fall through to super for drag operations

            # --- Handle click (not a drag, or not in edit mode drag) ---
            # A click is defined as press and release inside the button without significant movement.
            # QPushButton's default mouseReleaseEvent implementation handles emitting 'clicked()'
            # if the release is within bounds.
            else:
                # If it's a "new button", let the controller handle its specific click.
                # For other buttons, the controller also connects the `clicked` signal.
                # So, allowing super.mouseReleaseEvent() should be correct for all click types.
                if self.rect().contains(event.position().toPoint()):  # Ensure release is inside
                    super().mouseReleaseEvent(event)  # This emits clicked()
                else:  # Released outside, don't emit clicked, just reset state
                    self.setDown(False)
                    self.update()

        else:  # Not a left button release
            super().mouseReleaseEvent(event)

        # General cleanup for any release scenario if not returned earlier
        self.setDown(False)
        self.update()

    def _start_press_effect(self):
        self._suppress_dark = False
        self.fadeOpacity = 1.0
        if self._fade_anim and self._fade_anim.state() == QPropertyAnimation.Running:
            self._fade_anim.stop()
        if self._long_press_timer: self._long_press_timer.stop()

        self._long_press_timer = QTimer(self)
        self._long_press_timer.setSingleShot(True)
        self._long_press_timer.timeout.connect(self._disable_darkening_after_delay)
        self._long_press_timer.start(100)

    def _end_press_effect(self):
        if self._long_press_timer: self._long_press_timer.stop()
        if not self._suppress_dark and self.fadeOpacity > 0.01:
            if self._fade_anim and self._fade_anim.state() == QPropertyAnimation.Running:
                self._fade_anim.stop()

            self._fade_anim = QPropertyAnimation(self, b"fadeOpacity")
            self._fade_anim.setDuration(150)
            self._fade_anim.setEasingCurve(QEasingCurve.OutQuad)
            self._fade_anim.setStartValue(self.fadeOpacity)
            self._fade_anim.setEndValue(0.0)
            self._fade_anim.finished.connect(lambda: setattr(self, '_suppress_dark', True))
            self._fade_anim.start()
        else:
            self.fadeOpacity = 0.0
            self._suppress_dark = True

    def _disable_darkening_after_delay(self):
        if self.isDown():
            if self._fade_anim and self._fade_anim.state() == QPropertyAnimation.Running:
                self._fade_anim.stop()

            self._fade_anim = QPropertyAnimation(self, b"fadeOpacity")
            self._fade_anim.setDuration(180)
            self._fade_anim.setEasingCurve(QEasingCurve.OutQuad)
            self._fade_anim.setStartValue(self.fadeOpacity)
            self._fade_anim.setEndValue(0.0)
            self._fade_anim.finished.connect(lambda: setattr(self, '_suppress_dark', True))
            self._fade_anim.start()

    @Property(float)
    def fadeOpacity(self) -> float:
        return self._fade_opacity

    @fadeOpacity.setter
    def fadeOpacity(self, value: float):
        self._fade_opacity = value
        self.update()

    def _stop_recenter_timer(self):
        if hasattr(self, "_recenter_timer") and self._recenter_timer:
            if self._recenter_timer.isActive():
                self._recenter_timer.stop()
            self._recenter_timer.deleteLater()
            self._recenter_timer = None
# WordBookButton.py结束
WordBookButton.py结束

add_new_word.py开始
# add_new_word.py
import sys
import os
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLineEdit, QLabel, QPushButton, QHBoxLayout, QMessageBox,
    QInputDialog, QGridLayout, QFrame, QTextEdit, QScrollArea, QCheckBox
)
from PySide6.QtCore import Signal

from datetime import datetime

from font import meaning_font, word_font
from utils import get_tags_path, get_total_tags_path
from services.wordbook_service import WordBookService as WS
from styles import GREEN_BUTTON_STYLE, RED_BUTTON_STYLE, GRAY_INPUT_STYLE, GRAY_TEXT_EDIT_STYLE, PRIMARY_BUTTON_STYLE, \
    SECONDARY_BUTTON_STYLE


class WordEntryUI(QWidget):
    save_successful = Signal(dict)
    def __init__(self, path):
        super(WordEntryUI, self).__init__()
        self.path = path  # 保存传入的路径
        self.book_name = os.path.basename(path).split('_')[1]
        self.book_color = os.path.basename(path).split('_')[2]

        self.setWindowTitle("新单词")
        self.resize(800, 700)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)

        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)

        self.layout = QVBoxLayout()

        # 单词
        self.word_layout = QHBoxLayout()
        self.word_label = QLabel("单词:")
        self.word_label.setFont(word_font)
        self.word_input = QLineEdit()
        self.word_input.setFixedSize(400, 30)
        self.word_input.setStyleSheet(GRAY_INPUT_STYLE)
        self.word_layout.addWidget(self.word_label)
        self.word_layout.addWidget(self.word_input)
        self.scroll_layout.addLayout(self.word_layout)

        # 相关单词
        self.related_layout = QVBoxLayout()
        self.related_layout.setSpacing(10)
        self.related_items = [self.add_related_input_field(0)]
        self.add_related_button = QPushButton("+")
        self.add_related_button.setFixedSize(30, 30)
        self.add_related_button.setStyleSheet(GREEN_BUTTON_STYLE) # 加号按钮样式
        self.add_related_button.clicked.connect(self.add_related_input_row)
        self.remove_related_button = QPushButton("-")
        self.remove_related_button.setFixedSize(30, 30)
        self.remove_related_button.setStyleSheet(RED_BUTTON_STYLE) # 减号按钮样式
        self.remove_related_button.clicked.connect(self.remove_related_input_row)
        button_layout = QHBoxLayout()
        button_layout.addWidget(self.add_related_button)
        button_layout.addWidget(self.remove_related_button)
        self.scroll_layout.addLayout(self.related_layout)
        self.scroll_layout.addLayout(button_layout)

        # Separator
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        self.scroll_layout.addWidget(line)

        # 释义和例句
        self.meaning_example_layout = QVBoxLayout()
        self.meaning_example_grid = QGridLayout()
        self.meaning_inputs = [self.add_meaning_example_pair(0)]
        self.add_meaning_button = QPushButton("+")
        self.add_meaning_button.setFixedSize(30, 30)
        self.add_meaning_button.setStyleSheet(GREEN_BUTTON_STYLE) # 加号按钮样式
        self.add_meaning_button.clicked.connect(self.add_meaning_example_row)
        self.remove_meaning_button = QPushButton("-")
        self.remove_meaning_button.setFixedSize(30, 30)
        self.remove_meaning_button.setStyleSheet(RED_BUTTON_STYLE) # 减号按钮样式
        self.remove_meaning_button.clicked.connect(self.remove_meaning_example_row)
        self.meaning_example_layout.addLayout(self.meaning_example_grid)
        self.meaning_button_layout = QHBoxLayout()
        self.meaning_button_layout.addWidget(self.add_meaning_button)
        self.meaning_button_layout.addWidget(self.remove_meaning_button)
        self.meaning_example_layout.addLayout(self.meaning_button_layout)
        self.scroll_layout.addLayout(self.meaning_example_layout)

        # 备注
        self.note_layout = QHBoxLayout()
        self.note_label = QLabel("备注:")
        self.note_input = QTextEdit()
        self.note_input.setFixedSize(400, 90)
        self.note_input.setStyleSheet(GRAY_TEXT_EDIT_STYLE)
        self.note_layout.addWidget(self.note_label)
        self.note_layout.addWidget(self.note_input)
        self.scroll_layout.addLayout(self.note_layout)

        # 标签
        self.tag_label = QLabel("标签:")
        self.scroll_layout.addWidget(self.tag_label)

        self.tag_scroll_area = QScrollArea()
        self.tag_scroll_area.setWidgetResizable(True)
        self.tag_widget = QWidget()
        self.tag_layout = QVBoxLayout(self.tag_widget)
        self.tag_scroll_area.setWidget(self.tag_widget)

        self.new_tag_button = QPushButton("新建标签")
        self.new_tag_button.clicked.connect(self.add_new_tag)
        self.new_tag_button.setStyleSheet(PRIMARY_BUTTON_STYLE)

        self.scroll_layout.addWidget(self.tag_scroll_area)
        self.scroll_layout.addWidget(self.new_tag_button)
        self.load_tags()

        # 保存和取消按钮
        self.button_layout = QHBoxLayout()
        self.save_button = QPushButton("保存")
        self.cancel_button = QPushButton("取消")
        self.cancel_button.setStyleSheet(RED_BUTTON_STYLE)  # 取消按钮样式
        self.cancel_button.clicked.connect(self.close)
        self.save_button.setStyleSheet(SECONDARY_BUTTON_STYLE) # 保存按钮样式
        self.button_layout.addWidget(self.save_button)
        self.button_layout.addWidget(self.cancel_button)
        self.save_button.setFixedSize(80, 30)
        self.cancel_button.setFixedSize(80, 30)
        self.scroll_layout.addLayout(self.button_layout)

        self.save_button.clicked.connect(self.save_word)

        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)
        self.setLayout(self.layout)

    def add_meaning_example_pair(self, row):
        """
        新建“释义-例句”输入对，并在其上方预留隐藏的错误提示标签。
        每个输入对占两行：第 1 行放错误提示，第 2 行放输入控件。
        """
        base_row = row * 2  # 每对控件预留两行
        # ---------- 错误提示 ----------
        meaning_err = QLabel("")
        meaning_err.setStyleSheet("color: red;")
        meaning_err.hide()
        example_err = QLabel("")
        example_err.setStyleSheet("color: red;")
        example_err.hide()
        self.meaning_example_grid.addWidget(meaning_err, base_row, 1)
        self.meaning_example_grid.addWidget(example_err, base_row, 3)

        # ---------- 输入控件 ----------
        meaning_label = QLabel(f"释义{row + 1}:")
        meaning_label.setFont(meaning_font)
        meaning_input = QLineEdit()
        meaning_input.setFixedSize(180, 30)
        meaning_input.setStyleSheet(GRAY_INPUT_STYLE)

        example_label = QLabel(f"例句{row + 1}:")
        example_input = QTextEdit()
        example_input.setFixedSize(300, 90)
        example_input.setStyleSheet(GRAY_TEXT_EDIT_STYLE)

        self.meaning_example_grid.addWidget(meaning_label, base_row + 1, 0)
        self.meaning_example_grid.addWidget(meaning_input, base_row + 1, 1)
        self.meaning_example_grid.addWidget(example_label, base_row + 1, 2)
        self.meaning_example_grid.addWidget(example_input, base_row + 1, 3)

        return (meaning_input, example_input, meaning_err, example_err)

    def add_meaning_example_row(self):
        row = len(self.meaning_inputs)
        self.meaning_inputs.append(self.add_meaning_example_pair(row))

    def remove_meaning_example_row(self):
        if len(self.meaning_inputs) > 1:
            row = len(self.meaning_inputs) - 1
            for i in range(4):
                widget = self.meaning_example_grid.itemAtPosition(row, i).widget()
                if widget:
                    widget.deleteLater()
            self.meaning_inputs.pop()

    def add_related_input_field(self, index):
        layout = QHBoxLayout()
        label = QLabel(f"相关单词{index + 1}:")
        input_field = QLineEdit()
        input_field.setFixedSize(400, 30)
        input_field.setStyleSheet(GRAY_INPUT_STYLE)
        layout.addWidget(label)
        layout.addWidget(input_field)
        self.related_layout.addLayout(layout)
        return (layout, label, input_field)

    def add_related_input_row(self):
        index = len(self.related_items)
        self.related_items.append(self.add_related_input_field(index))

    def remove_related_input_row(self):
        if len(self.related_items) > 1:
            layout, label, input_field = self.related_items.pop()
            label.deleteLater()
            input_field.deleteLater()
            layout.deleteLater()

    def load_tags(self):
        if hasattr(self, 'tag_checkboxes'):
            for checkbox in self.tag_checkboxes:
                checkbox.setParent(None)
        self.tag_checkboxes = []
        tags_path = get_tags_path(self.book_name, self.book_color)
        if os.path.exists(tags_path):
            with open(tags_path, "r", encoding="utf-8") as file:
                tags = file.read().splitlines()
                for tag in tags:
                    tag_checkbox = QCheckBox(tag)
                    self.tag_layout.addWidget(tag_checkbox)
                    self.tag_checkboxes.append(tag_checkbox)

    def add_new_tag(self):
        tag, ok = QInputDialog.getText(self, "新建标签", "输入新标签:")
        if ok and tag:
            tags_path = get_tags_path(self.book_name, self.book_color)
            if os.path.exists(tags_path):
                with open(tags_path, "r", encoding="utf-8") as file:
                    existing_tags = file.read().splitlines()
            else:
                existing_tags = []

            if tag in existing_tags:
                QMessageBox.warning(self, "警告", "该标签已存在！", QMessageBox.Ok)
            else:
                with open(tags_path, "a", encoding="utf-8") as file:
                    file.write(tag + "\n")
                self.load_tags()
                for checkbox in self.tag_checkboxes:
                    if checkbox.text() == tag:
                        checkbox.setChecked(True)

                # 更新总单词册中的标签文件
                total_tags_path = get_total_tags_path()
                os.makedirs(os.path.dirname(total_tags_path), exist_ok=True)
                if os.path.exists(total_tags_path):
                    with open(total_tags_path, "r", encoding="utf-8") as file:
                        total_existing_tags = file.read().splitlines()
                else:
                    total_existing_tags = []

                if tag not in total_existing_tags:
                    with open(total_tags_path, "a", encoding="utf-8") as file:
                        file.write(tag + "\n")

    def save_word(self):
        """
        校验并保存单词。
        - 校验失败 → 在对应输入框上方显示红色“*该内容为必填字段”，弹窗提示但窗口保持开启
        - 校验成功 → 保存→发射 save_successful 信号→弹窗提示→关闭窗口
        """
        try:
            # ---------- 0. 先清空旧错误提示 ----------
            for tup in self.meaning_inputs:
                if len(tup) >= 4:
                    _, _, err_m, err_e = tup
                    err_m.hide();
                    err_m.setText("")
                    err_e.hide();
                    err_e.setText("")

            # ---------- 1. 收集字段 ----------
            word = self.word_input.text().strip()
            related = [w.text().strip() for _, _, w in self.related_items if w.text().strip()]
            tags = [c.text() for c in self.tag_checkboxes if c.isChecked()]
            note = self.note_input.toPlainText().strip()
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # ---------- 2. 校验释义-例句成对必填 ----------
            meanings, examples = [], []
            valid = True
            for meaning_inp, example_inp, err_m, err_e in self.meaning_inputs:
                m = meaning_inp.text().strip()
                e = example_inp.toPlainText().strip()

                if m and not e:  # 释义有值，例句缺失
                    err_e.setText("*该内容为必填字段")
                    err_e.show()
                    valid = False
                elif e and not m:  # 例句有值，释义缺失
                    err_m.setText("*该内容为必填字段")
                    err_m.show()
                    valid = False

                meanings.append(m)
                examples.append(e)

            # 过滤出真正成对的数据
            paired = [(m, e) for m, e in zip(meanings, examples) if m and e]

            # ---------- 3. 其它必填校验 ----------
            if not word:
                QMessageBox.warning(self, "警告", "单词不能为空！", QMessageBox.Ok)
                return
            if not paired:  # 全部为空或都不成对
                QMessageBox.warning(self, "警告", "至少填写一对释义和例句！", QMessageBox.Ok)
                return
            if not valid:  # 有红色提示，停止保存
                return

            # ---------- 4. 组织并保存 ----------
            data = {
                "单词": word,
                "相关单词": related,
                "标签": tags,
                "释义": [m for m, _ in paired],
                "例句": [e for _, e in paired],
                "备注": note,
                "时间": timestamp,
            }

            WS.save_word(self.book_name, self.book_color, data)

            # ---------- 5. 成功操作 ----------
            self.save_successful.emit(data)  # 发射信号，供父窗口刷新
            QMessageBox.information(self, "成功", "单词保存成功！", QMessageBox.Ok)
            self.close()

        except PermissionError:
            QMessageBox.warning(self, "错误", "无法写入文件，请检查文件占用或权限。", QMessageBox.Ok)
        except Exception as e:
            QMessageBox.critical(self, "错误", f"保存单词时发生错误：{e}", QMessageBox.Ok)

def show_word_entry_ui():
    app = QApplication(sys.argv)
    window = WordEntryUI()
    window.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    show_word_entry_ui()
add_new_word.py结束

controllers/cover_controller.py开始
# controllers/cover_controller.py开始
from __future__ import annotations
import os
import sys
from PySide6.QtCore import QObject, QEvent, Slot, Qt, QUrl, QTimer  # Added QTimer
from PySide6.QtWidgets import QMenu, QMessageBox
from PySide6.QtGui import QDesktopServices

from UI.word_book_cover.cover_view import CoverView
from services.folder_service import FolderService
from services.cover_layout_service import CoverLayoutService
from UI.word_book_button import WordBookButton
from UI.word_book_inside.word_book_window import WordBookWindow
from db import delete_word as db_delete_word_directly, init_db as db_init_db
import shutil


class CoverController(QObject):
    def __init__(self, view: CoverView) -> None:
        super().__init__()
        self.view: CoverView = view
        self.fs: FolderService = FolderService()
        self.ls: CoverLayoutService = CoverLayoutService()
        self.edit_mode: bool = False
        self._child_windows: list[WordBookWindow] = []

        self.view.content.controller = self  # Link controller to content for callbacks

        v = self.view
        v.editToggled.connect(self._set_edit_mode)
        v.searchTextChanged.connect(self._on_search_text)
        v.suggestionSelected.connect(self._open_word_by_text)

        self._load_buttons_and_layout()
        self._build_word_index()
        v.scroll_area.viewport().installEventFilter(self)
        view.destroyed.connect(lambda *_: view.scroll_area.viewport().removeEventFilter(self))

    def _get_content_buttons(self) -> list[WordBookButton]:
        """Helper to get the current list of main buttons from CoverContent."""
        return getattr(self.view.content, 'buttons', [])

    from UI.word_book_button import WordBookButton
    from PySide6.QtCore import Qt, QTimer
    from PySide6.QtWidgets import QMenu

    # ... 省略类头与其它方法 ...

    def _load_buttons_and_layout(self) -> None:
        """刷新 Cover 页面按钮 + 布局。"""
        self.view.clear_wordbook_buttons()

        # 1) 扫描磁盘生成按钮
        scanned = self.fs.build_buttons(self.view.content)

        # 2) “新建单词本”按钮
        nb = self.view.content.new_book_button
        try: nb.clicked.disconnect()
        except (RuntimeError, TypeError): pass
        nb.clicked.connect(self._create_wordbook)
        self._wire_context_menu(nb)
        self.view.add_wordbook_button(nb)           # 一定要 add！

        # 3) 把扫描到的按钮逐一塞进 CoverContent
        for btn in scanned:
            self._wire_context_menu(btn)
            self.view.add_wordbook_button(btn)      # ★ 关键：真正 attach

        # 4) 还原布局顺序
        layout = self.ls.load()
        if layout:
            self.fs.apply_layout(layout, self.view.content.buttons)

        self.view.content.update_button_positions()

        # ------------------- 工具：右键菜单挂接 ------------------- #
    def _wire_context_menu(self, btn: WordBookButton) -> None:
        try:
            btn.customContextMenuRequested.disconnect()
        except (RuntimeError, TypeError):
            pass
        btn.setContextMenuPolicy(Qt.CustomContextMenu)
        btn.customContextMenuRequested.connect(
            lambda pos, b=btn: self._show_button_context_menu(pos, b)
        )

    def _handle_folder_click(self, button: WordBookButton):
        if not self.edit_mode and button.is_folder:
            self.view.content.toggle_folder(button)
        # If in edit mode, clicking a folder does nothing (drag is primary interaction)

    def _show_button_context_menu(self, pos, button: WordBookButton):
        is_the_new_book_btn_widget = hasattr(self.view.content, 'new_book_button') and \
                                     button is self.view.content.new_book_button

        if is_the_new_book_btn_widget and not self.edit_mode:
            return

        menu = QMenu(self.view)
        if self.edit_mode and not is_the_new_book_btn_widget:
            rename_action = menu.addAction("重命名")
            rename_action.triggered.connect(lambda: self._rename_button(button))

        if not is_the_new_book_btn_widget:
            delete_action = menu.addAction("删除")
            delete_action.triggered.connect(lambda: self.delete_word_book(button))

        if not button.is_folder and hasattr(button, 'path') and button.path and not is_the_new_book_btn_widget:
            open_folder_action = menu.addAction("打开文件位置")
            open_folder_action.triggered.connect(lambda: self._open_book_location(button))

        if menu.actions():
            menu.exec_(button.mapToGlobal(pos))

    def _rename_button(self, button: WordBookButton):
        button.rename_source = "context_menu"
        button.start_name_edit()

    def _open_book_location(self, button: WordBookButton):
        if button.path and os.path.exists(button.path):
            QDesktopServices.openUrl(QUrl.fromLocalFile(button.path))
        else:
            QMessageBox.warning(self.view, "错误", "找不到单词本文件夹路径。")

    def delete_word_book(self, button_to_delete: WordBookButton):
        if button_to_delete.text() == "总单词册" and not button_to_delete.is_sub_button:
            QMessageBox.information(self.view, "提示", "『总单词册』是主单词册，无法删除！")
            return

        confirm = QMessageBox.question(self.view, "确认删除",
                                       f"确定要删除 '{button_to_delete.text()}' 吗？\n此操作不可恢复！",
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                       QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.No: return

        content = self.view.content

        if button_to_delete.is_sub_button and button_to_delete.parent_folder:
            parent = button_to_delete.parent_folder
            if button_to_delete in parent.sub_buttons:
                parent.sub_buttons.remove(button_to_delete)
            try:
                # Assuming db_delete_word_directly handles cases where book/color might not exist
                db_delete_word_directly(button_to_delete.text(), button_to_delete.color, "%")  # Deletes all words
                if button_to_delete.path and os.path.isdir(button_to_delete.path):
                    shutil.rmtree(button_to_delete.path)
            except Exception as e:
                QMessageBox.warning(self.view, "删除子项文件失败", f"删除 '{button_to_delete.text()}' 的文件失败: {e}")

            button_to_delete.deleteLater()
            parent.update_folder_icon()

            from UI.folder_ui._operations import _internal_check_and_remove_folder_if_needed
            _internal_check_and_remove_folder_if_needed(parent, content.buttons, content.scroll_content)

        else:  # Main button (folder or wordbook)
            if button_to_delete in content.buttons:
                content.buttons.remove(button_to_delete)

            if button_to_delete.is_folder:
                for sub_btn in button_to_delete.sub_buttons:
                    try:
                        db_delete_word_directly(sub_btn.text(), sub_btn.color, "%")
                        if sub_btn.path and os.path.isdir(sub_btn.path):
                            shutil.rmtree(sub_btn.path)
                    except Exception as e:
                        QMessageBox.warning(self.view, "删除子项文件失败",
                                            f"删除文件夹内 '{sub_btn.text()}' 的文件失败: {e}")
                    sub_btn.deleteLater()
            else:  # Single wordbook
                try:
                    db_delete_word_directly(button_to_delete.text(), button_to_delete.color, "%")
                    if button_to_delete.path and os.path.isdir(button_to_delete.path):
                        shutil.rmtree(button_to_delete.path)
                except Exception as e:
                    QMessageBox.warning(self.view, "删除文件失败", f"删除 '{button_to_delete.text()}' 的文件失败: {e}")

            if hasattr(button_to_delete, 'background_frame') and button_to_delete.background_frame:
                button_to_delete.background_frame.deleteLater()
            button_to_delete.deleteLater()

        content.update_button_positions()
        self.save_current_layout()
        self._build_word_index()

    def _build_word_index(self) -> None:
        self.word_index: dict[str, list[tuple[str, str]]] = {}  # word_text_lc -> [(path, book_display_name)]

        buttons_to_index = []
        for btn_or_folder in self._get_content_buttons():  # Use current buttons from content
            if getattr(btn_or_folder, 'is_new_button', False): continue
            if btn_or_folder.is_folder:
                buttons_to_index.extend(b for b in btn_or_folder.sub_buttons if hasattr(b, 'path') and b.path)
            elif hasattr(btn_or_folder, 'path') and btn_or_folder.path:
                buttons_to_index.append(btn_or_folder)

        from services import WordBookService  # Local import
        for btn in buttons_to_index:
            if not (hasattr(btn, 'text') and hasattr(btn, 'color') and btn.path): continue
            try:
                words_in_book = WordBookService.list_words(btn.text(), btn.color)
                for w_data in words_in_book:
                    word_text = str(w_data.get("单词", "")).strip().lower()
                    if not word_text: continue
                    self.word_index.setdefault(word_text, []).append((btn.path, btn.text()))
            except Exception:  # pylint: disable=broad-except
                # Log error if necessary, but continue building index
                # print(f"Error indexing book {btn.text()}: {e}")
                pass

    def _on_search_text(self, text: str) -> None:
        text_l = text.strip().lower()
        self.fs.highlight_search(text, self._get_content_buttons())  # Pass current buttons

        if not text_l:
            self.view.hide_suggestions()
            return
        matches = [w for w in self.word_index if text_l in w][:50]
        self.view.show_suggestions(matches)

    def _open_word_by_text(self, word: str) -> None:
        path_bookname_pairs = self.word_index.get(word.lower(), [])
        if not path_bookname_pairs: return

        if len(path_bookname_pairs) == 1:
            self._open_wordbook(path_bookname_pairs[0][0], target_word=word)
            return

        menu = QMenu(self.view)
        for path_to_open, book_display_name in path_bookname_pairs:
            act = menu.addAction(f"在 '{book_display_name}' 中打开")
            act.triggered.connect(lambda checked=False, p=path_to_open, t=word: self._open_wordbook(p, target_word=t))

        global_pos = self.view.search_bar.mapToGlobal(self.view.search_bar.rect().bottomLeft())
        menu.exec_(global_pos)

    @Slot()
    def save_current_layout(self):
        layout_to_save = self.fs.export_layout(self._get_content_buttons())
        self.ls.save(layout_to_save)

    def _set_edit_mode(self, entering: bool) -> None:
        self.edit_mode = entering
        self.view.content.edit_mode = entering

        all_main_buttons = self._get_content_buttons()

        # Handle jitter for main buttons and the "New Book" button
        buttons_for_main_jitter = all_main_buttons[:]
        if hasattr(self.view.content, 'new_book_button'):
            buttons_for_main_jitter.append(self.view.content.new_book_button)

        for b in buttons_for_main_jitter:
            if entering:
                b.start_jitter()
            else:
                b.stop_jitter()

        if entering:
            # Expand all folders and then handle sub-button jitter
            for btn in all_main_buttons:
                if btn.is_folder:
                    if not btn.is_expanded:
                        # toggle_folder sets btn.is_expanded to True (target state)
                        self.view.content.toggle_folder(btn)
                    # Jitter sub-buttons if the folder is (or will be) expanded
                    # Need to check is_expanded *after* toggle_folder might have changed it
                    # and its animation starts. A slight delay might be needed if toggle_folder
                    # is fully async for state change.
                    # However, toggle_folder in FolderAnimationMixin sets is_expanded synchronously.
                    if btn.is_expanded:  # Check the target state
                        for sub_b in btn.sub_buttons:
                            sub_b.start_jitter()
        else:  # Exiting edit mode
            if hasattr(self.view.content, 'collapse_all_folders'):
                self.view.content.collapse_all_folders()

            # Stop jitter for all sub-buttons, regardless of folder state
            for btn in all_main_buttons:
                if btn.is_folder:
                    for sub_b in btn.sub_buttons:
                        sub_b.stop_jitter()

            self.save_current_layout()

    def _create_wordbook(self) -> None:
        success, book_name, book_color = self.fs.show_new_wordbook_dialog()
        if success and book_name and book_color:
            base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
            books_dir = os.path.join(base_dir, "books")
            new_book_folder_name = f"books_{book_name}_{book_color}"
            new_book_path = os.path.join(books_dir, new_book_folder_name)

            if os.path.exists(new_book_path):
                QMessageBox.warning(self.view, "创建失败", f"名为 '{book_name}' 的单词本已存在。")
                return
            try:
                os.makedirs(new_book_path, exist_ok=True)
                db_init_db(os.path.join(new_book_path, "wordbook.db"))
            except Exception as e:
                QMessageBox.warning(self.view, "创建失败", f"创建单词本目录或数据库失败: {e}")
                return

            self._load_buttons_and_layout()  # Reload everything to include the new book
            self._build_word_index()  # Rebuild index
            self.save_current_layout()  # Save new layout with the new book

    def _open_wordbook(self, path: str, target_word: str | None = None) -> None:
        # Allow opening folders even in edit mode for inspection (though not typical interaction)
        # Main check is usually on WordBookButton's click handler for non-folder items.
        # If self.edit_mode is True, WordBookButton's own click (if connected to this) might be blocked
        # by its own logic if it's not a folder.

        # This method is primarily for non-folder buttons or when programmatically opening.
        if self.edit_mode:
            # Check if the button associated with this path is a folder
            # This is a bit indirect. Better to check on the button itself.
            # For now, assume if _open_wordbook is called directly, we intend to open.
            pass  # Allow opening for now, WordBookButton click handles edit mode prevention better

        win = WordBookWindow(path, target_word=target_word)
        self._child_windows.append(win)
        win.setAttribute(Qt.WA_DeleteOnClose)
        win.destroyed.connect(lambda obj=win: self._child_windows.remove(obj) if obj in self._child_windows else None)
        win.show()

    def eventFilter(self, obj, event: QEvent) -> bool:
        if obj is self.view.scroll_area.viewport() and event.type() == QEvent.Type.Resize:
            if hasattr(self.view.content, 'update_button_positions'):
                # Use a QTimer to avoid potential resize loops or acting on intermediate sizes
                QTimer.singleShot(0, self.view.content.update_button_positions)
        return super().eventFilter(obj, event)

# controllers/cover_controller.py结束
controllers/cover_controller.py结束

controllers/wordbook_button_controller.py开始
from __future__ import annotations


from services.wordbook_service import WordBookService
from UI.word_book_button import WordBookButtonViewModel


class WordBookButtonController:
    """
    Orchestrates high-level use-cases for a WordBook button.
    Receives ‘intent’ signals from the ViewModel and delegates to Service.
    """

    def __init__(
        self,
        vm: WordBookButtonViewModel,
        service: WordBookService | None = None,
    ) -> None:
        self._vm = vm
        self._service = service or WordBookService.get_instance()

        # Wire VM-level signals ➜ local handlers
        vm.rename_requested.connect(self._handle_rename)
        vm.delete_requested.connect(self._handle_delete)
        vm.open_requested.connect(self._handle_open)

    # --------------------------------------------------------------------- #
    # Signal handlers
    # --------------------------------------------------------------------- #
    def _handle_rename(self, new_name: str) -> None:
        """Rename the underlying WordBook then tell VM to update its state."""
        updated = self._service.rename(self._vm.book, new_name)
        self._vm.update_domain(updated)

    def _handle_delete(self) -> None:
        """Delete the WordBook and tell VM/UI to reflect the removal."""
        self._service.delete(self._vm.book)
        self._vm.notify_deleted()

    def _handle_open(self) -> None:
        """Open the book in its dedicated editor/window."""
        # 你可在 Service 层实现更复杂的逻辑；这里简单转给 VM。
        self._vm.open_in_editor()


__all__ = ["WordBookButtonController"]

controllers/wordbook_button_controller.py结束

cover.py开始
# word_book_cover.py – 程序入口
import sys
from PySide6.QtWidgets import QApplication
from UI.word_book_cover.cover_view import CoverView
from controllers.cover_controller import CoverController   # ← 路径未变

def main() -> None:
    app  = QApplication(sys.argv)
    view = CoverView()
    CoverController(view)   # 保持引用即可
    view.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

cover.py结束

db.py开始
# db.py
import os
import sys
import sqlite3
import json
from datetime import datetime

def get_db_path(book_name, color):
    """
    获取SQLite数据库文件路径
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        str: 数据库文件路径
    """
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    directory = os.path.join(base_dir, "books")
    os.makedirs(directory, exist_ok=True)
    folder_name = f"books_{book_name}_{color}"
    path = os.path.join(directory, folder_name)
    os.makedirs(path, exist_ok=True)
    return os.path.join(path, "wordbook.db")

def get_total_db_path():
    """
    获取总单词本数据库路径
    
    Returns:
        str: 总单词本数据库路径
    """
    return get_db_path("总单词册", "#FF0000")

def init_db(db_path):
    """
    初始化数据库，创建必要的表
    
    Args:
        db_path (str): 数据库文件路径
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # 创建单词表
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS words (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        word TEXT NOT NULL,
        meanings TEXT NOT NULL,  -- JSON格式存储释义列表
        examples TEXT,           -- JSON格式存储例句列表
        related_words TEXT,      -- JSON格式存储相关单词列表
        tags TEXT,               -- JSON格式存储标签列表
        note TEXT,               -- 备注
        timestamp TEXT,          -- 时间戳
        UNIQUE(word)
    )
    ''')
    
    # 创建标签表
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tag TEXT NOT NULL UNIQUE
    )
    ''')
    
    conn.commit()
    conn.close()

def get_connection(book_name, color):
    """
    获取数据库连接
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        sqlite3.Connection: 数据库连接对象
    """
    db_path = get_db_path(book_name, color)
    init_db(db_path)  # 确保数据库和表已创建
    return sqlite3.connect(db_path)

def load_words(book_name, color):
    """
    从数据库加载单词数据
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        list: 单词数据列表
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        cursor.execute("SELECT word, meanings, examples, related_words, tags, note, timestamp FROM words")
        rows = cursor.fetchall()
        
        words = []
        for row in rows:
            word, meanings, examples, related_words, tags, note, timestamp = row
            word_data = {
                "单词": word,
                "释义": json.loads(meanings),
                "例句": json.loads(examples) if examples else [],
                "相关单词": json.loads(related_words) if related_words else [],
                "标签": json.loads(tags) if tags else [],
                "备注": note if note else "",
                "时间": timestamp
            }
            words.append(word_data)
            
        conn.close()
        return words
    except Exception as e:
        print(f"Error loading words from database: {e}")
        return []

def save_word(book_name, color, data, sync_to_total=True):
    """
    保存 / 更新单词数据到数据库（『覆盖式』）。
    · 若单词不存在 ——> 直接插入
    · 若单词已存在 ——> 以最新提交的数据完全覆盖旧记录
      —— 这样才能正确处理『删除释义 / 例句』等编辑场景。
    """
    try:
        conn    = get_connection(book_name, color)
        cursor  = conn.cursor()

        # ---------- 1) 整理并去重 ----------
        word         = data["单词"]
        new_meanings = list(dict.fromkeys(data["释义"]))                # 去重但保持顺序
        new_examples = data.get("例句", [])
        new_related  = list(dict.fromkeys(data.get("相关单词", [])))
        new_tags     = list(dict.fromkeys(data.get("标签", [])))
        note         = data.get("备注", "")
        timestamp    = data.get("时间", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        # 例句条数不足时用空串占位，保证与释义等长
        if len(new_examples) < len(new_meanings):
            new_examples += [""] * (len(new_meanings) - len(new_examples))

        # ---------- 2) 查询是否已存在 ----------
        cursor.execute("SELECT id FROM words WHERE word = ?", (word,))
        row = cursor.fetchone()

        # ---------- 3) 覆盖更新 / 新增 ----------
        if row:        # ---- 更新 ----
            word_id = row[0]
            cursor.execute("""
                UPDATE words SET
                    meanings      = ?,
                    examples      = ?,
                    related_words = ?,
                    tags          = ?,
                    note          = ?,
                    timestamp     = ?
                WHERE id = ?
            """, (
                json.dumps(new_meanings, ensure_ascii=False),
                json.dumps(new_examples, ensure_ascii=False),
                json.dumps(new_related, ensure_ascii=False),
                json.dumps(new_tags,    ensure_ascii=False),
                note,
                timestamp,
                word_id
            ))
        else:          # ---- 插入 ----
            cursor.execute("""
                INSERT INTO words (
                    word, meanings, examples, related_words, tags, note, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (
                word,
                json.dumps(new_meanings, ensure_ascii=False),
                json.dumps(new_examples, ensure_ascii=False),
                json.dumps(new_related,  ensure_ascii=False),
                json.dumps(new_tags,     ensure_ascii=False),
                note,
                timestamp
            ))

        # ---------- 4) 新标签入库 ----------
        for tag in new_tags:
            cursor.execute("INSERT OR IGNORE INTO tags (tag) VALUES (?)", (tag,))

        conn.commit()
        conn.close()

        # ---------- 5) 同步到总单词册（同样采用覆盖策略） ----------
        if sync_to_total and book_name != "总单词册":
            sync_data        = data.copy()
            sync_data["备注"] = ""          # 总册不保留备注
            save_word_to_total(sync_data)

    except Exception as e:
        raise Exception(f"保存单词到数据库失败：{str(e)}")


def save_word_to_total(data):
    """
    保存单词到总单词本（#FF0000）。
    修复：同样基于『释义-例句对』精细合并，避免出现释义空行或例句错位。
    """
    try:
        conn   = get_connection("总单词册", "#FF0000")
        cursor = conn.cursor()

        word          = data["单词"]
        new_meanings  = data["释义"]
        new_examples  = data.get("例句", [])
        new_related   = data.get("相关单词", [])
        new_tags      = data.get("标签", [])
        timestamp     = data.get("时间", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        if len(new_examples) < len(new_meanings):
            new_examples += [""] * (len(new_meanings) - len(new_examples))

        cursor.execute(
            "SELECT id, meanings, examples, related_words, tags FROM words WHERE word = ?",
            (word,),
        )
        existing = cursor.fetchone()

        if existing:
            # ---------- 合并 ----------
            word_id, om_json, oe_json, or_json, ot_json = existing
            old_meanings = json.loads(om_json)
            old_examples = json.loads(oe_json) if oe_json else []
            old_related  = json.loads(or_json) if or_json else []
            old_tags     = json.loads(ot_json) if ot_json else []

            merged_meanings, merged_examples = _merge_meanings_examples(
                old_meanings, old_examples, new_meanings, new_examples
            )

            merged_related = old_related + [r for r in new_related if r not in old_related]
            merged_tags    = old_tags    + [t for t in new_tags if t not in old_tags]

            cursor.execute(
                """
                UPDATE words SET
                    meanings      = ?,
                    examples      = ?,
                    related_words = ?,
                    tags          = ?,
                    timestamp     = ?
                WHERE id = ?
                """,
                (
                    json.dumps(merged_meanings, ensure_ascii=False),
                    json.dumps(merged_examples, ensure_ascii=False),
                    json.dumps(merged_related, ensure_ascii=False),
                    json.dumps(merged_tags, ensure_ascii=False),
                    timestamp,
                    word_id,
                ),
            )
        else:
            # ---------- 直接插入 ----------
            cursor.execute(
                """
                INSERT INTO words (
                    word, meanings, examples,
                    related_words, tags, note, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    word,
                    json.dumps(new_meanings, ensure_ascii=False),
                    json.dumps(new_examples, ensure_ascii=False),
                    json.dumps(new_related, ensure_ascii=False),
                    json.dumps(new_tags, ensure_ascii=False),
                    "",        # 总单词册不记录备注
                    timestamp,
                ),
            )

        # ---- 标签入库 ----
        for tag in new_tags:
            cursor.execute("INSERT OR IGNORE INTO tags (tag) VALUES (?)", (tag,))

        conn.commit()
        conn.close()

    except Exception as e:
        raise Exception(f"保存单词到总单词本失败：{str(e)}")
def get_all_tags(book_name, color):
    """
    获取所有标签
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        list: 标签列表
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        cursor.execute("SELECT tag FROM tags ORDER BY tag")
        tags = [row[0] for row in cursor.fetchall()]
        
        conn.close()
        return tags
    except Exception as e:
        print(f"Error getting tags from database: {e}")
        return []

def save_tags(book_name, color, tags):
    """
    保存标签到数据库
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        tags (list): 标签列表
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        # 清空现有标签
        cursor.execute("DELETE FROM tags")
        
        # 插入新标签
        for tag in tags:
            cursor.execute("INSERT INTO tags (tag) VALUES (?)", (tag,))
        
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"Error saving tags to database: {e}")

def delete_word(book_name, color, word):
    """
    从数据库删除单词
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        word (str): 要删除的单词
    """
    try:
        conn = get_connection(book_name, color)
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM words WHERE word = ?", (word,))
        
        conn.commit()
        conn.close()
    except Exception as e:
        raise Exception(f"删除单词失败：{str(e)}")

# ======== 1. 释义-例句 合并工具 ========
def _merge_meanings_examples(
    old_meanings: list[str],
    old_examples: list[str],
    new_meanings: list[str],
    new_examples: list[str],
) -> tuple[list[str], list[str]]:
    """
    按『释义-例句』成对合并，解决：
      • 仅凭释义去重 → 例句丢失
      • 释义已存在但旧例句为空 → 写入新例句
      • 同一释义可保留多条不同例句
    """
    # --- 长度对齐 ---
    if len(old_examples) < len(old_meanings):
        old_examples += [""] * (len(old_meanings) - len(old_examples))

    # --- 逐对处理 ---
    for m, ex in zip(new_meanings, new_examples):
        # a. 查找所有同释义的位置
        idx_list = [i for i, om in enumerate(old_meanings) if om == m]

        updated = False
        for idx in idx_list:
            # ① 完全重复 → 跳过
            if old_examples[idx] == ex:
                updated = True
                break
            # ② 旧例句为空 → 填充
            if not old_examples[idx] and ex:
                old_examples[idx] = ex
                updated = True
                break

        if updated:
            continue    # 已处理

        # b. 释义不存在 / 未匹配成功 → 追加新对
        old_meanings.append(m)
        old_examples.append(ex)

    return old_meanings, old_examples
db.py结束

db_memory.py开始
# db_memory.py
import sqlite3
import json
from datetime import datetime, timedelta
import pandas as pd

from db import get_db_path

# 艾宾浩斯遗忘曲线复习间隔（单位：天）
MEMORY_INTERVALS = [0, 1, 2, 4, 7, 15, 30]

def init_memory_table(db_path):
    """
    初始化记忆曲线数据表
    
    Args:
        db_path (str): 数据库文件路径
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # 创建记忆曲线数据表
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS memory_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        word TEXT NOT NULL,
        review_count INTEGER DEFAULT 0,  -- 复习次数
        last_review_date TEXT,          -- 上次复习时间
        next_review_date TEXT,          -- 下次复习时间
        correct_count INTEGER DEFAULT 0, -- 正确次数
        error_count INTEGER DEFAULT 0,   -- 错误次数
        UNIQUE(word)
    )
    ''')
    
    conn.commit()
    conn.close()

def get_memory_connection(book_name, color):
    """
    获取数据库连接并确保记忆表已创建
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        sqlite3.Connection: 数据库连接对象
    """
    db_path = get_db_path(book_name, color)
    init_memory_table(db_path)  # 确保记忆表已创建
    return sqlite3.connect(db_path)

def load_memory_data(book_name, color):
    """
    从数据库加载记忆数据
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        pd.DataFrame: 记忆数据DataFrame
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 获取所有单词
        cursor.execute("SELECT word FROM words")
        all_words = [row[0] for row in cursor.fetchall()]
        
        # 获取记忆数据
        cursor.execute("""
        SELECT word, review_count, last_review_date, next_review_date, correct_count, error_count 
        FROM memory_data
        """)
        memory_rows = cursor.fetchall()
        
        # 转换为字典列表
        memory_data = []
        memory_words = set()
        
        for row in memory_rows:
            word, review_count, last_review_date, next_review_date, correct_count, error_count = row
            memory_words.add(word)
            memory_data.append({
                "单词": word,
                "复习次数": review_count,
                "上次复习时间": last_review_date,
                "下次复习时间": next_review_date,
                "正确次数": correct_count,
                "错误次数": error_count
            })
        
        # 检查是否有新单词需要添加到记忆数据中
        new_words = set(all_words) - memory_words
        if new_words:
            today = datetime.now().strftime("%Y-%m-%d")
            for word in new_words:
                memory_data.append({
                    "单词": word,
                    "复习次数": 0,
                    "上次复习时间": None,
                    "下次复习时间": today,
                    "正确次数": 0,
                    "错误次数": 0
                })
                
                # 将新单词添加到数据库
                cursor.execute("""
                INSERT INTO memory_data (word, review_count, last_review_date, next_review_date, correct_count, error_count)
                VALUES (?, ?, ?, ?, ?, ?)
                """, (word, 0, None, today, 0, 0))
            
            conn.commit()
        
        # 检查是否有已删除的单词需要从记忆数据中移除
        deleted_words = memory_words - set(all_words)
        if deleted_words:
            for word in deleted_words:
                cursor.execute("DELETE FROM memory_data WHERE word = ?", (word,))
            conn.commit()
            # 从内存中的记忆数据中移除已删除的单词
            memory_data = [data for data in memory_data if data["单词"] not in deleted_words]
        
        conn.close()
        
        # 转换为DataFrame
        memory_df = pd.DataFrame(memory_data)
        return memory_df
    
    except Exception as e:
        print(f"Error loading memory data: {e}")
        # 返回空DataFrame，包含必要的列
        return pd.DataFrame(columns=["单词", "复习次数", "上次复习时间", "下次复习时间", "正确次数", "错误次数"])

def save_memory_data(book_name, color, memory_data):
    """
    保存记忆数据到数据库
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        memory_data (pd.DataFrame): 记忆数据DataFrame
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 遍历DataFrame中的每一行
        for _, row in memory_data.iterrows():
            word = row["单词"]
            review_count = int(row["复习次数"])
            last_review_date = row["上次复习时间"]
            next_review_date = row["下次复习时间"]
            correct_count = int(row["正确次数"])
            error_count = int(row["错误次数"])
            
            # 检查单词是否已存在
            cursor.execute("SELECT id FROM memory_data WHERE word = ?", (word,))
            existing = cursor.fetchone()
            
            if existing:
                # 更新现有记录
                cursor.execute("""
                UPDATE memory_data SET 
                    review_count = ?,
                    last_review_date = ?,
                    next_review_date = ?,
                    correct_count = ?,
                    error_count = ?
                WHERE word = ?
                """, (review_count, last_review_date, next_review_date, correct_count, error_count, word))
            else:
                # 插入新记录
                cursor.execute("""
                INSERT INTO memory_data (word, review_count, last_review_date, next_review_date, correct_count, error_count)
                VALUES (?, ?, ?, ?, ?, ?)
                """, (word, review_count, last_review_date, next_review_date, correct_count, error_count))
        
        conn.commit()
        conn.close()
    
    except Exception as e:
        print(f"Error saving memory data: {e}")
        raise Exception(f"保存记忆数据失败: {str(e)}")

def get_review_words(book_name, color):
    """
    获取今天需要复习的单词
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        
    Returns:
        list: 需要复习的单词数据列表
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 获取今天需要复习的单词
        today = datetime.now().strftime("%Y-%m-%d")
        cursor.execute("""
        SELECT m.word, m.review_count, m.last_review_date, m.next_review_date, m.correct_count, m.error_count
        FROM memory_data m
        WHERE m.next_review_date <= ?
        """, (today,))
        
        memory_rows = cursor.fetchall()
        if not memory_rows:
            conn.close()
            return []
        
        # 获取单词详细信息
        review_words = []
        for row in memory_rows:
            word, review_count, last_review_date, next_review_date, correct_count, error_count = row
            
            # 获取单词详细信息
            cursor.execute("""
            SELECT meanings, examples, related_words, tags, note
            FROM words
            WHERE word = ?
            """, (word,))
            
            word_info = cursor.fetchone()
            if word_info:
                meanings, examples, related_words, tags, note = word_info
                
                word_data = {
                    "单词": word,
                    "释义": json.loads(meanings),
                    "例句": json.loads(examples) if examples else [],
                    "相关单词": json.loads(related_words) if related_words else [],
                    "标签": json.loads(tags) if tags else [],
                    "备注": note if note else "",
                    "复习次数": review_count,
                    "上次复习时间": last_review_date,
                    "下次复习时间": next_review_date,
                    "正确次数": correct_count,
                    "错误次数": error_count
                }
                
                review_words.append(word_data)
        
        conn.close()
        return review_words
    
    except Exception as e:
        print(f"Error getting review words: {e}")
        return []

def update_word_memory_status(book_name, color, word, is_correct):
    """
    更新单词的记忆状态
    
    Args:
        book_name (str): 单词本名称
        color (str): 单词本颜色
        word (str): 单词
        is_correct (bool): 是否回答正确
    """
    try:
        conn = get_memory_connection(book_name, color)
        cursor = conn.cursor()
        
        # 获取当前记忆状态
        cursor.execute("""
        SELECT review_count, correct_count, error_count
        FROM memory_data
        WHERE word = ?
        """, (word,))
        
        row = cursor.fetchone()
        if not row:
            conn.close()
            return
        
        review_count, correct_count, error_count = row
        review_count += 1
        today = datetime.now().strftime("%Y-%m-%d")
        
        if is_correct:
            correct_count += 1
            # 更新下次复习时间
            review_stage = min(review_count, len(MEMORY_INTERVALS) - 1)
            next_review_date = (datetime.now() + timedelta(days=MEMORY_INTERVALS[review_stage])).strftime("%Y-%m-%d")
        else:
            error_count += 1
            # 错误的单词第二天就复习
            next_review_date = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
        
        # 更新记忆状态
        cursor.execute("""
        UPDATE memory_data SET 
            review_count = ?,
            last_review_date = ?,
            next_review_date = ?,
            correct_count = ?,
            error_count = ?
        WHERE word = ?
        """, (review_count, today, next_review_date, correct_count, error_count, word))
        
        conn.commit()
        conn.close()
    
    except Exception as e:
        print(f"Error updating word memory status: {e}")
        raise Exception(f"更新单词记忆状态失败: {str(e)}")
db_memory.py结束

font.py开始
#font.py
from PySide6.QtGui import QFont, QPalette, QColor

# 使用通用字体族，确保在任何中文Windows系统上都能正常显示
normal_font = QFont("Microsoft YaHei, SimSun, sans-serif", 12)

meaning_font = QFont("Microsoft YaHei, SimSun, sans-serif", 13)
meaning_font.setBold(True)

sentence_font = QFont("Microsoft YaHei, SimSun, sans-serif", 13)
sentence_font.setBold(True)
sentence_font_platte = QPalette()
sentence_font_platte.setColor(QPalette.WindowText, QColor("gray"))

word_font = QFont("Microsoft YaHei, SimSun, sans-serif", 15)
word_font.setBold(True)

note_font = QFont("SimSun, Microsoft YaHei, sans-serif")

# 对于英文字体，添加备选字体
main_word_font = QFont("Georgia, Times New Roman, serif", 35)
main_word_font.setBold(True)
main_word_font.setWordSpacing(2.5)

list_word_font = QFont("Georgia, Times New Roman, serif", 12)
list_word_font.setBold(True)
font.py结束

memory_curve.py开始
# memory_curve.py
import os
import sys
import pandas as pd
import random
from datetime import datetime, timedelta
from PySide6.QtCore import Qt, QTimer
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QLineEdit, QMessageBox, QFrame, QTextEdit
)
from font import meaning_font, main_word_font, list_word_font, sentence_font
from styles import PRIMARY_BUTTON_STYLE, SECONDARY_BUTTON_STYLE, TEXT_EDIT_STYLE, LINE_EDIT_STYLE
from db_memory import load_memory_data, save_memory_data, get_review_words, update_word_memory_status

# 艾宾浩斯遗忘曲线复习间隔（单位：天）
MEMORY_INTERVALS = [0, 1, 2, 4, 7, 15, 30]

class MemoryCurveApp(QWidget):
    def __init__(self, path):
        super().__init__()
        self.path = os.path.dirname(os.path.abspath(sys.argv[0]))  # 使用可执行文件所在目录
        self.book_name = os.path.basename(path).split('_')[1]  # 获取单词本名称
        self.book_color = os.path.basename(path).split('_')[2]  # 获取单词本颜色
        
        # 初始化数据
        self.current_word_index = 0
        self.correct_count = 0
        self.total_count = 0
        self.review_words = []
        
        # 初始化界面
        self.init_ui()
        self.load_memory_data()
        self.load_review_words()
        
    def init_ui(self):
        self.setWindowTitle(f"背单词 - {self.book_name}")
        self.resize(800, 600)
        
        main_layout = QVBoxLayout()
        
        # 顶部信息栏
        info_layout = QHBoxLayout()
        self.progress_label = QLabel("进度: 0/0")
        self.correct_label = QLabel("正确率: 0%")
        info_layout.addWidget(self.progress_label)
        info_layout.addStretch()
        info_layout.addWidget(self.correct_label)
        main_layout.addLayout(info_layout)
        
        # 分隔线
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line)
        
        # 释义区域
        self.meaning_area = QTextEdit()
        self.meaning_area.setReadOnly(True)
        self.meaning_area.setFont(meaning_font)
        self.meaning_area.setStyleSheet(TEXT_EDIT_STYLE)
        main_layout.addWidget(self.meaning_area)
        
        # 下划线提示区域
        self.hint_label = QLabel("")
        self.hint_label.setAlignment(Qt.AlignCenter)
        self.hint_label.setFont(main_word_font)
        main_layout.addWidget(self.hint_label)
        
        # 输入区域
        input_layout = QHBoxLayout()
        self.word_input = QLineEdit()
        self.word_input.setPlaceholderText("请输入单词")
        self.word_input.setFont(list_word_font)
        self.word_input.setStyleSheet(LINE_EDIT_STYLE)
        self.word_input.returnPressed.connect(self.check_answer)
        self.word_input.textChanged.connect(self.update_hint_display)
        input_layout.addWidget(self.word_input)
        
        self.check_button = QPushButton("确认")
        self.check_button.setStyleSheet(PRIMARY_BUTTON_STYLE)
        self.check_button.clicked.connect(self.check_answer)
        input_layout.addWidget(self.check_button)
        
        main_layout.addLayout(input_layout)
        
        # 结果显示区域
        self.result_label = QLabel("")
        self.result_label.setAlignment(Qt.AlignCenter)
        self.result_label.setFont(main_word_font)
        main_layout.addWidget(self.result_label)
        
        # 例句区域
        self.example_area = QTextEdit()
        self.example_area.setReadOnly(True)
        self.example_area.setFont(sentence_font)
        self.example_area.setStyleSheet(TEXT_EDIT_STYLE)
        self.example_area.setVisible(False)  # 初始隐藏
        main_layout.addWidget(self.example_area)
        
        # 按钮区域
        button_layout = QHBoxLayout()
        
        self.hint_button = QPushButton("提示")
        self.hint_button.setStyleSheet(SECONDARY_BUTTON_STYLE)
        self.hint_button.clicked.connect(self.show_letter_hint)
        button_layout.addWidget(self.hint_button)
        
        self.show_answer_button = QPushButton("显示答案")
        self.show_answer_button.setStyleSheet(SECONDARY_BUTTON_STYLE)
        self.show_answer_button.clicked.connect(self.show_answer)
        button_layout.addWidget(self.show_answer_button)
        
        self.next_button = QPushButton("下一个")
        self.next_button.setStyleSheet(PRIMARY_BUTTON_STYLE)
        self.next_button.clicked.connect(self.next_word)
        self.next_button.setEnabled(False)  # 初始禁用
        button_layout.addWidget(self.next_button)
        
        main_layout.addLayout(button_layout)
        
        self.setLayout(main_layout)
        
        # 初始化提示相关变量
        self.current_word = ""
        self.revealed_letters = 0
    
    def load_memory_data(self):
        """加载记忆数据"""
        try:
            # 使用SQLite数据库加载记忆数据
            self.memory_data = load_memory_data(self.book_name, self.book_color)
            
            if self.memory_data.empty:
                QMessageBox.warning(self, "提示", "记忆数据为空，将创建新的记忆数据。")
                
        except Exception as e:
            QMessageBox.warning(self, "错误", f"加载记忆数据失败: {str(e)}")
            self.memory_data = pd.DataFrame(columns=["单词", "复习次数", "上次复习时间", "下次复习时间", "正确次数", "错误次数"])
    
    def save_memory_data(self):
        """保存记忆数据"""
        try:
            # 使用SQLite数据库保存记忆数据
            save_memory_data(self.book_name, self.book_color, self.memory_data)
        except Exception as e:
            QMessageBox.warning(self, "错误", f"保存记忆数据失败: {str(e)}")
    
    def load_review_words(self):
        """加载需要复习的单词"""
        try:
            # 使用SQLite数据库获取今天需要复习的单词
            self.review_words = get_review_words(self.book_name, self.book_color)
            
            if not self.review_words:
                QMessageBox.information(self, "提示", "今天没有需要复习的单词!")
                return
            
            # 随机打乱顺序
            random.shuffle(self.review_words)
            
            self.total_count = len(self.review_words)
            self.current_word_index = 0
            self.correct_count = 0
            
            self.update_progress()
            self.show_current_word()
        except Exception as e:
            QMessageBox.warning(self, "错误", f"加载单词数据失败: {str(e)}")
    
    def update_progress(self):
        """更新进度信息"""
        if self.total_count > 0:
            self.progress_label.setText(f"进度: {self.current_word_index}/{self.total_count}")
            correct_rate = (self.correct_count / max(1, self.current_word_index)) * 100 if self.current_word_index > 0 else 0
            self.correct_label.setText(f"正确率: {correct_rate:.1f}%")
        else:
            self.progress_label.setText("进度: 0/0")
            self.correct_label.setText("正确率: 0%")
    
    def show_current_word(self):
        """显示当前单词的释义"""
        if not self.review_words or self.current_word_index >= len(self.review_words):
            QMessageBox.information(self, "完成", "恭喜你完成了今天的复习!")
            self.close()
            return
        
        # 重置界面状态
        self.word_input.clear()
        self.word_input.setEnabled(True)
        self.check_button.setEnabled(True)
        self.show_answer_button.setEnabled(True)
        self.hint_button.setEnabled(True)
        self.next_button.setEnabled(False)
        self.result_label.clear()
        self.example_area.clear()
        self.example_area.setVisible(False)
        
        # 显示释义
        current_word = self.review_words[self.current_word_index]
        self.current_word = current_word["单词"]  # 保存当前单词
        self.revealed_letters = 0  # 重置已提示的字母数
        
        meanings = current_word.get("释义", [])
        
        meanings_text = ""
        for i, meaning in enumerate(meanings):
            meanings_text += f"释义{i+1}: {meaning}\n\n"
        
        self.meaning_area.setText(meanings_text)
        
        # 显示下划线提示
        self.update_hint_display()
        
        self.word_input.setFocus()
    def update_hint_display(self):
        """根据单词长度和用户输入更新下划线提示"""
        if not hasattr(self, 'current_word') or not self.current_word:
            return
            
        # 确保current_word是字符串类型
        if not isinstance(self.current_word, str):
            self.current_word = str(self.current_word)
            
        word_length = len(self.current_word)
        user_input = self.word_input.text()
        
        # 创建下划线提示
        hint_text = ""
        for i in range(word_length):
            if i < self.revealed_letters:
                # 已提示的字母
                hint_text += f" {self.current_word[i]} "
            elif i < len(user_input):
                # 用户已输入的字母
                hint_text += f" {user_input[i]} "
            else:
                # 未输入的字母用下划线表示
                hint_text += " _ "
                
        self.hint_label.setText(hint_text)
    
    def show_letter_hint(self):
        """提示下一个字母"""
        if not self.current_word or self.revealed_letters >= len(self.current_word):
            return
            
        self.revealed_letters += 1
        self.update_hint_display()
        
        # 如果已经提示了所有字母，禁用提示按钮
        if self.revealed_letters >= len(self.current_word):
            self.hint_button.setEnabled(False)
    
    def check_answer(self):
        """检查答案"""
        if not self.review_words or self.current_word_index >= len(self.review_words):
            return
        try:
            user_input = self.word_input.text().strip().lower()
            current_word = self.review_words[self.current_word_index]
            
            # 确保current_word是字典类型且包含单词字段
            if not isinstance(current_word, dict) or "单词" not in current_word:
                raise ValueError("单词数据格式错误")
                
            correct_word = str(current_word["单词"]).strip().lower()
            
            if user_input == correct_word:
                # 答案正确
                self.result_label.setText("✓ 正确!")
                self.result_label.setStyleSheet("color: green;")
                self.correct_count += 1
                
                # 使用SQLite数据库更新单词记忆状态
                update_word_memory_status(self.book_name, self.book_color, current_word["单词"], True)
                
                # 更新内存中的数据以保持UI一致性
                word_idx = self.memory_data[self.memory_data["单词"] == current_word["单词"]].index[0]
                self.memory_data.at[word_idx, "正确次数"] = self.memory_data.at[word_idx, "正确次数"] + 1
                self.memory_data.at[word_idx, "复习次数"] = self.memory_data.at[word_idx, "复习次数"] + 1
                review_stage = min(self.memory_data.at[word_idx, "复习次数"], len(MEMORY_INTERVALS) - 1)
                next_review_date = datetime.now() + timedelta(days=MEMORY_INTERVALS[review_stage])
                self.memory_data.at[word_idx, "上次复习时间"] = datetime.now().strftime("%Y-%m-%d")
                self.memory_data.at[word_idx, "下次复习时间"] = next_review_date.strftime("%Y-%m-%d")
            else:
                # 答案错误
                self.result_label.setText(f"✗ 错误! 正确答案是: {current_word['单词']}")
                self.result_label.setStyleSheet("color: red;")
                
                # 使用SQLite数据库更新单词记忆状态
                update_word_memory_status(self.book_name, self.book_color, current_word["单词"], False)
                
                # 更新内存中的数据以保持UI一致性
                word_idx = self.memory_data[self.memory_data["单词"] == current_word["单词"]].index[0]
                self.memory_data.at[word_idx, "错误次数"] = self.memory_data.at[word_idx, "错误次数"] + 1
                self.memory_data.at[word_idx, "复习次数"] = self.memory_data.at[word_idx, "复习次数"] + 1
                self.memory_data.at[word_idx, "上次复习时间"] = datetime.now().strftime("%Y-%m-%d")
                self.memory_data.at[word_idx, "下次复习时间"] = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
                
                # 将当前单词添加到队列末尾，以便再次复习
                self.review_words.append(current_word)
            
            # 显示例句
            examples = current_word.get("例句", [])
            if examples:
                examples_text = ""
                for i, example in enumerate(examples):
                    examples_text += f"例句{i+1}: {example}\n\n"
                self.example_area.setText(examples_text)
                self.example_area.setVisible(True)
            
            # 禁用输入和检查按钮，启用下一个按钮
            self.word_input.setEnabled(False)
            self.check_button.setEnabled(False)
            self.show_answer_button.setEnabled(False)
            self.hint_button.setEnabled(False)  # 禁用提示按钮
            self.next_button.setEnabled(True)
            
            # 保存记忆数据
            self.save_memory_data()
            self.update_progress()
        except Exception as e:
            QMessageBox.warning(self, "错误", f"检查答案时发生错误: {str(e)}")
    def show_answer(self):
        """显示答案"""
        if not self.review_words or self.current_word_index >= len(self.review_words):
            return
        
        current_word = self.review_words[self.current_word_index]
        self.result_label.setText(f"答案: {current_word['单词']}")
        self.result_label.setStyleSheet("color: blue;")
        
        # 显示例句
        examples = current_word.get("例句", [])
        if examples:
            examples_text = ""
            for i, example in enumerate(examples):
                examples_text += f"例句{i+1}: {example}\n\n"
            self.example_area.setText(examples_text)
            self.example_area.setVisible(True)
        
        # 使用SQLite数据库更新单词记忆状态 - 显示答案视为错误
        update_word_memory_status(self.book_name, self.book_color, current_word["单词"], False)
        
        # 更新内存中的数据以保持UI一致性
        word_idx = self.memory_data[self.memory_data["单词"] == current_word["单词"]].index[0]
        self.memory_data.at[word_idx, "错误次数"] = self.memory_data.at[word_idx, "错误次数"] + 1
        self.memory_data.at[word_idx, "复习次数"] = self.memory_data.at[word_idx, "复习次数"] + 1
        self.memory_data.at[word_idx, "上次复习时间"] = datetime.now().strftime("%Y-%m-%d")
        self.memory_data.at[word_idx, "下次复习时间"] = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
        
        # 将当前单词添加到队列末尾，以便再次复习
        self.review_words.append(current_word)
        
        # 禁用输入和检查按钮，启用下一个按钮
        self.word_input.setEnabled(False)
        self.check_button.setEnabled(False)
        self.show_answer_button.setEnabled(False)
        self.hint_button.setEnabled(False)  # 禁用提示按钮
        self.next_button.setEnabled(True)
    
    def next_word(self):
        """进入下一个单词"""
        self.current_word_index += 1
        self.show_current_word()


    def closeEvent(self, event):
        """窗口关闭事件处理"""
        # 数据已经在每次更新时保存到SQLite数据库，不需要再次保存
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    if len(sys.argv) > 1:
        path = sys.argv[1]
        window = MemoryCurveApp(path)
        window.show()
        sys.exit(app.exec())
    else:
        print("请提供单词本路径")
memory_curve.py结束

python collect_py_files.py.py开始
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
collect_py_files.py

遍历根目录下所有 .py 文件，输出：
1. py_structure.txt          —— 目录结构（仅列出含 .py 的目录与文件）
2. combined_py_code.txt      —— 合并后的源码（带“开始/结束”标记）

用法：
    python collect_py_files.py <root_dir> [-s STRUCT_FILE] [-c COMBINED_FILE]
"""
from __future__ import annotations

import argparse
import os
from pathlib import Path
from typing import List


def find_py_files(root: Path) -> List[Path]:
    """递归收集 root 下的全部 .py 文件（按相对路径排序）"""
    return sorted(
        (p for p in root.rglob("*.py") if p.is_file()),
        key=lambda p: p.relative_to(root).as_posix()
    )


def write_structure(root: Path, py_files: List[Path], outfile: Path) -> None:
    """
    按目录层级写出仅含 .py 的“树状结构”：
    project/
        package/
            module.py
    """
    # 先收集每个目录下有哪些 py
    dirs_with_py: set[Path] = {p.parent for p in py_files}
    # 自底向上把父目录也加进来（以便保持层级完整）
    for d in list(dirs_with_py):
        while d != root:
            d = d.parent
            dirs_with_py.add(d)

    with outfile.open("w", encoding="utf-8") as f:
        def _walk(current: Path, depth: int = 0) -> None:
            indent = "    " * depth
            if current != root:  # 根目录名称通常显而易见，可省略
                f.write(f"{indent}{current.name}/\n")
            sub_indent = indent + "    "
            # 输出当前目录下的 .py 文件
            for py in sorted(p for p in current.iterdir() if p.suffix == ".py"):
                f.write(f"{sub_indent}{py.name}\n")
            # 递归子目录
            for sub in sorted(p for p in current.iterdir() if p.is_dir()):
                if sub in dirs_with_py:
                    _walk(sub, depth + 1)

        _walk(root)


def write_combined(root: Path, py_files: List[Path], outfile: Path) -> None:
    """把所有 .py 文件源码合并输出"""
    with outfile.open("w", encoding="utf-8") as f:
        for path in py_files:
            rel = path.relative_to(root).as_posix()
            f.write(f"{rel}开始\n")
            f.write(path.read_text(encoding="utf-8", errors="ignore"))
            f.write(f"\n{rel}结束\n\n")


def main() -> None:
    parser = argparse.ArgumentParser(...)
    parser.add_argument(
        "root_dir",
        nargs="?",  # 变成可选
        type=Path,
        default=Path.cwd(),  # 默认用当前工作目录
        help="根目录路径（默认=当前工作目录）"
    )
    parser.add_argument(
        "-s", "--structure-file",
        type=Path,
        default=Path("py_structure.txt"),
        help="目录结构输出文件（默认 py_structure.txt）"
    )
    parser.add_argument(
        "-c", "--combined-file",
        type=Path,
        default=Path("combined_py_code.txt"),
        help="合并源码输出文件（默认 combined_py_code.txt）"
    )
    args = parser.parse_args()

    root = args.root_dir.resolve()
    if not root.is_dir():
        raise SystemExit(f"错误：{root} 不是有效的目录。")

    py_files = find_py_files(root)
    if not py_files:
        print("未找到任何 .py 文件，未生成输出。")
        return

    write_structure(root, py_files, args.structure_file.resolve())
    write_combined(root, py_files, args.combined_file.resolve())

    print(f"已生成：\n  - {args.structure_file.resolve()}\n  - {args.combined_file.resolve()}")


if __name__ == "__main__":
    main()
python collect_py_files.py.py结束

repositories/__init__.py开始
"""Repository package public interface."""

from .word_repository import WordRepository

__all__: list[str] = [
    "WordRepository",
]

repositories/__init__.py结束

repositories/layout_repository.py开始
# repositories/layout_repository.py
"""持久化 Cover 布局 JSON（不做任何业务校验）"""
import json
import os
import sys
from typing import Any, Dict, List


def _layout_file_path() -> str:
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    return os.path.join(base_dir, "cover_layout.json")


class LayoutRepository:
    @staticmethod
    def load_layout() -> List[Dict[str, Any]]:
        """读取 cover_layout.json，异常时返回空列表"""
        path = _layout_file_path()
        if not os.path.exists(path):
            return []
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            return data.get("layout", [])
        except Exception:
            return []

    @staticmethod
    def save_layout(layout_items: List[Dict[str, Any]]) -> None:
        path = _layout_file_path()
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump({"layout": layout_items}, f, ensure_ascii=False, indent=2)
        except Exception as exc:
            raise RuntimeError(f"保存 word_book_cover 布局失败: {exc}") from exc

repositories/layout_repository.py结束

repositories/memory_repository.py开始
# repositories/memory_repository.py
"""
纯数据访问层：背单词 / 记忆曲线相关持久化
"""
import pandas as pd
from db_memory import (
    load_memory_data as _load,
    save_memory_data as _save,
    get_review_words as _review,
    update_word_memory_status as _update,
)


class MemoryRepository:
    """对 db_memory.py 做一次薄封装"""

    # ---------- DataFrame 全量读 / 写 ----------
    @staticmethod
    def load_memory_df(book: str, color: str) -> pd.DataFrame:
        return _load(book, color)

    @staticmethod
    def save_memory_df(book: str, color: str, df: pd.DataFrame) -> None:
        _save(book, color, df)

    # ---------- 业务片段 ----------
    @staticmethod
    def get_today_review_words(book: str, color: str) -> list[dict]:
        return _review(book, color)

    @staticmethod
    def update_word_status(book: str, color: str, word: str, is_correct: bool) -> None:
        _update(book, color, word, is_correct)

repositories/memory_repository.py结束

repositories/tag_repository.py开始
# repositories/tag_repository.py
"""
纯数据访问层：所有【标签】相关的持久化操作
"""
from db import get_all_tags as _get_all_tags, save_tags as _save_tags


class TagRepository:
    """封装 db.py 里的标签 API，保证 UI/Service 不直接依赖 db.py"""

    @staticmethod
    def list_tags(book_name: str, color: str) -> list[str]:
        """返回指定单词本的全部标签（按字典序）"""
        return _get_all_tags(book_name, color)

    @staticmethod
    def add_tag(book_name: str, color: str, new_tag: str) -> None:
        """向指定单词本追加单个标签（自动去重）"""
        tags = _get_all_tags(book_name, color)
        if new_tag not in tags:
            tags.append(new_tag)
            _save_tags(book_name, color, tags)

repositories/tag_repository.py结束

repositories/word_repository.py开始
"""repositories/word_repository.py
---------------------------------
Wrap db.py helpers so upper layers never import db directly.
"""
from __future__ import annotations

from typing import Any, Dict, List

from db import (
    load_words as _load_words,
    save_word as _save_word,
    delete_word as _delete_word,
)


class WordRepository:
    """Thin data-access wrapper."""

    # -------- Query --------
    @staticmethod
    def list_words(book_name: str, color: str) -> List[Dict[str, Any]]:
        return _load_words(book_name, color)

    # -------- Save / Update --------
    @staticmethod
    def save_word(
        book_name: str,
        color: str,
        data: Dict[str, Any],
        *,
        sync_to_total: bool = True,
    ) -> None:
        _save_word(book_name, color, data, sync_to_total=sync_to_total)

    # -------- Delete --------
    @staticmethod
    def delete_word(book_name: str, color: str, word: str) -> None:
        _delete_word(book_name, color, word)

repositories/word_repository.py结束

repositories/wordbook_repository.py开始
# repositories/wordbook_repository.py
from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional


# ---------- 纯数据：WordBook (原 domain.wordbook.WordBook) ----------
@dataclass
class WordBook:
    name: str
    color: str = "#ffffff"
    path: Optional[Path] = None
    is_folder: bool = False
    sub_books: List["WordBook"] = field(default_factory=list)


# ---------- 持久化层：示例 Repository ----------
class WordBookRepository:
    """负责磁盘 / SQLite 的增删改查，这里只给骨架示例。"""

    def rename(self, book: WordBook, new_name: str) -> WordBook: ...
    def delete(self, book: WordBook) -> None: ...
    def save(self, book: WordBook) -> None: ...
    def load_all(self) -> List[WordBook]: ...


__all__ = ["WordBook", "WordBookRepository"]

repositories/wordbook_repository.py结束

services/__init__.py开始
"""Service package public interface.

Re‑export the main service classes so callers can simply do:

    from services import WordBookService
"""

from .wordbook_service import WordBookService

__all__: list[str] = [
    "WordBookService",
]

services/__init__.py结束

services/cover_layout_service.py开始
# services/cover_layout_service.py
"""
Cover 布局业务封装：UI <-> Repository 中间层，便于后期加缓存、版本迁移等。
"""
from typing import Any, Dict, List
from repositories.layout_repository import LayoutRepository


class CoverLayoutService:
    @staticmethod
    def load() -> List[Dict[str, Any]]:
        return LayoutRepository.load_layout()

    @staticmethod
    def save(layout_items: List[Dict[str, Any]]) -> None:
        LayoutRepository.save_layout(layout_items)

services/cover_layout_service.py结束

services/folder_service.py开始
# services/folder_service.py开始
from __future__ import annotations
import os
import sys
from typing import List, Dict, Any, TYPE_CHECKING

from UI.word_book_button import WordBookButton

if TYPE_CHECKING:
    from UI.word_book_cover.cover_content import CoverContent  # For type hinting


class FolderService:
    """Business‑logic layer for the word_book_cover page operations related to folders and buttons."""

    def __init__(self) -> None:
        self.content: 'CoverContent' | None = None

    def build_buttons(self, cover_content_instance: 'CoverContent') -> List[WordBookButton]:
        """扫描 books/ 目录并以新 WordBookButton 创建按钮列表。"""
        self.content = cover_content_instance

        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        books_dir = os.path.join(base_dir, "books")
        os.makedirs(books_dir, exist_ok=True)

        # -- 确保「总单词册」文件夹存在 ------------------------------------
        main_name, main_color = "总单词册", "#FF0000"
        main_folder = f"books_{main_name}_{main_color}"
        main_path = os.path.join(books_dir, main_folder)
        if not os.path.exists(main_path):
            os.makedirs(main_path, exist_ok=True)
            from db import init_db as _init_db
            _init_db(os.path.join(main_path, "wordbook.db"))

        # -- 枚举磁盘目录，整理元数据 ------------------------------------
        metas: list[Dict[str, str]] = []
        for d in os.listdir(books_dir):
            p = os.path.join(books_dir, d)
            if not (d.startswith("books_") and os.path.isdir(p)):
                continue
            try:
                _, nm, cl = d.split("_", 2)
                metas.append({"name": nm, "color": cl, "folder": d})
            except ValueError:
                continue

        metas.sort(key=lambda m: (m["name"] != main_name, m["name"]))

        buttons: list[WordBookButton] = []
        for m in metas:
            path = os.path.join(books_dir, m["folder"])

            btn = WordBookButton(m["name"], m["color"], parent=self.content)  # ★ 不再传 app=
            # —— 兼容旧逻辑：补挂属性 —— #
            btn.app = self.content
            btn.path = path
            btn.color = m["color"]
            btn.is_folder = False
            btn.is_sub_button = False

            # 点击 → 打开单词本
            if hasattr(self.content, "show_word_book"):
                try:
                    btn.clicked.disconnect()
                except (RuntimeError, TypeError):
                    pass
                btn.clicked.connect(lambda _=False, p=btn.path: self.content.show_word_book(p))

            buttons.append(btn)

        self.content.buttons = buttons
        return buttons

    def set_edit_mode(self, entering: bool, buttons_on_content: list[WordBookButton]) -> None:
        """Toggles edit mode for buttons (jitter, delete visibility)."""
        if not self.content: return

        for b in buttons_on_content:
            if not getattr(b, 'is_new_button', False):
                if entering:
                    b.start_jitter()
                else:
                    b.stop_jitter()

        if hasattr(self.content, 'new_book_button'):
            if entering:
                self.content.new_book_button.start_jitter()
            else:
                self.content.new_book_button.stop_jitter()

        if entering:
            for b_main in buttons_on_content:
                if b_main.is_folder and b_main.is_expanded:
                    for sub_b in b_main.sub_buttons:
                        sub_b.start_jitter()

    def highlight_search(self, kw: str, buttons_on_content: list[WordBookButton]) -> None:
        kw_lc = kw.strip().lower()
        all_buttons_to_check = buttons_on_content[:]
        if hasattr(self.content, 'new_book_button'):
            all_buttons_to_check.append(self.content.new_book_button)

        for b in all_buttons_to_check:
            if getattr(b, "is_new_button", False) and b is not self.content.new_book_button:
                continue

            original_stylesheet = getattr(b, '_original_stylesheet', b.styleSheet())
            if not hasattr(b, '_original_stylesheet'):
                b._original_stylesheet = original_stylesheet

            is_match = kw_lc and kw_lc in b.text().lower()

            current_style = b.styleSheet()
            border_highlight = "border:2px solid #e67e22;"

            if is_match:
                if border_highlight not in current_style:
                    import re
                    style_no_border = re.sub(r"border:.*?;", "", current_style, flags=re.IGNORECASE)
                    style_no_border = re.sub(r"\s\s+", " ", style_no_border).strip()
                    if style_no_border and not style_no_border.endswith(';'):
                        style_no_border += ";"
                    b.setStyleSheet(style_no_border + " " + border_highlight if style_no_border else border_highlight)
            else:
                b.setStyleSheet(original_stylesheet)

    def show_new_wordbook_dialog(self) -> tuple[bool, str | None, str | None]:
        from UI.new_wordbook_dialog import NewWordBookDialog
        parent_window = self.content.window() if self.content else None
        dlg = NewWordBookDialog(parent_window)
        if dlg.exec():
            return True, dlg.book_name, dlg.book_color
        return False, None, None

    def export_layout(self, buttons_on_content: list[WordBookButton]) -> List[Dict[str, Any]]:
        """Exports the current layout of buttons and folders."""
        items = []
        for btn in buttons_on_content:
            if getattr(btn, "is_new_button", False): continue

            item_data: Dict[str, Any] = {
                "name": btn.text(),
                "color": btn.color,
            }
            if btn.path:  # Store path if available
                item_data["path"] = btn.path

            if btn.is_folder:
                item_data["type"] = "folder"
                item_data["is_expanded"] = btn.is_expanded
                item_data["sub_books"] = []
                for sub in btn.sub_buttons:
                    sub_book_data = {
                        "name": sub.text(),
                        "color": sub.color,
                    }
                    if sub.path:
                        sub_book_data["path"] = sub.path
                    item_data["sub_books"].append(sub_book_data)
            else:
                item_data["type"] = "wordbook"
            items.append(item_data)
        return items

    def apply_layout(
        self,
        layout_items: List[Dict[str, Any]],
        current_buttons_from_scan: list[WordBookButton],
    ) -> None:
        """根据保存的布局重建按钮顺序 / 文件夹结构。"""
        if not self.content:
            return

        # ---------- 1. 统一补充缺失属性 ----------
        for b in current_buttons_from_scan:
            if not hasattr(b, "color"):
                b.color = getattr(b, "_color", "#999999")   # 默认灰，基本不会用到
            if not hasattr(b, "is_folder"):
                b.is_folder = False
            if not hasattr(b, "is_sub_button"):
                b.is_sub_button = False

        # ---------- 2. 建立检索索引 ----------
        path_to_scan = {b.path: b for b in current_buttons_from_scan if b.path}
        name_color_to_scan = {f"{b.text()}_{b.color}": b for b in current_buttons_from_scan}

        new_main_buttons: list[WordBookButton] = []
        processed: set[str] = set()

        # ---------- 3. 按布局文件逐条构建 ----------
        for spec in layout_items:
            name, color = spec.get("name"), spec.get("color")
            path, typ   = spec.get("path"), spec.get("type")

            # 先在扫描结果里找现成的按钮
            btn = None
            if path and path in path_to_scan:
                btn = path_to_scan[path]
            elif name and color and f"{name}_{color}" in name_color_to_scan:
                btn = name_color_to_scan[f"{name}_{color}"]

            # —— 文件夹 —— #
            if typ == "folder":
                folder_btn = btn or WordBookButton(name, color, parent=self.content)
                folder_btn.color = color             # 确保属性存在
                folder_btn.app   = self.content
                folder_btn.is_folder   = True
                folder_btn.is_expanded = spec.get("is_expanded", False)
                folder_btn.sub_buttons = []

                # 处理子按钮
                for sub in spec.get("sub_books", []):
                    s_name, s_color, s_path = sub.get("name"), sub.get("color"), sub.get("path")
                    sub_btn = None
                    if s_path and s_path in path_to_scan:
                        sub_btn = path_to_scan[s_path]
                    elif s_name and s_color and f"{s_name}_{s_color}" in name_color_to_scan:
                        sub_btn = name_color_to_scan[f"{s_name}_{s_color}"]

                    if sub_btn and (sub_btn.path or sub_btn.text()):
                        sub_btn.color = getattr(sub_btn, "color", getattr(sub_btn, "_color", s_color))
                        sub_btn.is_sub_button = True
                        sub_btn.parent_folder = folder_btn
                        folder_btn.sub_buttons.append(sub_btn)
                        processed.add(sub_btn.path or f"{sub_btn.text()}_{sub_btn.color}")

                folder_btn.update_folder_icon = getattr(folder_btn, "update_folder_icon", lambda: None)
                folder_btn.update_folder_icon()
                new_main_buttons.append(folder_btn)
                processed.add(path or f"{name}_{color}")

            # —— 普通单词本 —— #
            elif typ == "wordbook":
                word_btn = btn or WordBookButton(name, color, parent=self.content)
                word_btn.color = color
                word_btn.app   = self.content
                word_btn.is_folder = False
                new_main_buttons.append(word_btn)
                processed.add(path or f"{name}_{color}")

        # ---------- 4. 把扫描到但布局缺失的按钮追加到末尾 ----------
        for b in current_buttons_from_scan:
            key = b.path or f"{b.text()}_{b.color}"
            if key not in processed:
                new_main_buttons.append(b)

        # ---------- 5. 写回 CoverContent ----------
        self.content.buttons = new_main_buttons
        self.content.update_button_positions()

# services/folder_service.py结束
services/folder_service.py结束

services/memory_service.py开始
# services/memory_service.py
"""
背单词 / 记忆曲线业务层。供 memory_curve.py 及未来其它 UI 使用。
"""
import pandas as pd
from datetime import datetime, timedelta

from repositories.memory_repository import MemoryRepository

# 复习间隔（与 db_memory 保持一致，集中管理更方便）
DEFAULT_INTERVALS = [0, 1, 2, 4, 7, 15, 30]


class MemoryService:
    # ---------- DataFrame 存取 ----------
    @staticmethod
    def load_memory_df(book: str, color: str) -> pd.DataFrame:
        return MemoryRepository.load_memory_df(book, color)

    @staticmethod
    def save_memory_df(book: str, color: str, df: pd.DataFrame) -> None:
        MemoryRepository.save_memory_df(book, color, df)

    # ---------- 今日待复习列表 ----------
    @staticmethod
    def get_review_words(book: str, color: str) -> list[dict]:
        return MemoryRepository.get_today_review_words(book, color)

    # ---------- 更新单词结果 ----------
    @staticmethod
    def record_answer(
        book: str, color: str, word: str, is_correct: bool, *,
        intervals: list[int] = DEFAULT_INTERVALS,
    ) -> None:
        """
        更新答题结果，并根据是否正确推算下一次复习时间（在 repo 内完成）。
        """
        MemoryRepository.update_word_status(book, color, word, is_correct)

services/memory_service.py结束

services/tag_service.py开始
# services/tag_service.py
"""
面向 UI 的标签业务层。
"""
from repositories.tag_repository import TagRepository

_MAIN_BOOK = "总单词册"
_MAIN_COLOR = "#FF0000"


class TagService:
    # ---------- 查询 ----------
    @staticmethod
    def list_tags(book: str, color: str) -> list[str]:
        return TagRepository.list_tags(book, color)

    # ---------- 新增 ----------
    @staticmethod
    def add_tag(book: str, color: str, tag: str) -> None:
        """向当前册添加标签，并确保同步到『总单词册』"""
        TagRepository.add_tag(book, color, tag)
        if book != _MAIN_BOOK:
            TagRepository.add_tag(_MAIN_BOOK, _MAIN_COLOR, tag)

services/tag_service.py结束

services/wordbook_service.py开始
"""services/wordbook_service.py
-------------------------------------------------
High‑level business logic façade used by every UI layer.
UI components must talk to this class instead of accessing repositories or
`db.py` directly.  The service orchestrates repositories, applies validation
or additional business rules (if any) and offers a *stable* API.
"""
from __future__ import annotations

from typing import Any, Dict, List

from repositories.word_repository import WordRepository


class WordBookService:
    """Business methods for word‑book CRUD operations."""

    # ------------------------------------------------------------------
    # READ
    # ------------------------------------------------------------------
    @staticmethod
    def list_words(book_name: str, book_color: str) -> List[Dict[str, Any]]:
        """Return all words from the specified book.

        Thin wrapper for :py:meth:`repositories.word_repository.WordRepository.list_words`.
        UI should always call this instead of repositories directly so that
        later we can introduce caching, filtering or async loading without
        touching UI code.
        """
        return WordRepository.list_words(book_name, book_color)

    # ------------------------------------------------------------------
    # CREATE / UPDATE (Up‑sert)
    # ------------------------------------------------------------------
    @staticmethod
    def save_word(
        book_name: str,
        book_color: str,
        data: Dict[str, Any],
        *,
        sync_to_total: bool = True,
    ) -> None:
        """Insert or update a word.

        Currently just delegates to the repository.  Validation hooks can be
        added here later (e.g. ensure the word field is not empty, strip
        whitespace, etc.).
        """
        WordRepository.save_word(
            book_name,
            book_color,
            data,
            sync_to_total=sync_to_total,
        )

    # ------------------------------------------------------------------
    # DELETE
    # ------------------------------------------------------------------
    @staticmethod
    def delete_word(book_name: str, book_color: str, word: str) -> None:
        """Delete a word from the specified book."""
        WordRepository.delete_word(book_name, book_color, word)

services/wordbook_service.py结束

styles.py开始
#styles.py
# 主题颜色
PRIMARY_COLOR = "#4CAF50"  # 绿色，可以修改
PRIMARY_COLOR_LIGHT = "#81c784"
SECONDARY_COLOR = "#2196F3" #蓝色，可以修改
SECONDARY_COLOR_LIGHT = "#64b5f6"

# 文字颜色
TEXT_COLOR = "#212121"
GRAY_COLOR = "#757575"
WHITE_COLOR = "#FFFFFF"

# 按钮样式
PRIMARY_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: {PRIMARY_COLOR};
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: {PRIMARY_COLOR_LIGHT};
    }}
    QPushButton:pressed {{
        background-color: {PRIMARY_COLOR};
    }}
"""

SECONDARY_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: {SECONDARY_COLOR};
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: {SECONDARY_COLOR_LIGHT};
    }}
    QPushButton:pressed {{
        background-color: {SECONDARY_COLOR};
    }}
"""

TEXT_EDIT_STYLE = """
    QTextEdit {
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5;
        padding: 4px;
        font-size: 23px;
    }
    QTextEdit:focus {
        border: 1px solid #444;
    }
"""

LINE_EDIT_STYLE = """
    QLineEdit {
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5;
        padding: 4px;
        font-size: 23px;
    }
    QLineEdit:focus {
        border: 1px solid #444;
    }
"""
SCROLL_AREA_STYLE = """
    QScrollArea {
        border: none;
    }
    QScrollArea > QWidget > QWidget {
        background-color: #f0f0f0;
    }
"""
TAG_COMBOBOX_STYLE = """
    QComboBox {
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: white;
        padding: 4px;
        font-size: 14px;
    }
    QComboBox:focus {
        border: 1px solid #444;
    }
"""
TAG_LABEL_STYLE = """
    QLabel {
        background-color: #e0e0e0;
        border-radius: 8px;
        padding: 3px 8px;
        margin-right:5px;
        margin-bottom:5px;

    }
"""

GREEN_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: {PRIMARY_COLOR};
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: {PRIMARY_COLOR_LIGHT};
    }}
    QPushButton:pressed {{
        background-color: {PRIMARY_COLOR};
    }}
"""

RED_BUTTON_STYLE = f"""
    QPushButton {{
        background-color: #FF4D4D;
        color: {WHITE_COLOR};
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 14px;
    }}
    QPushButton:hover {{
        background-color: #FF8080;
    }}
    QPushButton:pressed {{
        background-color: #FF4D4D;
    }}
"""

GRAY_INPUT_STYLE = """
    QLineEdit {
        border: 2px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5; /* 稍微置灰的背景 */
        padding: 4px;
        font-size: 23px;
        min-height: 30px;
    }
    QLineEdit:focus {
        border: 2px solid #444;
    }
"""

GRAY_TEXT_EDIT_STYLE = """
    QTextEdit {
        border: 2px solid #ddd;
        border-radius: 4px;
        background-color: #e5e5e5; /* 稍微置灰的背景 */
        padding: 4px;
        font-size: 23px;
        min-height: 30px;
    }
     QTextEdit:focus {
        border: 2px solid #444;
    }
"""

# 备注部分的样式
NOTE_TEXT_EDIT_STYLE = """
    QTextEdit {
        background-color: #e5e5e5;  /* 浅灰背景 */
        border: 1px solid #ddd;     /* 浅灰边框 */
        border-radius: 4px;         /* 圆角 */
        padding: 5px;               /* 内边距 */
        font-size: 26px;            /* 字体大小 */
        color: #333;                /* 深灰文字 */
    }
"""
styles.py结束

utils.py开始
#_utils.py
import os
import sys
print("开始加载pandas")
import pandas as pd

def get_word_book_path(book_name, color):
    """
    Get the path to the word book folder.

    Args:
        book_name (str): The name of the word book.
        color (str): The color of the word book.

    Returns:
        str: The path to the word book folder.
    """
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    directory = os.path.join(base_dir, "books")
    os.makedirs(directory, exist_ok=True)
    folder_name = f"books_{book_name}_{color}"
    path = os.path.join(directory, folder_name)
    return path


def get_tags_path(book_name, color):
    """
    Get the path to the tags.txt file.

    Args:
        book_name (str): The name of the word book.
        color (str): The color of the word book.

    Returns:
        str: The path to the tags.txt file.
    """
    path = get_word_book_path(book_name, color)
    return os.path.join(path, "tags.txt")

def get_excel_path(book_name, color):
    """
    Get the path to the words.xlsx file.

    Args:
        book_name (str): The name of the word book.
        color (str): The color of the word book.

    Returns:
        str: The path to the words.xlsx file.
    """
    path = get_word_book_path(book_name, color)
    return os.path.join(path, "words.xlsx")


def get_total_tags_path():
    """Get the path to the total word book's tags.txt file."""
    return get_tags_path("总单词册", "#FF0000")

def get_total_excel_path():
    """Get the path to the total word book's words.xlsx file."""
    return get_excel_path("总单词册", "#FF0000")

def clean_data(data):
    """Clean data to avoid writing NaN, None, and empty lists to Excel."""
    for key in data:
      if isinstance(data[key], list):
        # If the list is empty, it should be [] and not be converted to string
        if not data[key]:
            continue  # keep list as is
      elif pd.isna(data[key]) or (isinstance(data[key], str) and data[key].lower() == 'nan'):
            # Replace NaN values or "nan" string with an empty string
            data[key] = ""
    return data

# 此函数已被移除，数据合并逻辑已在db.py的save_word_to_total函数中实现

def get_all_word_books(exclude_main=True):
    base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    directory = os.path.join(base_dir, "books")
    word_books = []
    for folder in os.listdir(directory):
        if folder.startswith("books_"):
            if exclude_main and folder == "books_总单词册_#FF0000":
                continue
            word_books.append(os.path.join(directory, folder))
    return word_books

def get_note_text(self, word):
    if self.book_name == "总单词册":
        from utils import get_all_word_books
        import sqlite3
        import os
        all_word_books = get_all_word_books(exclude_main=True)
        notes_with_sources = []
        for wb_path in all_word_books:
            wb_name = os.path.basename(wb_path).split('_')[1]
            db_path = os.path.join(wb_path, "wordbook.db")
            if os.path.exists(db_path):
                try:
                    conn = sqlite3.connect(db_path)
                    cursor = conn.cursor()
                    word_str = str(word["单词"]).strip()
                    cursor.execute("SELECT note FROM words WHERE word = ?", (word_str,))
                    result = cursor.fetchone()
                    if result and result[0]:
                        note_str = result[0]
                        if note_str.strip():
                            notes_with_sources.append(f"来自 {wb_name}: {note_str}")
                    conn.close()
                except Exception as e:
                    print(f"Error getting note from {wb_name}: {e}")
        return "\n\n".join(notes_with_sources) if notes_with_sources else "无备注"
    else:
        note = word.get('备注', '无备注')
        return str(note) if note else "无备注"

utils.py结束

